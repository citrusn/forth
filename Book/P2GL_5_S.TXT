                    Глава 5. ФОРТ-АССЕМБЛЕР


   Важным средством  усиления  мощности Форта является Форт-ассемблер,
который обычно поставляется в  виде  библиотеки,  вводимой  в  словарь
стартовым   загрузчиком   или   самим   пользователем.  В  отличие  от
традиционных  ассемблеров,  где  сначала  пишется   программа,   затем
проводится трансляция и редактирование связей (линкирование) и наконец
загрузка и исполнение программы,  в  Форт-ассемблере  осталась  только
интерпретация,   совмещенная  с  загрузкой.  В  результате  в  словаре
появляются описания процедур,  которые по  своей  структуре  идентичны
примитивам системы Форт.

   Рассмотрим для  примера примитивы D+ (сложение чисел двойной длины)
для ЭВМ типа PDP (СМ1420) и IBM PC (ЕС1841).

       PDP                    IBM PC

   .BYTE     202               DB 202Q         ; байт длины имени
   .ASCII    /D+/              DB 'D'          ; имя
   .BYTE     240               DB 253Q         ; слова
   .WORD     LINK              DW LINK         ; ячейка связи (LFA)
   .WORD     .+2               DW $+2          ; CFA
   ADD (S)+,  2(S)             POP AX
   ADD (S)+,  2(S)             POP CX
   ADC (S)                     MOV SI, SP      ; установка указателя
                                               ; стека
                               ADD SS:[SI+2],   CX
                               ADC SS:[SI],     AX
   MOV (IP)+, WP               LODSW           ; NEXT (переход к
   JMP @(WP)+                  MOV BX, AX      ; следующей
                               JMP [BX]        ; процедуре)

   Если записать эту же программу на Форт-ассемблере (PDP):

   CODE D+ S )+ 2 S I) ADD S )+ 2 S I) ADD S() ADC NEXT C ;

получим в   словаре   описание,  тождественное  приведенному  в  левой
колонке.

   Рассмотренный пример   позволяет    также    представить    главные
ограничения   быстродействия   системы  Форт.  В  процессе  исполнения
примитива как минимум две команды чисто  служебные:  они  осуществляют
переход  к  исполнению следующей процедуры (NEXT).  Сократить их число
можно только с помощью специальных Форт-процессоров [41,  42].  А  так
как  Форт-программа - это,  в конечном счете,  цепочка примитивов,  ее
быстродействие  ограничено  именно  этими  издержками.   Чем   длиннее
примитив,  тем  меньше  непроизводительные  потери  памяти  и  времени
исполнения.  Но набор примитивов в базовом словаре фиксирован. Отчасти
именно   это   и   толкало   некоторых  разработчиков  на  переработку
Форт-программ, связанную с удалением лишних связей.

   Форт-ассемблер предоставляет  компромиссный  путь.  У  программиста
появляется  возможность  написать  критическую  по  времени исполнения
программу в виде одного или нескольких "длинных" примитивов.  При этом
потери  на  процедуры  CFA  и NEXT уменьшатся,  а удобство написания и
отладки,  которые предоставляет Форт,  останется. Программист может не
знать  почти  ничего об ЭВМ,  на которой работает.  Любой же ассемблер
предполагает знание и умение использования  машинных  команд.  В  этом
отношении  Форт-ассемблер  не составляет исключения.  С помощью выбора
мнемоники и описания часто встречающихся процедур можно лишь  сгладить
это  неудобство.  Машинозависимость ассемблеров делает их разнообразие
неисчислимым. К счастью, одной из особенностей Форта является простота
написания    интерпретатора    и   создания   Форт-ассемблера.   Объем
интерпретатора с Форт-ассемблера 40-60 строк текста.

   Перед тем как приступить к написанию программ Форт-ассемблера, надо
внимательно  ознакомиться  с  набором команд и основными особенностями
процессора,  на котором он будет работать.  В первую очередь,  следует
выяснить,  имеет  ли  процессор  аппаратный  стек  и сколько регистров
общего  назначения  доступно  программно.  Важно  также   знать,   как
осуществляется  доступ  к  оперативной  памяти  и внешним устройствам.
Полезно иметь информацию о том,  какие регистры и как  используются  в
интерпретаторе. Надо выбрать регистры указатели стека параметров (S) и
возврата (RP),  а также регистры-указатели  инструкции  (IP)  и  слова
(WP).  От  правильного выбора их зависит эффективность программы,  так
как  позволяет  уменьшить  число  операций   сохранения-восстановления
содержимого регистров.

   Как видно   из   структуры   примитивов,  назначение  ассемблера  -
преобразование    последовательности     мнемонических     кодов     в
последовательность машинных команд и запись ее в ячейки вслед за полем
CFA. Завершается эта последовательность командами перехода к следующей
процедуре.


                  5.1. ОПЕРАТОРЫ ФОРТ-АССЕМБЛЕРА


   Список операторов   Форт-ассемблера   (здесь   и   далее  ассемблер
MACRO-11) представлен в табл.21.  Этот список,  так же как и в системе
Форт,  открытый.  Пользователь  может  добавить в него любой оператор,
если,  например,  приобретен процессор с расширенным набором команд. В
рассмотренной   реализации  Форт-ассемблера  имеются  практически  все
команды ЭВМ,  совместимой с  машинами  СМ1420.  Описание  оператора  в
Форт-ассемблере имеет следующий формат:

   CODE<NAME> { <опер1> MODE <опер2> MODE <КОП> } NEXT C; где <NAME> -
имя  нового  оператора;  <опер1>  и  <опер2>  -   операнды   1   и   2
соответственно  (число  операндов  зависит  от  типа команды);  MODE -
указатель типа адресации (может отсутствовать);  <КОП> - код операции;
NEXT  C;  -  оператор  перехода  к  следующей процедуре (в Форт-83 это
оператор END-CODE).  В области,  выделенной фигурными скобками,  может
быть  любое  число  команд.  Когда  мнемокоды  Форт-ассемблера и Форта
совпадают,  в Форт-ассемблере в начале  имени  добавляется  звездочка,
хотя  и  необязательно (см.  операторы *IF,  *ELSE и т.д.  в табл.21).
Оператор Форт-ассемблера,  содержащий 10 команд,  выполняется  на  20%
дольше программы,  написанной в машинных кодах. В Форт-ассемблере, так
же как и в системе Форт,  метки,  как правило,  не используются. (Хотя
метки  в  Форте и можно ввести,  но это,  так же как и прямая нотация,
лишит его  некоторых  преимуществ.)  Это  является  причиной  введения
операторов циклов и условных переходов.

   Операторы Форт-ассемблера  в  процессе  интерпретации  заносятся  в
словарь  с  именем  ASSEMBLER  и  в  дальнейшем  могут   употребляться
совместно с другими словами при описании новых операторов Форта.

Таблица 21. Операторы (мнемокоды) Форт-ассемблера СМ ЭВМ
----------------------------------------------------------------------
   Имя                          Функция
(мнемокод)
----------------------------------------------------------------------
CODE        Эквивалентно функции ":" системы Форт

#           Эквивалентно символу # в MACRO-11, но ставится не перед, а
            после числа и отделяется от него пробелом

)+          Соответствует форме (Rn)+ в MACRO-11, где Rn - имя
            регистра общего назначения

@+          Соответствует @(R)+ в MACRO-11

-)          Эквивалентно -(R)

@-)         Эквивалентно форме адресации @-(Rn)

1)          Соответствует форме X (Rn), где X - целое число

@1)         Эквивалентно форме адресации @X(Rn)

@#          Соответствует @# в MACRO-11, но ставится после числа или
            символического имени и отделяется от него пробелом

()          Эквивалентно форме адресации (Rn)

NEXT C;     Заменяет оператор ";" Форта

*IF         Аналоги соответствующих операторов Форта
*ELSE*BEGIN
*WHILE *UNTIL
*REPEAT
*THEN
----------------------------------------------------------------------

   Форт-ассемблер пригоден  для управляющих программ внешних устройств
и всех случаев, когда время исполнения является важной характеристикой
программы. Преимущество Форт-ассемблера перед обычным макроассемблером
- возможность немедленного исполнения сразу после написания  программы
(ведь трансляция и редактирование связей не нужны). Примером программы
на  Форт-ассемблере  может  служить  описание  процедуры   определения
абсолютного значения числа, лежащего в стеке (AABS), результат так же,
как и в случае ABS, записывается в стек:

      CODE AABS S () TST LT *IF S () NEG * THEN NEXT C;

При обращении - 5 AABS . ЭВМ откликнется 5 ОК.
					 - --
   Словарь ASSEMBLER  является  частью  словаря  системы  Форт.  Адрес
программы  CFA,  выполняющей  описанную  процедуру,  в  системе Форт в
случае Форт-ассемблера,  как и в примитивах,  всегда тождествен адресу
PFA (поля параметров).  В ячейках после CFA хранятся машинные команды,
которые реализуют  функции  TST  (S)  и  т.д.  (S  -  указатель  стека
параметров).  Последние  две команды обеспечивают возврат к программе,
откуда было обращение к описанной процедуре.  Из приведенного  примера
видно,  что в Форт-ассемблере также используется постфиксная нотация -
мнемокод,  указывающий  на  тип  адресации,  записывается  после  кода
операнда  и отделяется от него пробелом.  Мнемокод операции (например,
TST) пишется после операндов (а не перед ними, как в макроассемблере!)
и также отделяется пробелом.

   Приведем еще один пример оператора Форт-ассемблера:

      OCTAL           ( установка восьмеричной системы счисления)

      CODE AEMIT *BEGIN 200 # 177564 @# BIT NE *UNTIL ( ожидание)
                 S () 177566 @# MOV NEXT C; DECIMAL

   Оператор AEMIT выполняет операцию EMIT, описанную в Форте (работает
для  микроЭВМ  типа  ДВК).  При обращении 87 AEMIT ЭВМ выдаст W ОК.  В
данном примере слово NE совершенно необходимо:  именно  оно  формирует
соответствующим  образом  флаг  условия  для  оператора *UNTIL.  Таким
образом,  для всех случаев, где требуется проверка условия, необходимо
использовать соответствующий оператор из табл.22.

Таблица 22. Операторы Форт-ассемблера СМ ЭВМ
----------------------------------------------------------------------
    Имя                      Функция
----------------------------------------------------------------------
EQ          Формирует флаг для условных операторов перехода типа
            *IF, и т.д. f=TRUE, если предшествующий результат равен 0

NE          То же, что и EQ, но f=TRUE, если предшествующий результат
            не равен 0

MI          То же, но f=TRUE, если предшествующий результат - число со
            знаком "минус"

PL          То же, но f=TRUE, если предшествующий результат - число со
            знаком "плюс"

LT          f=TRUE, если предшествующий результат меньше 0

GT          f=TRUE, если предшествующий результат больше 0

LE          f=TRUE, если результат больше или равен 0

GE          f=TRUE, если результат больше или равен 0

VS          f=TRUE, если бит переполнения 1

VC          f=TRUE, если бит переполнения 0

CS(LO)      f=TRUE, если бит переноса 1

CC(HIS)     f=TRUE, если бит переноса 0

HI          f=TRUE, если биты переноса (C) и нулевого результата (Z)
            равны 0

LOS         f=TRUE, если C=Z=1
----------------------------------------------------------------------

   Как же работает интерпретатор Форт-ассемблера? Обычно ок пишется на
Форте.  Его  текст  начинается со слов VOCABULARY ASSEMBLER IMMEDIATE.
Возможен  вариант,  когда  оператор   словаря   не   является   словом
немедленного исполнения, но это сделает некоторые последующие описания
более громоздкими и  менее  читаемыми.  Одним  из  главных  операторов
интерпретатора  является  CODE.  Именно  он вносит в словарь имя слова
Форт-ассемблера. Его структура становится понятной из описания:

      : CODE CREATE [COMPILE] ASSEMBLER;

   CODE, так же как и ASSEMBLER,  является словом  из  словаря  FORTH.
Далее   должны   следовать  слова-описания  процедур  Форт-ассемблера,
поэтому здесь  необходимо  записать  в  текст  интерпретатора  команду
ASSEMBLER DEFINITIONS.

   Двумя другими  универсальными  операторами Форт-ассемблера являются
NEXT и C;. Описание NEXT:

      : NEXT IP )+ WP MOV WP @) + JMP ;

полностью соответствует  программе  в   начале   гл.5.   Оператор   C,
комбинирует некоторые функции Форт-операторов ":" и ";":

      : C; CURRENT @ CONTEXT ! SMUG ;

   CODE и C,  могут включать сохранение-восстановление значения BASE и
контроль неизменности указателя стека параметров.

   Вы, возможно, уже обратили внимание на две сходные структуры : CODE
<NAME>  XXXXX  NEXT  C;  и  :  <NAME> XXXXX,  (например,  в только что
описанной  процедуре  NEXT),  XXXXX  -  последовательность  мнемокодов
Форт-ассемблера.  Вторая структура,  знакомая из базового Форта, может
показаться идентичной первой, но это не так. Первая формирует описание
оператора  Форта,  которое  при  обращении выполнит последовательность
машинных команд,  соответствующую мнемокодам,  вторая начиная с первой
свободной  ячейки,  указанной  HERE,  скомпилирует  последовательность
машинных кодов,  которая соответствует  тексту  между  <NAME>  и  ";".
Другими словами,  первая структура формирует исполняемую программу,  а
вторая - компилирующую. Таким образом, возможна комбинация:

              : TEST *BEGIN R4 () TST PL *UNTIL ;
                CODE PUT TEST R0 R5 () MOV NEXT C;

Оператор TEST  скомпилирует  необходимый  нам  кусок программы в слове
PUT.   Операторы    типа    TEST    фактически    выполняют    функции
макроопределений.

   А зачем рядовому программисту знать, как работает интерпретатор или
как  его  написать?  Во-первых,  интерпретатор  Форт-ассемблера  может
отсутствовать  в  вашей  библиотеке,  а  во-вторых,  его  очень  легко
написать.  Здесь же поясним основные идеи.  Предположим,  что мы хотим
описать   команды,   где  в  качестве  операндов  используются  только
содержимое регистров общего назначения. Опишем сначала эти регистры:

        0 CONSTANT R0     1 CONSTANT R1     2 CONSTANT WP
        3 CONSTANT R3     4 CONSTANT IP     5 CONSTANT S
        6 CONSTANT RP

   Введем слово WW:

            OCTAL
            : WW <BUILDS , DOES> @ ROT 100 * + + , ;

которое является  описателем операций типа регистр-регистр.  Следующим
шагом должно быть описание команд,  например:  10000 WW MOV,  20000 WW
CMP,  30000  WW  BIT  и т.д.  Теперь,  если в описании какого-то слова
встретится команда R1 R3 MOV, в соответствующую ячейку PFA этого слова
будет  занесен восьмеричный код 10103,  который соответствует машинной
команде,  выполняющей операцию MOV для этих регистров.  Конечно,  WW -
это нереальный оператор,  здесь не учтено все многообразие модификаций
адресации,  непосредственные операнды и т.д.,  но форма описания самих
команд MOV, CMP и т.д. соответствует настоящему интерпретатору.

   Для безоперандных  команд  типа  CLC,  HALT,  NOP,  RTI все гораздо
проще. Достаточно ввести описание слова OP:

      : OP *BUILDS , DOE> @ , ;

а вслед за ним описать все такие команды:  2 OP RTI, '240 OP NOP, '240
OP CLC и т.д.

   Следующий по сложности уровень представляют команды ветвления.  Для
них нужно ввести описатель BRO:

      OCTAL

      : BRO <BUILDS , DOES> @ , HERE - DUP 376 > OVER -400 < OR
        IF ." ILL BRANCH" THEN 2/ 377 AND HERE CFA SWAP OVER
        @ OR SWAP ! ;

и вслед за этим описать все команды ветвления:  400 BRO BR,  1000  BRO
BNE, 1400 BRO BEQ и т.д.

   Ознакомившись с этим,  а также имея примеры из приложения 2 и 6, вы
без труда сможете написать интерпретатор  Форт-ассемблера  для  нового
процессора.  Не  забудьте завершить свой текст интерпретатора командой
FORTH DEFINITIONS DECIMAL.



                  5.2. РАБОТА С ФОРТ-АССЕМБЛЕРОМ


   Рассмотрим некоторые    примеры    использования   Форт-ассемблера.
Предположим, мы хотим описать процедуру сложения для чисел с плавающей
точкой на ЭВМ,  где есть операция FADD (ДВК-4, СМ1420). Такое описание
будет иметь вид

      CODE F+ S FADD NEXT C;

   F+ - имя этого слова. При обращении f1 f2 F+, где f1 и f2 - числа с
плавающей точкой, F+ удалит из стека четыре кода одинарной длины (f1 и
f2) и на их место запишет два кода (f3),  представляющие  собой  сумму
f1+f2.

   Другим примером может служить оператор FABS, который заменяет число
с плавающей точкой, записанное в стек, его абсолютным значением:

      CODE FABS'100000 # S (/\) BIC NEXT C;

   Команда 2>R,  описанная в приложении 2,  пригодна как для  чисел  с
плавающей  точкой,  так  и для кодов двойной длины,  она переносит два
верхних числа из стека параметров  в  стек  возвратов.  Описание  этой
процедуры в Форт-ассемблере:

      CODE 2>R S )+ RP -) MOV S )+ RP -) MOV NEXT C;

   Может показаться,  что это эквивалентно : 2>R >R >R ;. Попробуйте и
убедитесь в обратном.  Весьма вероятно, что вам придется перезагрузить
систему,  так  как  изменение  указателя  стека возвратов в структурах
<name> ...;  ведет к тому,  что оператор  ;S,  к  которому  произойдет
обращение  в  конце исполнения,  передаст управление процедуре,  адрес
которой хранится в стеке  возвратов.  А  что  там  окажется  в  данном
случае,  предугадать весьма сложно.  В этом еще одно отличие примитива
от  описания  :  <name>  ...;.  Последние  для  перехода  к  следующей
процедуре используют стек возвратов, а примитивы нет.

   Примером условных  переходов  в Форт-ассемблере может служить слово
F0> (библиотека для работы с числами с плавающей точкой):

      ASSEMBLER DEFINITIONS OCTAL
      CODE F0> 2 S I) CLR        ( обнуление младшей части мантиссы)
               S )+ TST GT       ( формирование флага, если
                                   число меньше 0 )
               *IF S () INC      ( запись в стек 1, если число
                                   больше 0)
               *THEN NEXT C;
      FORTH DEFINITIONS DECIMAL

   F0> проверяет число с плавающей точкой,  находящееся в стеке:  если
оно больше нуля, заменяет его флагом =1, в противном случае нулем.

   Более сложным примером использования Форт-ассемблера может  служить
процедура  извлечения  квадратного  корня  из числа с плавающей точкой
(SQRT) в стеке (алгоритм Герона [37]):

      : SQRT 2DUP 2/ '17600 AND '40000 OR
             5 0 DO ( начало итеративного процесса, число итераций
                      равно 5)
             2OVER 2OVER F/ F+ 2Е F/ LOOP ( конец итераций)
             2SWAP 2DROP ;

   Операторы Форт-ассемблера F/ и  F+  выполняют  операции  деления  и
сложения  над числами с плавающей точкой;  2Е - число 2.0 (с плавающей
точкой).

   Другое важное  приложение  Форт-ассемблера  -  написание   программ
прерывания,     где    время    исполнения    является    определяющей
характеристикой.  Но об этом речь пойдет позже.  Сейчас же  посмотрим,
как будет выглядеть примитив U<, написанный на Форт-ассемблере:

   CODE U<   AX POP   CX POP   CX AX CMP   AB  ( Формирование Флага
                                                 для IF)
             *IF      1 AX MOV                 ( Флаг = TRUE )
             *ELSE    0 AX MOV                 ( Флаг = FALSE)
             *THEN    AX PUSH NEXT C;   ( запись Флага в стек)

AB - оператор "превышает" (ABOVE).  Программа написана  на  ассемблере
персонального компьютера типа IBM PC.  Для ЭВМ СМ1420 эта же программа
будет выглядеть так:

            CODE U<  S )+ S () HI  *IF 1 # S () MOV
				   *ELSE S () CLR
                                   *THEN NEXT C;

   Следующую программу  на  Форт-ассемблере  предлагаю написать самим.
Пусть необходимо просуммировать числа натурального ряда от 1 до N, N в
стеке.  Составьте  описание  слова  SUM,  которое  решает эту задачу и
записывает в стек результат. Сделайте это сначала на Форте, а затем на
Форт-ассемблере. Ответ для последнего варианта:

      CODE SUM S ()  R1  MOV           ( внесение N в счетчик R1)
               S -)  CLR               ( очищение "сумматора")
               *BEGIN   R1  S ()  ADD  ( суммирование )
               R1 DEC   LE *UNTIL NEXT C;

   Теперь, если напечатать 10 SUM., ЭВМ откликнется 55 OK.
                                                    -- --
   Как только Форт-ассемблер  заработал,  для  вас  стали  доступны  и
программные запросы,  выполняемые через операционную систему с помощью
команды EMT (для ЭВМ СМ1420) или INT (для персональных ЭВМ).

   А как быть,  если нужно написать  небольшую  программу  в  машинных
кодах, а Форт-ассемблера нет или его загрузка нежелательна? Это вполне
возможно,  хотя и трудоемко.  Для решения задачи надо  написать  текст
программы в машинных кодах, а затем записать

      CODE <NAME> C1 , C2 ..., Cn , NEXT C;

где C1,  C2,...,Cn  - последовательность кодов,  образующая программу.
Запятые в описании слова <NAME> - это не знаки препинания, а операторы
записи   кодов   C1,   C2,...  в  описание.  Если  программа  содержит
команды-байты,  то после них вместо запятой следует  писать  C,.  Если
использовать  описания  CODE  и  NEXT,  то  такая программа может быть
реализована непосредственно в системе Форт.

   Интересные возможности при написании  программ  на  Форт-ассемблере
предоставляет  оператор  ;CODE,  который  работает  исключительно  при
компиляции и используется в структурах слов-описателей вида

      : <name> XXX CREATE YYY ;CODE ZZZ NEXT C;

где XXX - обычная Форт-программа;  YYY - часть программы,  выполняемая
при   компиляции  (см.  гл.2);  ZZZ  -  последовательность  мнемокодов
Форт-ассемблера. Обращение к такому слову-описателю имеет форму:

      <name> <ИМЯ>,

где <name> - имя слова-описателя;  <ИМЯ> - имя сгенерированного нового
слова,  причем CFA слова <ИМЯ> будет содержать адрес начала программы,
текст которой лежит между ;CODE и NEXT в слове-описателе.  В сущности,
вам  предоставляется  шанс создать принципиально новый вид слов,  где,
например,  содержимое  поля   параметров   будет   обрабатываться   по
программе,   составленной   вами.   Стандартные  типы  таких  программ
предоставляют операторы :  <name> ...;,  VARIABLE,  CONSTANT. Аналогом
;CODE  можно  считать DOES>,  где исполнительная программа написана на
Форте, а не на ассемблере, как в ;CODE.

   Упражнение 1.
   Опишите на ассемблере оператор -ROT (см. табл.2).

   Решение. Для IBM PC

   CODE -ROT AX POP CX POP SI POP AX PUSH SI PUSH CX PUSH
	NEXT END-CODE

Для СМ ЭВМ

   CODE -ROT  R5 )+ R0 MOV  R5 )+ R1 MOV  R5  )+ R2 MOV
              R0 R5 -) MOV  R2 R5 -) MOV  R1  R5 -) MOV
              NEXT C;

   Упражнение 2.
   Опишите слово 2*, используя Форт-ассемблер. Решение смотри в тексте
интерпретатора Форта (приложение 9).

   Упражнение 3.
   Опишите оператор    для    извлечения    квадратного    корня    на
Форт-ассемблере (см.  SQRT в приложении  2).  Напишите  программу  для
оценки времени исполнения операторов и сравните их быстродействие. Для
этого  можно  использовать  внутренние  часы  ЭВМ.  Здесь  также   вам
пригодится  ассемблер,  так  как  одним  из путей доступа к внутренним
часам является применение команды EMT для СМ ЭВМ или INT для IBM PC.
