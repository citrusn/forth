                   ЧАСТЬ 1. ОСНОВЫ ЯЗЫКА ФОРТ

             Глава 1. СТРУКТУРА ЯЗЫКА И РЕЖИМЫ РАБОТЫ



   Основной конструкцией языка Форт для описания процедур является

      : <NAME> <A1 A2... An> ;

где <A1 A2...  An> - список имен слов (операторов),  описания  которых
хранятся в словаре Форта и которые должны быть исполнены при обращении
к слову с именем <NAME>. Описание слова начинается с ":" и завершается
";".  Единственным  разрешенным  разделителем слов в описании является
пробел.  В некоторых версиях разделителем  может  быть  <ВК>  (Возврат
каретки).

   Имя может  содержать любые символы,  кроме пробелов,  отделяется от
двоеточия и последующего списка имен пробелом.  В имени не должно быть
более  31  символа,  но этот предел (в версии FIG) можно регулировать,
изменяя значение системной переменной  WIDTH.  При  загрузке  слова  с
именем,  уже имеющимся в словаре,  "старое" слово не будет забыто,  но
доступа к нему в последующих описаниях не будет.

   Список имен в описании любого слова Форта может содержать операторы
базового  словаря  или  слова,  описанные  и загруженные пользователем
ранее. В новом описании одно имя слова от другого отделяется пробелом.
Между  последним  именем  в  списке  и  ";"  также должен быть пробел.
Например, записано слово

      : SQUARE DUP * . ;

   Обратиться к нему можно немедленно:  10 SQUARE <ВК>,  и  на  экране
появится 100 OK.  Здесь и далее <ВК> означает нажатие клавиши "Возврат
каретки" или ее заменяющей. Подчеркиванием отмечается отклик на экране
терминала,  чтобы  его можно было отличить от текста,  вводимого самим
программистом.

   При работе с Фортом нужно очень  внимательно  относиться  к  знакам
препинания (":", ".", ";", >?", ","), так как они также слова базового
словаря Форта,  а  не  просто  значки,  упрощающие  чтение  текста.  В
примерах  присутствует  оператор  ".".  Он  извлекает  число из стека,
преобразует его  с  учетом  действующей  системы  счисления  в  строку
символов и выводит на экран.

   Одной из   важнейших   особенностей   Форта   является  постфиксная
(обратная польская)  нотация  -  сначала  записываются  операнды,  над
которыми должно быть выполнено действие, и только затем знак операции.
К примеру, нужно вычислить произведение 12x11. в этом случае вы должны
записать 12 11 * .  <ВК>,  и на экране будет 132 OK,  где OK означает,
что операция выполнена  успешно  (с  точки  зрения  ЭВМ).  Постфиксная
запись  -  одна  из  причин неприятия некоторыми программистами Форта,
ведь с начальной школы мы усвоили,  что следует писать 2 x 2 = 4, а не
2 2 *.

   Для хранения  исходных  данных  и  результатов в Форте используется
стек.  Особенностью такой структуры является последовательная запись и
чтение чисел.  Причем число,  записанное в стек первым,  будет считано
последним.  При этом никакого перемещения  информации  не  происходит,
изменяется  только  содержимое  регистра-указателя  стека  (иногда его
функций исполняет специальная ячейка памяти,  но это менее удобно).  В
некоторых  ЭВМ  арифметические  операции  выполняются  над  числами  в
аппаратном стеке.  Операции со стеком являются  основным  инструментом
любого  интерпретатора,  именно  поэтому Форт так удобен для написания
трансляторов.  Применение  стека  и  постфиксной  нотации  органически
согласуется  с  аппаратными возможностями современных ЭВМ,  что делает
Форт весьма эффективным.

   Операнды записываются  в  стек  непосредственно  или  в  результате
выполнения предшествующих процедур.  Оператор вызывает их из стека,  а
на их место записывается результат работы -  число  или  числа.  Схема
преобразования стека следующая:

      ОП1 ОП2... ОПМ --Р1 Р2... РК,

где ОП1 ОП2 ...  ОПМ - М операндов, находящихся в стеке до операции (М
обычно фиксировано для каждого оператора,  может быть равно нулю);  Р1
Р2  ...  РК - коды результата,  их число К,  как правило,  постоянно и
также может равняться нулю.

   Все числа,  вводимые с терминала,  в конце концов попадают в  стек.
Так,  если набрать 1 2 3 4 5..... <ВК>, ЭВМ выдаст 5 4 3 2 1 OK. Здесь
пять  точек  -  это  не  многоточие,  а  пять  операторов  отображения
содержимого  стека на терминале.  Каждая точка должна быть отделена от
предшествующего и  последующего  текста  пробелами.  Количество  точек
должно  быть  равно  количеству  чисел  в  стеке,  которые мы намерены
удалить из стека и напечатать.  При попытке записать  в  стек  слишком
большое  количество  чисел  или  извлечь  что-то  из  "пустого"  стека
возникнет сообщение об ошибке. Перед каждой записью значение указателя
стека  уменьшается,  а после чтения увеличивается на 2.  Это связано с
тем,  что стек в Форте  обычно  содержит  только  16-разрядные  числа.
Последнее справедливо для микро- и мини-ЭВМ, в общем случае приращение
указателя стека может быть иным. Еще один пример:

      : ONEMORE 1+;

   Если теперь набрать 5 ONEMORE .  <BK>,  то в ответ  получим  6  ОК.
Вновь  определенное  слово  при  обращении  к нему добавляет 1 к числу
находящемуся на вершине стека.  При  этом  число  в  стеке  заменяется
полученным  результатом.  В данном случае в стеке вместо 5 окажется 6,
это число можно использовать в дальнейших расчетах. Наберем

      7 3 * ONEMORE. <BK>

и немедленно получим на экране 22 ОК.

   Постфиксная нотация  тесно  связана  с  использованием  стека  куда
записываются как исходные данные,  так и результаты. В вышеприведенном
примере до выполнения операции в стеке хранились числа 7 и 3 (здесь  и
далее  число,  записанное  справа,  расположено  в  стеке "выше числа,
записанного слева).  После выполнения операции умножения (*)  в  стеке
остается 21,  оператор ONEMORE заменяет его на число 22,  оператор "."
удаляет 22 из стека,  возвращая его в состояние  которое  он  имел  до
ввода числа 7.  При постфиксной нотации возможны операции типа a b с *
+.  При этом результат будет равен a +  (b  *  c).  Как  преобразуется
содержимое стека при той или иной операции? Воспользуемся схемой a1 a2
a3 --> a,  где a1,  a2 и a3 - числа,  находящиеся в стеке до операции,
причем  a3  на верху стека;  справа от стрелки отображается содержимое
стека после выполнения операции.  В традиционных языках  для  хранения
промежуточных результатов используются специальные рабочие переменные.
В Форте  это  также  возможно  весьма  нерационально,  для  этой  цели
используется стек.

   Базовый словарь Форта оперирует только целыми числами. Причем, если
специально не оговорено,  то подразумевается,  что эти числа одинарной
длины (16-разрядные). Допустимый диапазон результатов -32768...+32767.
Именно такие числа называются  в  Форте  числами  одинарной  длины  со
знаком.  Поэтому  выполнение  операции  1024  128  *  дает  совершенно
бессмысленный результат - произведение больше 32768.  Определив  слово
SECONDS, которое вычисляет число секунд в часах:

      : SECONDS 3600 * ;

мы можем  рассчитывать на правильный ответ,  только если число часов <
или  =  9.  Так,  9  SECONDS  .  <BK>  даст  32400  ОК.  При   попытке
воспользоваться  этим  словом  для  числа  10 и более получим неверный
результат. Для правильного решения подобных задач требуются операции с
числами    двойной   длины   (здесь   и   далее   для   определенности
предполагается, что память ЭВМ 16-разрядная).


                  1.1. АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ


   Список стандартных арифметических операторов приведен в табл. 1. Во
второй  колонке  показана  трансформация  стека  в процессе исполнения
команды: слева от стрелки состояние до операции, справа - после.

   Арифметические операции над числами выполняются  в  соответствии  с
порядком  их  записи.  Здесь  не  действуют  никакие  правила иерархии
операций. Так, выполнение операции а b с + * даст результат (b+c)*a.

Таблица 1. Арифметические операторы
----------------------------------------------------------------------
Имя	Состояние стека             Версия    Функция
----------------------------------------------------------------------
+       n1 n2 --> n1 + n2           9, 3, F   Сложение

-       n1 n2 --> n1 - n2           9, 3, F   Вычитание

*       n1 n2 --> n1 * n2           9, 3, F   Умножение

/       n1 n2 --> n1 / n2           9, 3, F   Деление

/MOD    u1 u2 --> u-rem u-quot      9, 3, F   Деление с остатком

MOD     u1 u2 --> u-rem             9, 3, F   Получение остатка

1+      n --> n+1                   9, 3, F   Прибавление 1

1-      n --> n-1                   9, 3, F   Вычитание 1

2+      n --> n+2                   9, 3, F   Прибавление 2

2-      n --> n-2                   9, 3      Вычитание 2

2*      n --> n*2                   9, 3, F   Умножение на 2

2/      n --> n/2                   9, 3, F   Деление на 2

ABS     n --> |n|                   9, 3, F   Получение абсолютного
                                              значения
                                    G
MINUS   n --> - n                   F         Смена знака числа в
                                              стеке
NEGATE                              9, 3

MIN     n1 n2 --> n-min             9, 3, F   Выделение минимума

MAX     n1 n2 --> n-max             9, 3, F   Выделение максимума

*/      n1 n2 n3 --> (n2*n1)/n3     9, 3, F   Умножение с
                                              с последующим делением.
                                              Результат умножения -
                                              32-разрядное число

*/MOD   u1 u2 u3 --> u-rem u-result 9, 3, F   u1*u2/u3 - остаток и
                                              частное, u1 u2 - 32-
                                              разрядное число

U*      u1 u2 --> ud                9, F      Числа u1 u2 - 16-
                                              разрядные без знака,
                                              u1*u2 - 32-разрядное
                                              число

U/      ud u1 --> u2                F         Деление 32-разрядного
                                              числа без знака на 16-
                                              разрядное

Примечание. 9 и З - стандарты Форт-79 и Форт-83; F - FIG-FORTH;
            G - GraFORTH.
----------------------------------------------------------------------

   Для ускорения выполнения простых, но часто встречающихся операций в
базовый  словарь  некоторых  версий   Форта   введены   однооперандные
операторы   1+,1-,2+,2-,2*   и   2/.  Разумеется,  эти  функции  можно
реализовать с помощью еще более простых операторов:  1 +;  1 -; 2 +; 2
-; 2 *; и 2 /. Однако такая реализация в 1,5-2 раза медленнее, так как
требует сначала записи числа 1 (или 2).  Кроме того,  операции 2* и 2/
выполняются   простым  арифметическим  сдвигом  и  никакого  реального
умножения или деления не производится. К этому ряду процедур примыкают
операторы ABS - замена числа в стеке его абсолютным значением и NEGATE
(в  некоторых  версиях  MINUS)  -  замена  знака  числа  в  стеке   на
противоположный.

   Большинство арифметических  операций  достаточно просты и способ их
записи очевиден из табл.  1. Некоторого пояснения требуют, может быть,
только  вычитание  ("-")  и  деление ("/"),  для которых небезразлично
положение операндов в стеке.  Так,  10 2 /.  <ВК> дает 5 OK, а 2 10 /.
<ВК>  дает  0  OK.  Во втором случае с учетом целочисленности операций
получается нулевой результат. Аналогично 5 3 - . <ВК> дает на экране 2
OK,  а 3 5 - .  <ВК> дает - 2 ОК. К этому же типу операторов относятся
/MOD  и  MOD.  Первый  выполняет  деление  целых  положительных  чисел
одинарной длины с остатком, например

      10 3 /MOD ..<ВК> 3 1 OK.

   Обратите внимание  -  частное наверху стека.  У некоторых читателей
может возникнуть недоумение,  ведь  ранее  говорилось,  что  "верхнее"
число в стеке записывается слева.  На самом деле никакого противоречия
нет,  3 действительно находится в стеке над 1,  просто здесь  показано
то, что выдаст ЭВМ на экран. А первым на экране отображается "верхнее"
число из стека.  Оператор MOD  определяет  остаток  от  деления  целых
положительных  чисел одинарной длины,  например 10 3 MOD.  <ВК> даст 1
OK, a 3 10 MOD даст 3.

   Рассмотрим конкретную задачу. В массиве 1024 элемента сгруппированы
в  строки  длиной по 64 элемента.  Нужно определить,  в какой строке и
каком столбце находится элемент 724.  Решение: 724 64 /MOD . . . Ответ
11 20 OK означает,  что данный элемент расположен в 11-й строке и 20-м
столбце.  При этом предполагается,  что строки и столбцы пронумерованы
начиная с 0.

   Особый интерес могут представлять операторы */ и */MOD.  Уже не раз
обращалось внимание на ограничения,  связанные  с  разрядностью  чисел
(переполнение).  Это  обстоятельство  весьма важно,  так как во многих
версиях  Форта  переполнение  не  вызывает  прерывания   и   программа
продолжает  работать  как ни в чем не бывало,  выдавая непредсказуемые
результаты.  Указанные  операторы  отчасти  снимают  эти  ограничения.
Функционально  */  и  */,  а  также  */MOD  и  *  /MOD в какой-то мере
эквивалентны.  Отличие   заключается   в   том,   что   для   хранения
промежуточного  результата  этих  операций  используется  32  разряда.
Например:

      4096 128 64 * / . <ВК> 8192 OK ([4096x128]/64).

   Если попытаться  выполнить  эту  операцию,  используя  *  и  /,  то
результат будет неверным из-за переполнения. Можно, разумеется, решить
задачу и иначе:

      4096 64 / 128 *

   Но в общем случае это  может  дать  менее  точный  ответ,  так  как
результат деления - целое число (остаток отброшен), например

      4097 128 64 */. <ВК> 8194 OK
      4097 64/128 *. <ВК> 8192 OK

   Последний результат неточен.  Конечно,  можно,  используя  оператор
/MOD получить правильный ответ и другим путем, но применение */ проще.

   В качестве  еще одного простого примера рассмотрим работу с числами
с плавающей точкой,  применяя  только  целочисленные  операции.  Пусть
требуется  вычислить  длину  гипотенузы равнобедренного треугольника с
длиной стороны 5 см.  Как известно,  искомая длина равна 5 х √2 (√2  =
1,4142). Требуемые вычисления с достаточной точностью можно проделать,
и не прибегая к "плавающей" арифметике:

      5 14142 100 */.<ВК> 707 OK

что соответствует 7,07.  Понятно, что такие "фокусы" лучше оставить на
крайний случай.  При решении подобных задач правильнее воспользоваться
библиотекой процедур для чисел с плавающей точкой.

   Остановимся еще на двух операторах MIN и  MAX,  которые  сравнивают
два  верхних  числа в стеке и оставляют там только меньшее или большее
соответственно:

      3 4 MIN. <ВК> З ОК и 34 MAX. <ВК> 4 ОК

   В первом случае 4,  а во втором 3 будут удалены из стека.  На самом
деле  благодаря  операции  "."  в  обоих  случаях  стек возвращается в
состояние, которое он имел до ввода чисел 3 и 4.

   В Форте скобки не  используются,  что  может  создать  определенные
трудности.   Для   их  преодоления  предусмотрен  набор  операций  для
манипулирования числами в стеке (см.  1.2). Однако следует заботиться
о том, в какой последовательности записываются числа в стек. Например,
вычисление (3+9) (4+6) может быть выполнено без перестановки  чисел  в
стеке:

      39 + 46 + *. <ВК> 120 ОК.

   Если же в стек записаны числа 3 9 4 6,  то без перестановок в стеке
поставленную задачу уже не решить. Однако не всегда удается "выложить"
числа  в  стек  так,  чтобы  можно  было  произвести  над  ними нужные
арифметические  действия,  не  меняя  их  порядка   в   стеке.   Когда
столкнетесь с такой ситуацией, вспомните об операциях со стеком.

   Арифметические операции  с  числами  двойной  длины  и  с плавающей
точкой будут рассмотрены позже (гл. 3 ч. II).


                    1.2. ОПЕРАЦИИ СО СТЕКОМ


   Вернемся к задаче вычисления (а-b)с,  когда  в  исходном  состоянии
стек содержит a b с.  Чтобы получить требуемый результат, надо иметь в
стеке c а b.  Но как привести стек к нужному  состоянию?  Загляните  в
табл.  2.  Воспользуемся  командой  SWAP,  которая  меняет местами два
верхних числа,  и получим в стеке а с b. Если теперь применить команду
ROT  (rotate  -  вращать),  в стеке будет с b а.  Повторное применение
команды SWAP даст искомый результат с а b. Таким образом, полный текст
программы будет иметь вид:  SWAP ROT SWAP - *. Последовательность SWAP
SWAP оставляет стек неизменным,  таким же свойством  обладают  команды
DUP DROP, OVER DROP, ROT ROT ROT и некоторые другие. Заметим, что один
и тот же результат  можно  получить  различными  способами.  Например,
указанную  выше  задачу  можно  решить  с  помощью  ROT ROT - *,  что,
конечно,  лучше,  или >R - R> *,  но примененные в последнем  варианте
операторы будут описаны

                          ╔═══════╗
                          ║ R O T ║
                          ╚═══════╝

                            ┌───┐
                         -> │ 3 │->
                            └───┘
     ┌───┬───┬───┐        ┌───┬───┐         ┌───┬───┬───┐
     │ 3 │ 2 │ 1 │        │ 2 │ 1 │         │ 2 │ 1 │ 3 │
     └───┴───┴───┘        └───┴───┘         └───┴───┴───┘


Таблица 2. Операции над кодами в стеке параметров
----------------------------------------------------------------------
Имя        Состояние стека          Версия     Функция
----------------------------------------------------------------------
SWAP       n1 n2 --> n2 n1          9, 3, F    Меняет местами два
                                               верхних элемента стека

DUP        n --> n n                9, 3, F    Дублирует верхний
                                               элемент стека

OVER       n1 n2 --> n1 n2 n1       9, 3, F    Копирует 2-й элемент
                                               стека и заносит его
                                               наверх

ROT        n1 n2 --> n1 n2 n1       9, 3, F    Переносит 3-й элемент
                                               стека наверх

DROP       n --> -                  9, 3, F    Удаляет верхний элемент
                                               стека

SP!        - --> -                  F          Устанавливает указатель
                                               стека в исходное
                                               состояние

SP@        - --> SP                 9, 3, F, М Записывает в стек
                                               значение указателя,
                                               которое он имел до
                                               исполнения команды SP@

2DROP      d --> -                  9, 3       Удаляет из стека число
                                               двойной длины

2OVER      d1 d2 --> d1 d2 d1       9, 3       Копирует 2-ю пару
                                               чисел в стеке и
                                               заносит ее наверх

2SWAP      d1 d2 --> d2 d1          9, 3       Меняет местами верхние
                                               две пары чисел в стеке

2DUP       d -> dd                  9, 3       Дублирует верхнюю пару
                                               чисел в стеке

DEPTH      - --> n                  9, 3       Выдает в стек число
                                               кодов одиночной длины,
                                               которые хранились в
                                               стеке до исполнения
                                               команды DEPTH

PICK       n1 --> n2                9, 3       Копирует элемент стека
                                               с номером n1 и
                                               записывает его на верх
                                               стека. Отсчет
                                               начинается сверху,
                                               верхний элемент имеет
                                               номер 1

ROLL       n1 --> -                 9, 3       Удаляет элемент n1 из
					       стека (n1 не считается)
					       и записывает его на
					       верх стека. 2 ROLL
					       эквивалентно SWAP

-ROT      abc --> cab               M          Операция эквивалентна
					       ROT ROT

Примечание. См. примечание к табл.1; М- MMSFORTH.
----------------------------------------------------------------------


позже (см.  табл. 12). Многовариантность открывает широкие возможности
для оптимизации.

   Выше промелькнуло загадочное слово DUP.  Для прояснения его функции
рассмотрим пример:

      : КУБ DUP DUP * *;

   При обращении 4 КУБ .  <ВК> получим 64 ОК.  В исходном состоянии  в
стеке 4.  DUP дублирует верхнюю ячейку стека.  И мы сначала получаем в
стеке 4 4,  а затем,  после повторного использования DUP,   4 4 4.  Не
будет лишним напомнить об ограничениях применения слова КУБ. Куб числа
64 уже не будет вычислен правильно, так как произойдет переполнение.

   Процедура DROP удаляет из  стека  одно  (верхнее)  число  одинарной
длины.  Например, в стеке 5 2 5. Нужно вычислить произведение 5x5, а 2
вообще не нужна  для  дальнейших  вычислений.  Задача  решается  путем
выполнения последовательности команд

      SWAP DROP*. <ВК> 25 OK

   Примером использования   DROP   и   SWAP   могут  служить  описания
арифметических операторов / и MOD:

      : //MOD SWAP DROP;
      : MOD /MOD DROP;

		       ┌───┐    ╔══════╗     ┌───┐
		     ->│ 1 │->  ║ DROP ║     │ 2 │
		       ├───┤    ╚══════╝     ├───┤
		       │ 2 │                 │ 3 │
		       ├───┤                 ├───┤
		       │ 3 │                 │ 4 │
		       ├───┤                 ├───┤
		       │ 4 │                 │ 5 │
		       ├───┤                 └───┘
		       │ 5 │
		       └───┘

   OVER преобразует  стек  следующим  образом:   a b с --> a b с b.  В
некоторых версиях Форта имеются операторы PICK и  ROLL.  Обращение:  N
PICK и N ROLL.  По команде PICK количество чисел в стеке увеличивается
на 1. При исполнении ROLL число элементов в стеке не изменяется.

   Например, в стеке 3 4 5 6,  по команде 3 PICK стек преобразуется  к
виду 3 4 5 6 4.  Если повторить команду, в стеке окажется 3 4 5 6 4 5.
По команде 3 ROLL при том же начальном  состоянии  стека  (3  4  5  6)
получим  3  5  6  4.  Нетрудно  заметить,  что команды 1 PICK и 2 PICK
эквивалентны  DUP   и   OVER   соответственно   (последние,   конечно,
выполняются заметно быстрее). Команды же 2 ROLL и 3 ROLL функционально
тождественны SWAP и РОТ соответственно.  По  команде  1  ROLL  никакой
работы  не  производится.  Команда  ROLL  из  числа самых "тихоходных"
(перемещается   много   данных)   и   поэтому    должна    применяться
осмотрительно.  Вообще  искусство  работы  со стеком в Форте - одни из
главных критериев, характеризующих программиста.

			       ┌───┐
			       │ 1 │
                               ├───┤
                               │ 2 │    ╔════════╗
                               ├───┤    ║   PICK ║
                             ->│ 3 │->  ║ 3  &   ║
                               ├───┤ │  ║   ROLL ║
                               │ 4 │ │  ╚════════╝
                               ├───┤ │
                               │ 5 │ │
                               └───┘ │
                                   <─┘

   Вы уже  знакомы с оператором DUP,  создающим копию верхнего числа в
стеке (DUP а --> а а).  Существует также его двойник -DUP (в некоторых
версиях ?DUP),  который обычно работает так же,  как и DUP, и только в
случае а = 0 содержимое стека не изменяется.  Например,  опишем слово,
которое  делает  пропуск  в  N  строк  при  выводе данных на экран или
печать, присвоим ему имя CR#:

      : CR# -DUP IF 0 DO CR LOOP THEN ;

   Оставим без комментариев не описанные пока слова-процедуры, заметим
лишь, что то же слово с использованием оператора DUP имело бы вид

      : CR# DUP IF 0 DO CR LOOP ELSE DROP THEN ;

   Ведь слово CR# не должно изменять состояния стека.

   Не требует  какого-либо  глубокого  проникновения  в  тайны Форта и
понимание операторов,  работающих  с  числами  двойной  длины:  2SWAP,
2OVER,  2DROP  и 2DUP.  Их функции идентичны SWAP,  OVER,  DROP и DUP,
только   они   оперируют   парами    чисел    в    стеке.    Например,
последовательность  чисел  1  2  3  4  в  стеке  (верх  стека  справа)
преобразуется по командам следующим образом:

      2SWAP   3 4 1 2
      2OVER   1 2 3 4 1 2
      2DROP   1 2
      2DUP    1 2 3 4 3 4

   Принцип работы  других  команд  из табл.2 легко понять по состоянию
стека.  Для начинающих работать с Фортом полезно следить за состоянием
стека.  Для  этого  можно  воспользоваться  оператором  "." (вывести).
Существуют  и  другие  более  эффективные   операторы,   но   с   ними
познакомимся позднее.

   В случае  необходимости  вернуть  стек  в  исходное  состояние (это
делается  путем  присвоения  указателю  стека   начального   значения)
достаточно выполнить команду SP!  (записать значение указателя стека).
Эта же команда используется и для инициализации  словаря  и  некоторых
других процедур. Другой командой, имеющей отношение к указателю стека,
является SP@ (загрузить в стек указатель стека).  По  этой  команде  в
стек  записывается  значение  указателя,  которое  было  до выполнения
данной команды. Команда применяется также для контроля состояния стека
в  ходе  выполнения  трансляции  и  при  некоторых  других процедурах.
Пожалуй,  самым простым способом  восстановления  исходного  состояния
стека  при  работе  с  клавиатурой  является  выдача не существующей в
словаре команды,  например WWWW. ЭВМ удивится и откликнется WWWW? MSG#
0  ОК,  попутно  очистит стек.  Этот прием годится только при работе в
пультовом режиме.  В результате  данной  операции  стек  преобразуется
следующим образом:

      777 <- SP (указатель стека)                777
        1                                          1
       12                                         12
      128                                        128
      ---"дно стека"                             --- <- SP

   Дальнейшее освоение  Форта  полезнее  вести за терминалом ЭВМ.  Для
этого на одном из дисков должны быть записаны файлы FORTH.  SAV(RT-11)
или FORTH.EXE (для персональной ЭВМ IBM PC), а кроме того, потребуется
файл FORTH.DAT или какой-то другой с  системной  библиотекой,  где  вы
будете   хранить  свои  программы.  Этот  диск  должен  быть  объявлен
устройством по умолчанию (DK: для RT-11).

   Для загрузки Форта напечатайте команду RU FORTH  (или  RUN  FORTH),
если вы работаете с операционной системой RT-11,  или просто FORTH для
MS-DOS,  если же вы владеете автономной версией,  Форт будет  загружен
при  включении  ЭВМ.  На экране появится FORTH IS HERE или FORTH-PC IS
HERE или нечто иное в этом же духе.  Теперь вы хозяин (хозяйка) машины
и можете приступать к работе.

   Описание любого  слова содержит список имен других слов.  Это могут
быть слова базового словаря,  или загруженные ранее из библиотеки, или
процедуры, описанные самим программистом. Например, описания

      : EMPTY ; ( пустое описание)
      : A 65 EMIT ;
      : В 66 EMIT ;
      : NUMBERS 10 0 DO '60 I+ EMIT SPACE LOOP ;

включают только слова базового словаря Форта  (апостроф  перед  числом
указывает,  что  число  представлено в восьмеричной системе счисления,
что впрочем, справедливо лишь для FIG-FORTH). Описание

      : COMPARE DUP 65 = IF A THEN 66 = IF В THEN ;

печатает на экране букву A, если в стеке число 65, букву В, если 66, и
ничего  во  всех  остальных  случаях.  Важно  то,  что  слово  COMPARE
использует слова A и B, которых нет в базовом словаре, но которые были
описаны   и   загружены   ранее.   Если   это  правило  не  выполнено,
интерпретация слова COMPARE  будет  прервана.  Некоторые  относят  это
свойство  Форта  к  его  недостаткам  [32],  на  мой взгляд,  этот тип
регламетации лишь дисциплинирует программиста и упрощает поиск  ошибок
в  тексте.  Более  сложный  случай представляет собой пример косвенной
рекурсии:

      : AA ВВ 2+;
      : ВВ AA 4+;

   Здесь как  ни  меняй местами слова,  сообщение об ошибке неизбежно.
(Желающих найти выход из этого тупика отсылаю к  4.4, где рассмотрены
рекурсивные  процедуры.  На практике такие ситуации встречаются крайне
редко.)


                     1.3. РЕЖИМЫ РАБОТЫ ФОРТ


   Как и многие интерпретаторы.  Форт может имитировать в той или иной
мере работу на ручном калькуляторе:

      6 6 * .<ВК> 36 ОК
                  -- --
   Если читатель  располагает  ЭВМ,  он  без  труда  сможет  проверить
оставшуюся  часть  таблицы умножения самостоятельно.  Возможны и более
сложные операции:

      1 2 + 3 + 4 * . <ВК> 24 OK
                           -- --
   Нужно только  помнить,  что  базовый  словарь Форта содержит только
целочисленные операции. Не удивляйтесь, если в результате операции 3 5
/  10  *.  <ВК>  вы  получите 0 ОК.  Правильный ответ получится,  если
операцию переписать иначе:  3 10 *5 /.  <ВК>  6  ОК.  Разные  варианты
решения  в некоторых случаях дадут различные ответы (для целочисленных
операций умножение  и  деление  некоммутативны).  При  этом  не  нужно
забывать и об ограничениях, связанных с разрядностью чисел.

   Следующий уровень   Форта   предполагает  описание  процедур  и  их
исполнение.  Допустим,  вы хотите объективно оценить достоинства  двух
ораторов и оперативно подсчитать, сколько раз за время выступления они
скажут "так сказать" или какое-либо другое слово или выражение.  Тогда
напишите программу

      0 VARIABLE AA
      0 VARIABLE ВВ
      : A 1 AA +! ;
      : В 1 ВВ +! ;
      : ITOG AA @ ." A=" . ВВ @ ." B=". ;

   Теперь всякий  раз,  когда ораторы A и В произносят выбранное слово
или выражение,  вы даете команду A <ВК>  или  В  <ВК>.  По  завершении
соревнования   напечатайте   команду  ITOG  <ВК>  и  ЭВМ  откликнется,
например,  A = 135 В = 144, если результат оратора A равен 135 и 144 у
оратора В. Эта программа несовершенна: требуется нажатие клавиши <ВК>,
что снижает быстродействие и может привести к  просчетам.  Но  главная
цель  программы  -  показать  возможности  Форта  в  пультовом режиме.
Основная особенность программ,  написанных в этом режиме,  то, что они
будут  безвозвратно  утрачены  при выключении ЭВМ (ведь они хранятся в
оперативной памяти).

   Чтобы запечатлеть свое имя в веках,  следует  хранить  программы  в
более надежном месте,  например на магнитном диске или ленте. Для этой
цели можно использовать программу-редактор.  Так,  с помощью редактора
запишем на экране 70 описание оператора FF (см. гл.3):

      : FF  ." FFFFF  OOO  RRR  TTTTT H   Н"
        CR  ." F     О   O R  R   T   Н   Н"
        CR  ." FFF   О   О RRR    T   HH  Н"
        CR  ." F     О   O R R    T   Н   Н"
        CR  ." F      OOO  R  R   T   Н   Н" ; ( см. гл.3)

   Чтобы им  воспользоваться,  нужно  загрузить  этот  экран с помощью
команды 70 LOAD,  которая обеспечит интерпретацию и загрузку в словарь
этого описания.  Теперь выдайте команду FF <ВК>,  и на экране большими
немного неуклюжими буквами будет написано слово FORTH.

   Упражнение 1.
   Сдвинуть код, лежащий в стеке на 9 разрядов влево.

   Решения.  а) 2* 2* 2* 2* 2* 2* 2* 2* 2*
             б) 512*
             в) '177 AND SWAB 2* (если описана операция смены  местами
                байтов числа в стеке SWAB)

   Самое быстродействующее решение в).

   Упражнение 2.
   В стеке  числа 6 7 8 9 1 0.  Что будет выдано на экран в результате
выполнения команды 3 PICK..... <ВК>?

   Ответ. 8 10 9 8 7 ОК

   То же, но при команде 3 ROLL..... <ВК>

   Ответ. 8 10 9 7 6  ОК

   Упражнение 3.
   Пусть в стеке коды A B C D E F.  Вычислить выражение {(F - A)C/(В -
D)} + E.

   Решения, a) SWAP >R >R ROT SWAP - R> SWAP >R ROT -* R>/R>+
            б) 6 ROLL - 4 ROLL * 4 ROLL 4 ROLL - / +
            в) SWAP >R >R ROT SWAP - / R> ROT -* R>+

   Самое медленное решение б) (много команд ROLL).

   Упражнение 4.
   В стеке коды A B C D. Вычислить (В + D)C + В + A.

   Решение. 3 PICK + * + +

   Упражнение 5.
   Исходные данные те же,  что и в упражнении 3, но вычислить (A + В)C
- D + C.

   Решения, a) MINUS OVER + SWAP ROT 4 ROLL + * +
            б) OVER - SWAP ROT 4 ROLL + * SWAP -

   Возможны и другие варианты решения.
