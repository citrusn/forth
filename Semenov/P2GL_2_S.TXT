              Глава 2. КОНСТРУКЦИЯ  <BUILDS...DOES>


   Одной из важнейших особенностей Форта является возможность создания
новых слов-описателей.  Главным отличием  этих  слов  от  традиционных
является   способ   использования   кодов  поля  параметров  (PFA).  С
некоторыми  словами-описателями  вы  уже  знакомы  -   это   операторы
VARIABLE,  CONSTANT,  с  определенными  оговорками  CREATE (создать) и
безусловно : NNN XXX ;.  Но создание новых слов - описателей с помощью
структуры  <BUILDS...DOES>,  (в Форт-83 CREATE...DOES>) присуще только
Форту (табл.17).

Таблица 17. Управляющие операторы

----------------------------------------------------------------------
Имя                 Состояние   Версия          Функция
                      стека
----------------------------------------------------------------------
<BUILDS XXX DOES>  Исполнение:  F       Формирование новых слов -
(CREATE XXX         - --> адр           описателей. XXX исполняется на
DOES>)               (I, C)             этапе компиляции, текст
				        программы, следующий за DOES>,
				        - на этапе исполнения. При
				        исполнении DOES> выдает в стек
				        PFA вновь определенного слова

LITERAL            Компиляция:  9, 3, F Используется только в
                     n --> -            конструкциях : NNN XXX ; При
                   Исполнение:          компиляции переносит код n из
                     - --> n            стека в описание нового слова,
                    (I, C)              а при исполнении описанного
                                        слова записывает в стек
                                        указанное число n

DLITERAL           Компиляция:  F       То же что и LITERAL, но для
(I, C)               n -- > -           чисел двойной длины
	           Исполнение:
                     - --> n

FIND            адр1 --> адр2 n  9, 3   адр1 - адрес начала счетной
-FIND                           F       строки, содержащей имя слова,
				        которое нужно найти в словаре

Примечание. I - слово немедленного исполнения,
            C - используется при компиляции;
            F - FIG-FORTH, 9 и 3 - стандарты Форт-79 и Форт-83.
----------------------------------------------------------------------

   Классическим примером  использования   такой   структуры   является
формирование новых констант с помощью оператора NEW CONSTANT:

      : NEWCONSTANT <BUILDS, DOES> @ ;

который по  своим  возможностям  тождествен  оператору  CONSTANT.  При
обращении 1990 NEWCONSTANT YEAR слово <BUILDS сформирует  константу  с
именем  YEAR.  В поле PFA будет 0.  Оператор "," запишет число 1990 по
адресу PFA+2.  DOES> (выполнить) заменяет 0 в PFA на адрес  оператора,
следующего  за  DOES>  в  описании  NEWCONSTANT,  а  в  CFA YEAR будет
записана ссылка на программу $DOE.  Последняя при  исполнении  запишет
YEAR в стек PFA+2 и передаст управление программе,  которая следует за
DOES>. <BUILDS имеет весьма простую структуру:

      : <BUILDS 0 CONSTANT ;

т.е. это слово при обращении <BUILDS XXX, формирует в словаре описание
константы равной 0 с именем XXX.

   Другим примером  использования  <BUILDS...DOES>  является  описание
констант с плавающей точкой:

      : FCON <BUILDS , , DOES> DUP 2+ @ SWAP @ ;

   Это слово пригодно и для  формирования  описаний  обычных  констант
двойной  длины.  Отличие  здесь  заключается  не  в  работе FCON,  а в
содержимом стека при обращении к нему.  Обращение в случае константы с
плавающей   точкой:   +XXXXX.XXXXXE+-XXXXX.XXXXXE+-YY,   а   в  случае
целочисленной константы двойной длины: u1 u2 FCON <NAME>, где <NAME> -
имя  константы,  u1  и  u2  -  любые  целые константы одинарной длины,
образующие число двойной длины  со  знаком.  При  обращении  ко  вновь
описанному слову <NAME> в стек будет записано два кода u1 и u2.

       3.1415926 FL CON PI

         NFA   LFA   CFA |     |<-3.1415926->|
       ┌─────┬─────┬─────┬─────┬──────┬──────┐
       │  PI │     │     │     │  A   │      │ Слово PI
       └─────┴─────┴─────┴──┬──┴──────┴──────┘
                            V
                      ┌─────┴─────┐
                      │ ADR    A  │
                      │  в стек   │
                      └─────┬─────┘
                            └──>──┐         Слово FCON
 ┌────┬───┬───┬────────┬─┬─┬─────┬┴─┬───┬───┬───┬───┬───┐
 │FCON│LFA│CFA│<BUILDS>│,│,│DOES>│  │   │   │   │   │   │
 └────┴───┴───┼────────┴─┴─┴─────┴─┬┴┬─┬┴─┬┬┴┬─┬┴┬─┬┴┬─┬┘
              │                    │ │ │  ││ │ │ │ │ │ │
              │<──── PFA(FCON)     │ │ └┐ │└┐│ │ │ └┐│ │
                                   V ^  V ^ V^ V ^  V^ V
                                   │ │  │ │ ││ │ │  ││ │
                                 ┌─┴─┴─┬┴─┴┬┴┴┬┴─┴─┬┴┴┬┴─┐
                                 │ DUP │ 2+│ @│SWAP│ @│;S│
                                 └─────┴───┴──┴────┴──┴┬─┘
                                                       V
                                                       │
						      NEXT
                  Рис. 7. Структура слова PI

   Как работает эта конструкция? Часть программы между <BUILDS и DOES>
выполняется  только  при компиляции,  текст после DOES> при выполнении
вновь описанного слова (рис.7).  В случае констант с плавающей  точкой
при  обращении,  например,  к  константе P1 в две верхние ячейки стека
будет записано значение  n.  В  библиотеке  для  работы  с  числами  с
плавающей  точкой (табл.18) приведено несколько иное описание констант
с плавающей точкой:

              : 2@ DUP 2+ @ SWAP @ ;
              : FC FL <BUILDS , ,  DOES> 2@ ;

   Обратите внимание  на  слово  FL.  Оно  выполняется  так же,  как и
<BUILDS, но только при обращении к FC. В первой ячейке поля параметров
PI  указан  адрес  ячейки поля параметров слова FCON,  где лежит адрес
перехода   в   DUP.   Такая   последовательность   переходов    начнет
осуществляться  после  того,  как  в стек будет записан адрес ячейки A
поля  параметров  PI.  Все  константы   с   плавающей   точкой   будут
использовать   программу,   лежащую   в   FC  после  слова  DOES,  что
обеспечивает компактность программы.

Таблица 18. Операции над числами с плавающей точкой
----------------------------------------------------------------------
Имя     Состояние          Функция
          стека
----------------------------------------------------------------------
FCON     D -->-        Обращение: D FCON <NAME>. Формируя в словаре
                       константу значением D с именем <NAME>

FVAR     D -->-        Обращение: D FVAR <NAME>. То же, но для
                       переменной. Для получения значения переменной
                       в стеке надо написать <NAME> 2 @

F0=      D --> f       Аналог 0= (для чисел с плавающей точкой).
                       Выдает в стек флаг f=TRUE, если D=0

F0>      D --> f       Аналог 0>

F0<      D --> f       Аналог 0<

F>       D --> f       Аналог >

F<       D --< f       Аналог <

FTY      D --> -       Выдает на терминал в E-формате значение числа
                       с плавающей точкой

F-       D1 D2 --> D3  Вычитание чисел D3 = D1 - D2

F+       D1 D2 --> D3  Сложение чисел D3 = D1 + D2

F*       D1 D2 --> D3  Умножение чисел D3 = D1 * D2

F/       D1 D2 --> D3  Деление чисел D3 = D1 / D2

SIN      D1 --> D2     D2 = Sin(D1), D1 в радианах

TAN      D1 --> D2     D2 = tg(D1), D1 в радианах

LN       D1 --> n2     D2 = ln(D1)

F**      D1N --> D2    D2 = D1^N, где N - целое число со знаком;
                       обращение: D1 N F**

EXP      D1 --> D2     D2 = e^D1, где e=2,718281828; обращение D1 EXP

INT      D1 --> N      Выделяет целую часть числа D1 и записывая
                       ее в стек

1/Х      D1 --> D2     D2 = 1/D1, D1 =/= 0

4DUP     D1 --> D1 D1  Аналог 2DUP 2DUP

4DRO     D1 D2 --> -   Аналог 2DROP 2DROP

SQRT     D1 --> D2     D2 = + √ |D1|; обращение: D1 SQRT

FCHS     D1 --> D2     Изменяет знак числа с плавающей точкой:
                       D2 =- D1

FABS     D1 --> D2     Заменяет число с плавающей точкой в стеке
                       его модулем

F+!      D адр --> -   Аналог +! (для чисел с плавающей точкой)

F-!      D адр --> -   Аналог SWAP MINUS SWAP +!

F.       D --> D       Аналог 2DUP FTY. Пропечатывает число из стека,
		       не меняя его указателя
----------------------------------------------------------------------

   Фактически текст после DOES> - это программа,  которая обрабатывает
заданным образом содержимое ячейки (или ячеек), начиная с адреса PFA+2
вновь описанного слова. С этой точки зрения она аналогична программам,
к  которым  происходит  обращение  через  CFA  в  случае :  NNN XXX ;,
CONSTANT или VARIABLE. По своим возможностям структура <BUILDS...DOES>
практически  не  уступает  перечисленным выше операторам.  Всякий раз,
когда вы столкнетесь с необходимостью ввести новый вид данных  (особые
массивы,  комплексные  числа,  виртуальные  структуры  данных и т.д.),
вспомните о <BUILDS...DOES> и ваша проблема будет решена.

   Интересный пример    использования    структуры     <BUILDS...DOES>
представляют   операторы  DOER  и  MAKE,  предложенные  Л.Броуди  [1].
Оператор DOER XXX вводит в словарь новое  слово  с  именем  XXX.  Если
затем  написать MAKE XXX " Что изволите?" ;  и обратиться к слову XXX,
то ЭВМ выдаст:

      Что изволите? OK
      --- --------- --
а затем

      MAKE XXX . "А кто вас звал? OK."
                  - --- --- ----- --

   Откликом на XXX будет "А кто вас звал? ОК. Вместо оператора ." TTT"
может  быть  записана  любая  последовательность  операторов  словаря.
Обратите  внимание на ";" в конце обращения.  Это обязательный атрибут
программы.  Рассмотренный  прием  позволяет  не   только   реализовать
нехитрый диалог, приведенный выше.

   Представьте себе   программу   со  сложным  логическим  деревом.  В
некоторую точку при  исполнении  программы  можно  попасть  различными
путями  и  в  зависимости  от  пути  исполнить  в этой точке различную
работу.   Традиционный   способ    решения    предполагает    введение
переменной-флага, которая формируется в процессе исполнения и в нужном
месте анализируется. Более наглядное решение предлагает DOER..MAKE - в
XXX  каждой из ветвей засылается соответствующая программа,  которая и
исполняется в оговоренной точке.

   Теперь о структуре DOER и MAKE. Ниже приведены схемы их реализации.

   : RRR                                       ("пустое" описание)
   : DOER <BUILDS      ( введение в словарь нового слова с именем
                         из входного потока)
          ' RRR ,   ( определение PFA слова RRR и занесение его в
                      описание нового слова)
          DOES>              ( запись в стек PFA+2 при исполнении
                               нового слова)
          @ >R ;          ( извлечение содержимого этого адреса и
                            запись его в стек возвратов)

   : (MAKE) R> DUP @ 4 + SWAP 2 + SWAP ! ;
   : MAKE STATE @                                 ( компиляция ? )
           IF COMPILE (MAKE)   ( компиляция ссылки (CFA) на слово
                                 (MAKE) в новое описание )
           ELSE SP@ CSP !            ( сохранение указателя стека)
                HERE              ( запись в стек HERE, где лежит
                                   текст программы-подмены)
                [COMPILE] ' ( запись в стек PFA слова из входного
                              потока [ XXX - как мы его
                              назвали выше])
                2+ !     ( запись в поле параметров значения HERE)
                SMUG       ( коррекция флага в имени нового слова)
                [COMPILE] ]        ( компиляция команды переход в
                                     режим компиляции)
           THEN ; IMMEDIATE        ( установка Флага немедленного
				   исполнения )
   : UNDO ' RRR [COMPILE] ' 2+ ! ;


   Опишем слово DRUCK:


      : DRUCK MAKE XXX ." Кто там ?" MAKE XXX ." Это вы ?"

              MAKE XXX ." Да, это я" ;

дадим команду DRUCK <ВК>, а затем исполним XXX несколько раз:

                   XXX <ВК> Кто там ? OK               (*)
			    --- ---
                   XXX <ВК> Это вы ? OK
			    --- ---
                   XXX <ВК> Да это я. OK
			    -- --- --
                   XXX <BK> Да это я. OK
                            -- --- --

   При последующих   исполнениях   XXX   будет   выполняться  задание,
описанное последним.  Если исполнить DRUCK еще раз, последовательность
(*)  может  быть  повторена.  Не  правда  ли,  забавный результат?  Но
операторы DOER и MAKE способны и на серьезную  работу  по  вариации  и
реконфигурации  уже  имеющихся программ.  Оператор UNDO (отменить) при
обращении UNDO XXX возвращает XXX в  то  состояние,  которое  он  имел
после выполнения команды DOER XXX.

   Структура DOER...MAKE  -  прекрасный  пример возможностей,  которые
скрывает  в  себе  Форт.  Как  же  работает  оператор   DRUCK?   После
интерпретации  на  месте  MAKE  оказывается  ссылка на (MAKE).  (MAKE)
засылает в PFA+2 слова XXX адрес оператора .",  стоящего в DRUCK перед
"Кто  там?".  По  завершении  работы  (MAKE)  управление  передается в
систему Форт,  так как оператор R> в (MAKE)  убрал  из  стека  команду
возврата в DRUCK. При выполнении XXX управление передается программе "
Кто там ?" в XXX,  а после ее  завершения  выполняется  очередной  раз
(MAKE)  и  ссылка в XXX на " Кто там ?" будет заменена ссылкой на "Кто
вы?" и т.д.

   Если описать два слова с именами T и В, а также слово XX:

         : T MAKE XXX " TTT" ; : В MAKE XXX " BBB"
         : XX IF T ELSE В THEN XXX ;

то при  0 XX будет печататься BBS,  а при 1 XX будет TTT.  Так можно в
широких пределах варьировать работу,  которую выполняет одна и  та  же
программа.  На  первый взгляд,  аналогичного результата можно достичь,
используя условные операторы IF...THEN. Приведенный пример реализуется
таким   путем  довольно  легко,  но  DOER-MAKE  позволяет  произвольно
заменять функцию после того,  как оператор уже описан,  а IF...THEN на
все случаи жизни не запастись.

   При вводе  текста  с  клавиатуры  неизбежны  ошибки  (человек  - не
машина).  В режиме редактирования  ошибки  легко  устранить,  да  и  в
процессе  отладки программы они больших проблем не создают.  Но,  если
диалог встроен в сложную программу управления,  где  повторный  запуск
программы ведет к большим потерям,  уход в систему Форт через оператор
ERROR (ошибка)  становится  непозволительной  роскошью.  (В  FIG-FORTH
ERROR используется в операторах ?ERROR,  ?COMP,  ?EXEC,  ?PAIR, ?LOAD,
?CSP,  ?STACK и некоторых других.) Чтобы преодолеть  эту  трудность  в
интерпретатор Форта введена системная переменная ERB, значение которой
контролируется оператором ERROR и в норме равно 0.

   Если ERB=0,  ERROR  работает  обычным  образом,  в противном случае
переменная ERB обнуляется,  а уход из  программы  в  Форт  через  QUIT
блокируется. Блокировка осуществляется как при "неузнанном" имени, так
и  при  неправильном  вводе  чисел,  включая   ошибки,   связанные   с
конфликтами  по  системе  счисления.  Ниже  описан  алгоритм оператора
ERROR:

   : ERROR HERE COUNT TYPE ." ? "  ( распечатка содержимого
				     буфера слов)
           ERB @      ( проверка состояния флага блокировки)
           IF 0 ERB ! DROP  ( обнуление ERB и удаление кода
                              ошибки из стека)
           ELSE MESSAGE               ( сообщение об ошибке)
           SP! QUIT THEN ; ( восстановление указателя стека)

   Рассмотрим пример,  как можно воспользоваться ERB в программе ввода
чисел.  С целью блокировки ухода в QUIT при  ошибке  перед  оператором
INTERPRET (или NUMBER) надо записать команду 1 ERB !.

   Сразу вслед    за   оператором-преобразователем   вводим   контроль
равенства ERB нулю, например:

   : TTT BEGIN ." ENTER>" QUERY BL WORD HERE 1 ERB ! NUMBER
	       ERB @ DUP 0=
	       IF 1 ERB !          ( Установка флага блокировки)
               THEN
	 UNTIL ;            ( если после NUMBER ERB @ = 0, ввод
			      повторяется )

   Возможны и другие варианты.
