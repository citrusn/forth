      Глава 5. ЛОГИЧЕСКИЕ ОПЕРАЦИИ, ЦИКЛЫ И РАБОТА СО СТЕКОМ
                             ВОЗВРАТОВ


	            5.1. ЛОГИЧЕСКИЕ ОПЕРАЦИИ



   Форт предлагает программисту обширный список логических  операторов
(табл. 10). Основная логическая структура Форта

      IF A ELSE В THEN C

где A,  В  и  C - некоторые процедуры.  Предполагается,  что к моменту
исполнения оператора IF (если) в стеке флаг f (FALSE/TRUE) :  f  =0  -
FALSE  (ложно),  f  =/= 0 - TRUE (истинно),  в некоторых версиях Форта
TRUE=-1 [19]. Если f=TRUE, выполняется процедура A, в противном случае
- В.  Процедура C выполняется при любом f.  Оператор ELSE (в противном
случае)  может  отсутствовать,  тогда  f  определяет,  будет  или  нет
исполняться   программа   между   IF   и  THEN.  Оператор  IF  требует
обязательного наличия слова THEN после него,  вместо THEN в  некоторых
версиях используется оператор ENDIF, который тождествен THEN.


Таблица 10. Условные операторы
----------------------------------------------------------------------
Имя           Состояние стека   Версия            Функция
----------------------------------------------------------------------
IF XXX ELSE   f --> -           9, 3, F   Если f = TRUE (=\=О),
YYY THEN ZZZ                              исполняется XXX, в противном
					  случае YYY, ZZZ в любом
					  случае

=             n1 n2 --> f       9, 3, F   f = TRUE, если n1=n2

-             n1 n2 --> n1-n2   9, 3, F   f = TRUE, если n1 - n2 =/= 0

<             n1 n2 --> f       9, 3, F   f = TRUE, если n1 > n2

<             n1 n2 --> f       9, 3, F   f = TRUE, если n1 < n2

0=            n --> f           9, 3, F   f = TRUE, если n = 0

0<            n --> f           9, 3, F   f = TRUE, если n < 0

0>            n --> f           9, 3,     f = TRUE, если n > 0

NOT           f --> f           9, 3,     Результат предшествующего
                                          текста меняется на
                                          противоположный.
					  Эквивалентно 0=

AND           n1 n2 --> n1&n2   9,3,F,G   Выполняется логическое И

OR            n1 n2 --> OR      9,3,F,G   Выполняется логическое ИЛИ

XOR           n1 n2 --> n3                Выполняется Исключающее ИЛИ

-DUP          n --> n n F                 Осуществляя операцию DUP,
?DUP          или 0 --> 0       9,3       если n =/= 0

?STACK        - --> f           F         f=TRUE, если значение
                                          указателя стека в пределах
                                          допусков

U<            u1 u2 --> f       9, 3, F   f=TRUE, если u1 < u2, оба
					  числа не имеют знака

П р и м е ч а н и е. 9 - стандарт Форт-79; 3 - стандарт Форт-8З,
F-FIG-FORTH, G-GraFORTH.
----------------------------------------------------------------------

                            ┌──────┐
                            │ THEN │
                            └──────┘
                              /││\
                               ││
                    ┌──────────┘└──────────┐
                    │                      │
                    │                      │
                    │   ┌──────────────┐   │
                    │   │IF        ELSE│   │
                    └───│<════    ════>│───┘
                        └──────────────┘
                              /││\
                               ││
                               ││


   Флаг f  может  формироваться  в  стеке с помощью арифметических или
логических (булевых) операций.  К числу логических операций  относятся
"<",  ">" и "=". Эти операции производятся над числами в стеке. Так, в
результате операции 10 7 < или 10 7 = в стек будет записано  число  0,
что означает f=FALSE, а в результате операции 10 7 > число 1 (f=TRUE).
Исходные числа из стека удаляются.

   Операции 0=,  0> и 0< выполняются над одиночными числами  в  стеке.
Если  это  число  равно  0,  больше  или  меньше нуля,  то вместо него
записывается  флаг  истинности  (TRUE).  Оператор  0=,   тождественный
оператору NOT,  присутствующему в некоторых версиях Форта, преобразует
флаг FALSE в TRUE, а TRUE в FALSE. Рассмотрим пример:

         : SORT DUP 0> IF " POSITIVE" DROP
		       ELSE 0=
			    IF " ZERO"
                            ELSE " NEGATIVE"
                            THEN
                       THEN ;

   Если число  в  стеке  равно  0,  при  обращении к SORT будет выдано
сообщение ZERO, а при положительном или отрицательном числе - POSITIVE
или NEGATIVE соответственно.  Слово SORT при всей непритязательности -
хороший пример вложения операторов IF...ELSE...THEN.  Два THEN в конце
описания - не причуда,  а суровая необходимость. Только при их наличии
интерпретатор  сможет  разобраться,  что  же  вы   от   него   хотите.
Последовательности    типа    IF...IF...ELSE...ELSE...THEN...THEN   не
разрешены,  так как непонятно,  какому IF  какое  ELSE  соответствует.
Ограничений  на число вложений операторов IF...ELSE...THEN практически
не существует,  надо только следить,  чтобы каждому IF  соответствовал
THEN.

   Операторы AND,  OR  и  XOR производят логические операции И,  ИЛИ и
Исключающее ИЛИ над парами кодов в стеке.

   Рассмотрим несколько примеров  использования  логических  операций.
Например  программу  работы  холодильника (данная программа - полезный
пример управления объектом в реальном масштабе времени);

      0 VARIABLE SWITCH        ( переменная,  определяющая  состояние
                                 компрессора. Запись в нее 1 включает
                                 компрессор, 0 - выключает)

      -1 CONSTANT LIMIT ( температура, поддерживаемая в холодильнике )

      ADDRESS CONSTANT TEMPERATURE ( ADDRESS - адрес, при обращении
             к которому, в стек записывается значение температуры в
             холодильнике )

      : ON 1 SWAP I ;  ( включение)

      : OFF 0 SWAP I ; ( выключение)

      : FREEZER BEGIN TEMPERATURE @ LIMIT < IF SWITCH OFF
                                            ELSE SWITCH ON
                                            THEN 0
                UNTIL ;

   Оператор FREEZER  содержит  бесконечный цикл BEGIN...UNTIL,  внутри
которого определяется текущее  значение  температуры  в  холодильнике,
сравнивается  с  эталонным значением (LIMIT) и,  если температура выше
эталонной, включается компрессор, в противном случае он выключается.

   Рассмотрим алгоритм  работы  операторов  IF  и   THEN   (начинающие
программисты эту часть текста могут пропустить).  Описания IF и THEN в
самом интерпретаторе написаны на Форте:

      : IF COMPILE ?BRANCH HERE 0 , 2;IMMEDIATE

   COMPILE (скомпилировать) вводит  в  описание  компилируемого  слова
ссылку на оператор, имя которого следует за ним. В приведенном примере
это ?BRANCH (ветвление?) -  оператор  условного  перехода,  спрятанный
внутри  интерпретатора,  в  обычных  программах  использовать  его  не
рекомендуется. Слово "," вводит в описание интерпретируемого оператора
код, хранящийся в стеке (здесь 0).

      :THEN?COMP 2 ?PAIR HERE OVER -SWAP!;IMMEDIATE

   ?COMP проверяет, не находимся ли мы в пультовом режиме, и, если это
так,  выдает  сообщение   об   ошибке;   ?PAIR   (операторы   парные?)
контролирует  парность  операторов  IF  и  THEN.  Последующая  цепочка
операторов  вычисляет  и  записывает   в   ячейку,   зарезервированную
оператором IF,  адрес ветвления для оператора ?BPANCH. Слово IMMEDIATE
(немедленно) указывает,  что  оператор,  описание  которого  находится
непосредственно  перед  ним,  выполняется только при интерпретации.  В
пультовом режиме слова IF,  ELSE  и  THEN  неприменимы,  так  как  они
являются операторами немедленного исполнения (IMMEDIATE !).

   Пусть требуется   оператор,  который  проверяет  число  в  стеке  и
формирует флаг TRUE,  если оно лежит  в  заданном  интервале  значений
(например, между 7 и 10), и FALSE в противном случае:

       7 CONSTANT L1

      10 CONSTANT L2 (LI и L2 - пределы отбора)

      : SELECT DUP L1 > OVER L2 < AND ;

   При обращении  а  SELECT  число  в  стеке (а) будет заменено флагом
TRUE, если 7<а<10.

   Если записать 35000 10 <,  в стек будет сформирован флаг TRUE,  так
как   35000   будет   воспринято   как   отрицательное   число  (здесь
предполагается десятичная система  счисления).  При  работе  с  кодами
бывает необходимо сравнивать числа, рассматривая бит знака как обычный
двоичный разряд (например,  сравнение 16-разрядных адресов).  Для этой
цели  используется  оператор  U<.  Команда 35000 10 U < сформирует уже
флаг FALSE (см. также описание слова FORGET).

   Кроме названных в некоторых версиях Форта имеются операторы:

                   a b <=    f=TRUE, если а <= b
                   a b <>    f=TRUE, если а =\= b
                   а b >=    f=TRUE, если а => b

   Часто вместо  логических  операторов  используются  арифметические.
Например,  нужно  проверить условие М=/=64 & М>0 (предполагается,  что
оператора <> (не равно) в системе нет). Проверку первого условия можно
организовать  как  64  М  = 0= или 64 М -.  Вторая реализация короче и
быстрее,  но ее применение без  должного  внимания  может  привести  к
досадным ошибкам. Так, если записать указанное выше условие как М 64 -
М 0 > AND,  то ошибка неизбежна.  Пусть 64 М- дает результат  14,  что
эквивалентно  флагу TRUE (ведь 14=/=0).  Что же нам даст оператор AND?
По логике он должен выдать флаг TRUE. Но AND - операция поразрядная, а
мы имеем в стеке 1110 и 1 (двоичное представление) и, естественно, AND
даст 0 (т.е. FALSE). Думаю, именно этим соображением руководствовались
авторы  версии,  где  TRUE=-1  (ведь это дает единицы во всех разрядах
числа).

   Если организовать проверку числа М иначе:  64 М - IF М  0>  ELSE  0
THEN,  ошибки  бы  не произошло,  а оптимальность по памяти и скорости
исполнения  сохранилась.  Безусловную  корректность  в  таких  случаях
гарантирует использование при проверках только логических операторов.

   Рассмотрим еще   один   пример.   Пусть   положение   курсора   при
редактировании лежит в пределах  0  -  1023,  а  число,  задающее  его
координату,  после  очередного приращения записано в стек.  Необходимо
сохранить это число неизменным,  если оно лежит в указанных  пределах,
сделать его равным нулю,  если приращение сделало его отрицательным, и
приравнять 1023,  если координата превысила верхний предел. Опишем для
этого слово LIMI:

        : LIMI DUP 1023 >          ( больше 1023 ? )

               IF ( если да) DROP 1023
               ELSE DUP 0<         ( меньше 0 ? )
                    IF ( если да) DROP 0
                    THEN
               THEN ;

   Но нужно  помнить  и  о  других  путях.  Эту же задачу можно решить
проще:

      : LIMI 1023 MIN 0 MAX ;



                      5.2. ОРГАНИЗАЦИЯ ЦИКЛОВ

    В Форте предусмотрено несколько способов  организации  программных
циклов (табл.11).  Учитывая, что в Форте нет оператора GO TO (оператор
BRANCH не является его аналогом) и, как правило, не применяются метки,
операторы   цикла   наряду   с   условными   операторами   приобретают
основополагающее значение.


Таблица 11. Операторы циклов
----------------------------------------------------------------------
Имя           Состояние стека     Версия          Функция
----------------------------------------------------------------------
DO XXX LOOP     DO:Lim ind -      9, 3, F    Организует конечный
                LOOP: - --> -                цикл, фиксирует индекс
                                             (ind) и предел (lim),
                                             приращение индекса на 1

DO XXX +LOOP    DO: lim ind -     9, 3, F    То же, что и DO...LOOP,
	        +LOOP:n --> -   	     но к индексу добавляется
				 	     n, а не 1

LEAVE            - --> -          9, 3, F    Прерывая цикл по
                                             исполнении очередного
                                             LOOP или +LOOP

BEGIN XXX UNTIL  UNTIL: f --> -   9, 3, F    Организует бесконечный
                                             цикл, который
                                             завершается, если f=TRUE.
                                             Один раз XXX выполняется
                                             при любых условиях

BEGIN XXX        WHILE: f --> -   9, 3, F    Организует бесконечный
WHILE YYY                                    цикл. При этом XXX
REPEAT                                       исполняется всегда, а YYY
                                             только при f=TRUE. Выход
                                             из при цикла f=FALSE

DO XXX/LOOP      DO:u-lim         9, 3, F    То же, что и DO +LOOP,
                 u-ind --> -                 но индекс, предел и
		 /LOOP: u --> -              приращение являются
					     числами без знака

П р и м е ч а н и е . Cм. примечание к табл.10.
----------------------------------------------------------------------

              ┌───────────────<─────────────────┐
              │                                 │
          ╔══════╗                           ╔═════╗
          ║ HOME ║          ЦИКЛЫ            ║ PUB ║
          ╚══════╝                           ╚═════╝
              │                                 │
              └───────────────>─────────────────┘

   При обращении М K DO...LOOP, где М - число, определяющее предельное
значение индекса цикла,  а K - начальное значение индекса цикла, после
каждого цикла индекс получает приращение 1,  процедура между DO и LOOP
исполняется M - K раз.  Опишем,  например, слово ROW, которое печатает
числа натурального ряда от 0 до 9:

      : ROW 10 0 DO 1 . SPACE LOOP;

где слово I выдает в стек параметров текущее значение  индекса  цикла,
не изменяя состояния стека возвратов. Исполнение ROW даст

      0 1 2 3 4 5 6 8 9 OK
      - - - - - - - - - --

   Оператор DO...LOOP использует два верхних числа стека  возвратов  -
стека  для  хранения предельного и текущего значений индекса цикла.  В
вышеприведенном  примере  перед  началом  исполнения  цикла  в   стеке
возвратов 10 и 0 (последнее число на верху стека).

   Предельное и  начальное  значения индекса необязательно должны быть
записаны в стек непосредственно перед оператором DO  (исполнить),  они
могут  быть  определены  в  ходе  предшествующих  вычислений.  Имеется
возможность вложения одного цикла в другой, например

      TAB 10 0 DO 10 0 DO I . LOOP CR LOOP;

при исполнении будет выдано 10 рядов чисел:

	       0 1 2 3 4 5 6 7 8 9
	       - - - - - - - - - -
	       0 1 2 3 4 5 6 7 8 9
	       - - - - - - - - - -
	       ...................
	       0 1 2 3 4 5 6 7 8 9 OK
	       - - - - - - - - - - --

   Оператор цикла М K DO...n +LOOP во многом аналогичен DO...LOOP,  но
приращение  индексу  цикла  (n) задается программой и,  вообще говоря,
может меняться от цикла к циклу.  Например, опишем слово EVEN, которое
пропечатывает первые пять четных чисел:

      : EVEN 10 0 DO I . 2 +LOOP ;

   Откликом на обращение EVEN будет 0 2 4 6 8 ОК. Другой пример:
                                    - - - - - --
      : BACKCOUNT 0 10 DO I . -1 +LOOP ;

   При обращении BACKOUNT <ВК> даст: 10 9 8 7 6 5 4 3 2 1 ОК. Предел и
индекс могут быть и отрицательными.  Процедура между DO и  LOOP  будет
исполнена  по  крайней  мере  один раз.  Если это нежелательно,  можно
записать -DUP IF 0 DO...LOOP THEN и т.д.

   Полезно иметь в виду, что все без исключения операторы циклов могут
использоваться  только  внутри  описаний слов (пультовой режим для них
запрещен).

   Цикл BEGIN XXXX f UNTIL относится к бесконечным.  Это означает, что
при  определенных  условиях  они  могут вызвать бесконечное повторение
процедуры XXXX.  f - число в стеке,  воспринимаемое  оператором  UNTIL
(пока  не)  как  логическая  переменная  TRUE/FALSE.  Цикл  XXXX будет
повторяться  до  тех  пор,  пока  f  =0  (FALSE).  Отсюда  видно,  что
последовательность   XXXX   будет   исполнена   один   раз  при  любых
обстоятельствах. Если оператор описать так:

      : BBB BEGIN XXX 0 UNTIL; ,

он будет "циклить" бесконечно.  На первый взгляд,  истинно бесконечный
цикл   малопривлекателен.  На  самом  деле  это  полезно  при  отладке
аппаратуры,  но выйти из такого цикла можно только с помощью  <CTRL  C
(RT-11),  при  этом  управление  будет  передано  пультовому  монитору
операционной   системы.   Этого   же   можно   достичь,   перезагрузив
операционную систему.  Поэтому лучше заранее предусмотреть программные
средства выхода из цикла.  Например:  BEGIN XXXX ?TERM '105  =  UNTIL,
здесь  выход из цикла произойдет сразу,  как только вы нажмете клавишу
<Е>. Примером бесконечного цикла может служить оператор QUIT (гл.4), а
также оператор EDT в экранном редакторе:

         FORTH DEFINITIONS

         : EDT ED EDITOR LI ON ESC 61 EMIT OF CB
               BEGIN ' T1 KEY L1 5 TT ON 0
               UNTIL ;

   (За разъяснениями,  как  это  работает,  отсылаю читателей к гл.4 и
приложению  1,  где  имеется   прокомментированный   текст   экранного
редактора.)  Здесь  перед циклом BEGIN...UNTIL производится подготовка
режима редактирования,  а внутри - ожидание и исполнение редактирующих
команд (перемещение курсора, ввод и удаление символов, слов или кусков
текста).  Выход из этого бесконечного цикла осуществляется  с  помощью
оператора  QUIT  (уйти)  базового словаря Форта.  Таким образом,  если
позаботиться  о  возможности  выхода  программы  при  вводе  некоторой
последовательности символов (команды) на исполнение процедуры QUIT или
ABORT, бесконечный цикл станет не таким уж бесконечным.

   Рассмотрим несколько примеров программ,  где используются операторы
цикла:

      : LINE 0 DO ASCII * EMIT LOOP CR ;

   При обращении  k  LINE  на экране (или печатающем устройстве) будет
отображено  k  символов  *.   ASCII   -   слово,   которое   указывает
интерпретатору, что за ним следует код ASCII (см. гл.7). Используя это
описание,  напишем программу,  которая напечатает на экране квадратную
рамку из символов *:

      : FRAME DUP LINE DUP 2 - DUP 0 DO DUP ASCII * EMIT SPACES
	      ASCII * EMIT CR LOOP DROP LINE ;

при обращении 5 FRAME <BK> на экране будет напечатано

		     ******
		     ------
		     *    *
		     -    -
		     *    *
		     -    -
		     *    *
		     -    -
		     ****** OK
		     ------ --

   Число k  может  лежать  в  пределах 3<k<=24.  Последнее ограничение
связано с числом строк на экране. Последовательность ASCII * можно при
желании заменить числом 42 (десятичный код символа *). Бывает так, что
до исполнения программы нельзя определить  число  необходимых  циклов,
что  связано  с  характером  обрабатываемой входной информации.  Чтобы
решить  эту  задачу,  можно  использовать  оператор   LEAVE   (выйти),
обращение  к  которому  происходит только при выполнении определенного
условия (см.,  например,  описание слова EXPECT,  приведенное в  конце
параграфа).

   Еще одним бесконечным циклом является BEGIN XXX f WHILE YYY REPEAT.
Процедура выполняется по крайней  мере  один  раз,  так  как  проверка
условия  выхода  из  цикла помещена после нее.  Последовательность YYY
выполняется только при условии f=TRUE.  Выход из цикла происходит  при
f=FALSE.  Флаг  f  может  быть вычислен тем или иным способом,  но его
наличие в стеке перед исполнением WHILE (в то  время  как)  или  UNTIL
совершенно  необходимо,  в  противном  случае  в  качестве флага будет
рассматриваться код, который оказался к этому моменту в стеке, а это в
свою очередь может привести к разрушению программы.

   Как устроены операторы цикла?

      BEGIN ?COMP HERE 1 ; IMMEDIATE

   ?COMP проверяет, находится ли система в режиме компиляции. Если это
не так,  выдается сообщение об ошибке.  Главное  назначение  оператора
BEGIN  (начать)  -  запись  в  стек  текущего значения указателя HERE,
которое использует компилятор,  чтобы  сформировать  правильный  адрес
ветвления при обработке оператора UNTIL или REPEAT (повторить).

   Сходную структуру имеет оператор DO:

      : DO COMPILE XDO HERE 3 ; IMMEDIATE

   COMPILE XDO  компилирует в описание нового слова ссылку на оператор
XDO,  который при исполнении  записывает  в  стек  возвратов  исходные
параметры цикла (предельное и начальное значения индекса). Флаги 1 и 3
служат для контроля парности операторов цикла.  Ниже  описан  алгоритм
UNTIL:

      : BACK HERE - , ; (компилирует в описание слова адрес возврата)
      : UNTIL 1 ?PAIR COMPILE ?BRANCH BACK ; IMMEDIATE

   Здесь 1 образует пару с флагом =  1  в  операторе  BEGIN,  а  ?PAIR
контролирует  эту  парность.  Далее  в  новое  описание слова вводится
ссылка  на  оператор  ?BRANCH,  который  в  процессе  исполнения   при
определенных  условиях  передаст  управление  по адресу,  описанному в
слове BACK.

   Структура оператора WHILE еще проще:

      : WHILE IF ;IMMEDIATE

а операторов REPEAT и LOOP чуть сложнее:

      : REPEAT ROT 1 ?PAIR ROT COMPILE BRANCH BACK
               THEN ; IMMEDIATE

      : LOOP 3 ?PAIR COMPILE XLOOP BACK ; IMMEDIATE

   COMPILE BRANCH  компилирует  в  описание  слова  ссылку  на команду
безусловной передачи управления по адресу,  сформированному операторам
BACK.  Сходное  назначение  команды  COMPILE XLOOP,  но в недрах XLOOP
"спрятан" контроль условия выхода из цикла,  т.е. организован условный
переход  на  начало  цикла.  Все  это  операторы  базового  словаря  и
приведены здесь лишь для того,  чтобы показать,  насколько они просты.
Любой  программист после небольшой практики сам сможет описать сходную
процедуру, если в этом возникнет необходимость.

   Оператор IMMEDIATE всегда (когда требуется) следует непосредственно
за только что описанным словом,  преобразует его так, что оно работает
только на этапе  компиляции.  Он  выполняет  очень  простую  работу  -
изменяет  первый  байт  описания,  устанавливая  второй по старшинству
(6-й)   бит   в   единичное   состояние.   Этот   флаг    используется
интерпретатором и помеченное таким образом слово будет работать только
при интерпретации.

   В заключение  рассмотрим  алгоритм  системного  оператора   EXPECT,
который также использует циклы:

      : EXPECT   ( в стеке адрес ввода и максимальное число
        	   вводимых символов)
            0 DO ( начало цикла, в стеке только адрес ввода)

            KEY DUP 13 = ( введенный символ <ВК> ? )
            IF ( если да, то) LEAVE DROP 0 (уход из цикла,
	         если нажата клавиша <ВК>)
	    THEN OVER C! ( запись очередного символа в буфер)
	    1+           ( в стеке адрес, куда будет введен
	      		   следующий байт)
	LOOP                             ( конец цикла)
        2 ERASE ; ( запись нулей в два последних байта)

   Причины последней  операции  объясняются   в   описании   процедуры
прерывания интерпретации.


                     5.3. СТЕК ВОЗВРАТОВ


   По структуре   и   способу   функционирования   стек  возвратов  не
отличается от стека параметров (табл.12).

Таблица 12. Операции над кодами в стеке возвратов

----------------------------------------------------------------------
Имя       Состояние стека   Версия          Функция
----------------------------------------------------------------------
>R        n --> -           9, 3, F   Записывает число из стека
				      параметров в стек возвратов

R>        - --> b           9 ,3, F   Записывает число из стека
				      возвратов в стек параметров

I         - --> n           F         Копирует верхнее число из
R                           9, 3      стека возвратов и записывая в
R@                                    стек параметров

I'        - --> n           9, 3, М   Копирует второе сверху число
                                      из стека возвратов и записывает
                                      его в стек параметров

J         - --> b           9, 3      Копирует третье сверху число
                                      из стека возвратов и записывает
                                      его в стек параметров

Rp!       - --> -           F         Ставит указатель стека возвратов
                                      в исходное состояние
----------------------------------------------------------------------

   Определены процедуры  записи  числа  из  стека  параметров  в  стек
возвратов >R и обратная процедура R> (из  стека  возвратов).  Оба  эти
оператора  изменяют  указатели как стека параметров (SP),  так и стека
возвратов (RP).

   Имеются операторы, не изменяющие значение указателя стека возвратов
(I,  J,  I').  Оператор  I  (в  некоторых версиях R) записывает в стек
параметров верхнее число из стека возвратов.  Он уже использовался  во
многих  примерах  работы с циклами DO...LOOP.  Во многих версиях Форта
имеются операторы,  которые записывают в стек параметров второе (I') и
третье  (J) (в Форт-83 нумерация кодов в стеке начинается с 0,  а не с
1) числа из стека  возвратов.  В  случае  цикла  DO-LOOP  оператор  I'
позволяет считывать значение предела цикла, например

      : T 6 0 DO I' . SPACE LOOP;

   При исполнении  оператор  T отпечатает 6 6 6 6 6 6 ОК.  Здесь SPACE
необходим, чтобы цифры не слились в одно 6-значное число.

   В некоторых версиях Форта имеются операторы эквивалентные  R>  DROP
(LEV).   Примером   использования  операторов,  работающих  со  стеком
возвратов, является LEAVE (см. описание DO...LOOP):

      : LEAVE R>   ( занесение адреса возврата в стек параметров)
                 R> DROP I >R                  ( индекс - предел)
             >R ;               ( восстановление адреса возврата)

   Таким образом,  LEAVE приравнивает значения индекса и предела.  Эта
процедура  в  базовом  словаре  реализована  на  Ассемблере и выглядит
проще,  так как там не требуется  ни  первого  R>,  ни  последнего  >R
операторов.  Эти  два  слова связаны с тем,  что стек возвратов играет
определяющую роль при переходе от одной процедуры к другой  и  обратно
(отсюда  и  название  "стек  возвратов").  При  переходе  к  очередной
процедуре  адрес  возврата  запоминается  в  стеке  возвратов,  а   по
завершении операции выполняется процедура ;S,  которая восстанавливает
программный счетчик, занося в него код из стека возвратов.

   При наличии  вложенных  процедур  в  стек   возвратов   оказывается
записана  целая  цепочка адресов возврата.  Если выполнить команду LEV
(R> DROP),  то  возврат  будет  осуществлен  не  в  процедуру,  откуда
произошел  вызов,  а  в процедуру,  более раннего уровня или в систему
Форт. Это свойство широко используется в Форте для управления порядком
выполнения процедур.

   Существует аналог SP!  для стека возвратов - это RP!.  Оператор RP!
присваивает указателю стека  возвратов  исходное  (базовое)  значение.
Помнить  об этом полезно,  но пользоваться нужно осторожно.  Используя
этот оператор внутри процедуры,  мы поставим систему в затруднительное
состояние  -  она  не  будет  знать,  куда  ей  передать управление по
завершении исполнения,  и передаст куда придется.  Можно считать,  что
применение  RP!  есть  привилегия  операторов  типа QUIT или ABORT.  В
пультовом режиме эта команда выполнима,  но от нее мало проку:  в этом
случае стек возврата и без того находится в исходном состоянии. Именно
поэтому, работая в пультовом режиме, нельзя выполнять операторы R> или
LEV.   Попытка   их   исполнить   может  привести  к  непредсказуемому
результату.  Надо  сказать,  что,  предоставляя  программисту  большие
возможности.   Форт   дает   ему  доступ  к  немалому  разрушительному
потенциалу.

  Важной функцией  стека  возвратов  является  возможность  временного
запоминания  кодов  из стека параметров.  Это делает работу с основным
стеком  более  гибкой.  Нужно  только  не  забывать  так   или   иначе
восстанавливать стек возврата до выхода из процедуры. Например:

      : /MOD                ( в стеке параметров делимое и делитель)
             >R                  ( запись делителя в стек возвратов)
             S->D    (преобразование делимого в число двойной длины)
             R>                ( возврат делителя в стек параметров)
             M/ ;                              ( выполнение деления)

   Немало аналогичных   образцов   использования  стека  возврата  для
аналогичных целей вы найдете и в других разделах.

   Упражнение 1.
   Пусть массив из 64 элементов 0 VARIABLE MAS 126 ALLOT. В результате
работы некоторой программы этот массив заполняется  числами.  Напишите
программу  MAXI,  которая  выбирает максимальный элемент массива MAS и
записывая его в стек.

   Решение см.  в  8.1 (оператор CMAX).

   Упражнение 2.
   Опишите слово с именем N!,  которое вычисляет значение N!,  где N -
число в стеке. Результат вычисления также записывается в стек.

   Решение.

   : N! 1 SWAP 0 DO I 1+ * LOOP ;

   Упражнение 3.
   Опишите оператор,  который  распечатывает таблицу кодов ASCII в 8-,
16-ричном и десятичном представлении. Имя оператора ASCTAB.

   Решение.

   : ASCTAB ." OCT NEX DECI CHAR OCT HEX DECI CHAR  "
            ." OCT HEX DECI CHAR"   CR     ( печать заголовка)
            128 32 DO  ( начало цикла, первый символ - пробел)
            I OCTAL 3 .R      ( распечатка 8-ричного значения)
            SPACE 1 HEX 3 .R ( распечатка 16-ричного значения)
            SPACE 1 DECIMAL 3 .R      ( распечатка десятичного
				        значения кода)
	    3 SPACES 1 EMIT        ( распечатка ASCII-символа)
            5 SPACES 1 3 MOD 0= IF CR THEN  ( укладка таблицы
					        в три колонки)
            LOOP ;

   При обращении ASCTAB <ВК> будет напечатана таблица в виде:

    ОСТ HEX DECI CHAR    ОСТ HEX DECI  CHAR   ОСТ NEX DECI CHAR

    40  20  32           41  21  33    !
    42  22  34   "       43  23  35    #      44  24  36   $
    45  25  37   %       46  26  38    &      47  27  39   '
    50  28  40   (       51  29  41    )      52  2A  42   *
    53  2B  43   +       54  2C  44    ,      55  2D  45   -
    56  2E  46   .       57  2F  47    /      60  30  48   0
    61  31  49   1       62  32  50    2      63  33  51   3
    64  34  52   4       65  35  53    5      66  36  54   6
    67  37  55   7       70  38  56    8      71  39  57   9
    72  3A  58   :       73  3B  59    ;      74  3C  60   <
    75  3D  61   =       76  3E  62    >      77  3F  63   ?
   100  40  64   @      101  41  65    A     102  42  66   B
   103  43  67   C      104  44  68    D     105  45  69   E
   106  46  70   F      107  47  71    G     110  48  72   Н
   111  49  73   I      112  4A  74    J     113  4B  75   K
   114  4C  76   L      115  4D  77    М     116  4E  78   N
   117  4F  79   O      120  50  80    P     121  51  81   Q
   122  52  82   R      123  53  83    S     124  54  84   T
   125  55  85   U      126  56  86    V     127  57  87   W
   130  58  88   X      131  59  89    Y     132  5A  90   Z
   133  5B  91   [      134  5C  92    \     135  5D  93   ]
   136  5E  94   ^      137  5F  95    _     140  60  96   Ю
   141  61  97   А      142  62  98    Б     143  63  99   Ц
   144  64  100  Д      145  65  101   Е     146  66  102  ф
   147  67  103  Г      150  68  104   Х     151  69  105  И
   152  6A  106  Й      153  6В  107   К     154  6C  108  Л
   155  6D  109  М      156  6Е  110   Н     157  6F  111  О
   160  70  112  П      161  71  113   Я     162  72  114  Р
   163  73  115  С      164  74  116   Т     165  75  117  У
   166  76  118  Ж      167  77  119   В     170  78  120  Ь
   171  79  121  Ы      172  7A  122   3     173  7В  123  Ш
   174  7C  124  Э      175  7D  125   Щ     176  7Е  126  Ч

   Обьясните, почему  начало  таблицы  выглядит именно так и как этого
можно  избежать?  Русская  часть  таблицы  лишь  один   из   вариантов
кодировки.)

   Упражнение 4.
   Опишите слово NLOAD,  которое при обращении K N NLOAD  загружает  N
экранов, начиная с K.

   Упражнение 5.
   Опишите оператор, который при обращении K N LISTING выдает на экран
(или печать) N экранов, начиная с K.

   Упражнение 6.
   Опишите оператор,  который при обращении  N  WORDS  печатает  число
описаний вида: NNN ...; на экране с номером N.

   Решение.

   : WORDS 0 (счетчик описаний) SWAP
           BLK @ >R IN @ >R         ( сохранение в стеке возвратов
                                      значений BLK и IN)
           BLK ! 0 IN !         (установка новых значений BLK и IN)
           BEGIN '72 WORD ( выделение последовательности символов,
                            завершающейся кодом ":")
	   1+                    ( инкрементация счетчика описаний)
           IN @ 1023 >               ( проверка значения указателя
                                  буфера - условие выхода из цикла)
           UNTIL R> IN ! R> BLK !        ( восстановление IN и BLK)
           1- ." WORD#=" ;                 ( распечатка результата)

   Упражнение 7.
   Опишите слово,  которое при обращении SI SN WORD_LIST пропечатает в
четыре  колонки  имена  операторов,  описания  которых  содержатся  на
экранах S1,...,SN.

   Решение.

   : WORD_LIST 1+ SWAP BLK @ >R IN @ >R DO      ( цикл по экранам)
               ." S#=" I . CR           ( печать заголовка экрана)
               I BLK ! 0 IN !         ( начало работы с очередным
                                        экраном)
               0 BEGIN '72 WORD               ( поиск символа ":")
               32 WORD HERE COUNT TYPE             ( печать имени
                                             очередного оператора)
               14 HERE C@ - 1 MAX SPACES  ( организация табуляции)
               1+ DUP 4 = IF DROP 0 CR THEN        ( формирование
                                   переноса на новую строку после
                                   распечатки 4 имен)
               IN @ 1023 > UNTIL   ( проверка условия завершения
                                     работы с текущим экраном)
               DROP CR CR          ( переход к следующему экрану)
               LOOP R> IN ! R> BLK ! ;
