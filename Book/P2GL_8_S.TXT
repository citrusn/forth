         Глава 8. ПРИМЕНЕНИЕ ФОРТА ДЛЯ СИСТЕМ, РАБОТАЮЩИХ
                     В РЕАЛЬНОМ МАСШТАБЕ ВРЕМЕНИ


   Программированию для  устройств,  работающих  в  реальном  масштабе
времени,  присуща  зависимость  от  структуры  и  особенностей  ЭВМ  и
периферийного оборудования.  Аппаратная часть таких систем строится по
магистрально-модульному    принципу    и   обычно   стандартизируется.
Стандартизация позволяет сократить требуемый ассортимент  интерфейсов,
но полной унификации достичь не удается. Отсюда и разнообразие пакетов
управляющих программ.  В таких условиях немалым достоинством  является
простота  адаптации программного обеспечения к новой аппаратуре.  Форт
предоставляет в этом смысле неплохие  возможности.  К  числу  наиболее
известных  и  распространенных  стандартов  на  магистрально-модульные
системы  относятся  КАМАК,  шина   МЭК-625   (приборная   шина,   ГОСТ
26.003-80),  Q-BUS,  UNIBUS,  ФАСТБАС,  VME  и Мультибас [42-44,  46].
Последние три стандарта  ориентированы  на  работу  с  большим  числом
процессоров.

            15                                             0
	   ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬───┬──┬──┬──┬──┐
	   │ Z│ C│R4│R2│R0│M4│M2│M0│ Q│ X│ I│F16│F8│F4│F2│F0│ CSR
           └──┴──┼──┴──┴──┼──┴──┴──┼──┴──┴──┴───┴──┴──┴──┴──┘
                 │   Код  │  Маска │
                 прерывания
	    15                                          0
           ┌──┬──┬──┬──┬──┬──┬───┬──┬──┬──┬──┬──┬──┬──┬──┐ Адрес
           │ 1│ 1│ 1│ 0│C2│C1│N16│N8│N4│N2│N0│A8│A4│A2│A0│ модуля
           └──┴──┴──┴──┴──┴──┴───┴──┴──┴──┴──┴──┴──┴──┴──┘

Рис. 9. Назначение   разрядов  регистра  CSR  и  регистра  данных  в
                    интерфейсе системы КАМАК

   Приступая к       написанию       программ      для      управления
магистрально-модульными   системами,   нужно    выяснить    устройство
интерфейса  ЭВМ-магистрально-модульная система и способ взаимодействия
процессора с внешними устройствами. Ниже будут рассмотрены примеры для
случая,  когда  обращение  к  внешним устройствам осуществляется через
специально выделенную адресную зону,  как правило, это 4 Кслов нулевой
или последней страницы памяти (ЭВМ СМ1420,  ДВК и т.д.). Обычно в этой
зоне для любого внешнего устройства выделяется два или более  адресов.
В  простейшем варианте первому адресу соответствует регистр управления
и состояния (CSR),  второму - регистр данных.  Взаимодействие внешнего
устройства с ЭВМ реализуется через прерывания [48].

   Предположим, мы  работаем с системой КАМАК [42],  интерфейс которой
имеет следующую структуру CSR (рис.9).  Здесь R0,  R2,  R4  -  разряды
вектора (код) прерывания,  адрес которого равен 340 + R*4,  т.е.  344,
350,  354,  360,  364,  370 и  374  (все  числа  восьмеричные).  Всего
предусмотрено семь векторов прерывания.  M0,  M2,  M4 определяют порог
прерывания.  Если код М равен коду R,  прерывание не происходит. Код R
записывается из системы КАМАК,  а читается в ЭВМ на аппаратном уровне.
F0,  F2,  F4,  F8,  F16 - поле команд системы КАМАК;  Q и X - отклики,
посылаемые  модулями;  I - флаг блокировки (запрета);  Z и C - разряды
для  выработки  команд  подготовки  и   сброса   соответственно.   При
прерывании управление передается по адресу, указанному в одном из семи
векторов (344...374).  C1 и C2  -  разряды  для  идентификации  номера
каркаса,  это означает, что данная схема позволяет обращаться максимум
к четырем каркасам.  N0,  N2,  N4,  N8,  N16  -  номера  станций,  где
расположены модули, A0, A2, A4, A8 - субадрес регистра в модуле.

   Чтобы обратиться  к  тому  или иному модулю КАМАК,  надо записать в
регистр CSR  код  команды  (F0...F16),  затем  обратиться  по  адресу,
соответствующему этому модулю. Этот адрес вычисляется по формуле

      ADR = CAMAC_BASE + N*32 + A*2,

где CAMAC_BASE  ='160000  (зависит  от  типа  интерфейса);  N  - номер
станции,  где расположен модуль в каркасе;  A -  субадрес  регистра  в
модуле.    Адрес   может   быть   вычислен   заранее   или   определен
непосредственно перед обращением.

   При отладке аппаратуры и в управляющих задачах удобно  использовать
операторы MODL и MODLA:

   OCTAL 166000 CONSTANT CRATE
         160000 VARIABLE CSR
   : MODL <BUILDS 40 * CRATE + ,        ( Вычисление KAMAK-адреса
                                   модуля и запись его в описание
                                     нового слова с именем <NAME>)
           DOES> @ ;

   MODL позволяет сформировать слово,  которое  при  исполнении  имеет
свойства константы.  Обращение к MODL имеет вид N MODL <ИМЯ>,  где N -
номер станции,  где расположен данный модуль;  <ИМЯ>  -  условное  имя
модуля КАМАК. Обращение к MODLA несколько иное: SA N MODLA <NAME>, где
SA - субадрес регистра в модуле:

      : MODLA <BUILDS 40 * CRATE + SWAP 2* + , DOES> @ ;

   MODL вычисляет адрес модуля КАМАК при нулевом субадресе,  а MODLA -
при произвольном. В обоих случаях в поле параметров записывается адрес
модуля КАМАК, вычисленный в процессе интерпретации.

   Пусть модуль аналого-цифрового преобразователя  ADC1  установлен  в
станции 7.  Его описание:  7 MODL ADC1. Выполнив команду 0 CSR ! ADC ?,
получим на экране значение кода, записанного в модуле. ADC1 записывает
в  стек  восьмеричное  число  166340  - адрес модуля КАМАК ADC1.  Если
модуль  допускает  запись  в  него  данных,   такую   операцию   легко
осуществить:  FF CSR ! K ADC1 !, где FF - код команды записи; K - код,
записываемый в регистр модуля ADC1.  Стандартный оператор чтения может
иметь вид

      : RD CSR ! @ ;

обращение к нему:  ADR FF RD, где FF - код команды чтения, ADR - адрес
модуля КАМАК.  По команде CSR ! код команды записывается в регистр CSR
КАМАК-интерфейса,  @  считает содержимое регистра в модуле,  используя
команду FF.  Например,  ADC1 2 RD выполняет чтение со стиранием (F=2).
Запись ( : WT CSR ! ! ; ) осуществляется аналогично: М ADC1 FF WT, где
М - код,  записываемый в регистр (или память) модуля; FF - код команды
записи (например, FF=17).

   Для проверки откликов, вырабатываемых модулем (Q и X), когда это не
делается аппаратно,  достаточно выполнить команду CSR @  '300  AND.  В
результате  в  стеке  окажется  число,  в разрядах 6 и 7 которого (см.
рис.9) будут флаги откликов Q и X  соответственно.  Установка  системы
КАМАК в исходное состояние выполняется командой '100000 CSR !, команда
'40000  CSR  !  сбрасывает  все  регистры  КАМАК-системы  в   исходное
состояние.  Сброса  в  нуль  соответствующих  разрядов регистра CSR не
требуется, так как в этом случае запись реально не производится.

   Можно было бы решить задачу  чтения  содержимого  регистров  модуля
ADC1  и  с  помощью  процедуры  0  CSR !  7 32 * CRATE + ?  или внутри
описания какого-либо слова 0 CSR !  [7 32 * CRATE + ] LITERAL ?.  Если
чтение  или  запись  ADC1  выполняется  только  один раз,  оба решения
приемлемы,  хотя  и  громоздки.  Первый  вариант,  кроме  того,  более
"медленный",  так  как  вычисление  КАМАК-адреса производится во время
исполнения программы.  Эти решения,  конечно,  и менее  наглядны.  При
работе  с персональными ЭВМ в интерпретаторе необходимо иметь команды,
эквивалентные  IN  и  OUT  (READ  и  PORT,  см.   описание   программы
"Подмосковные вечера" в  8.3).

   Примером управляющей  программы  для  системы  КАМАК  может служить
программа в приложении 4.  Назначение программы - тестирование  памяти
емкостью  1024  слов  (32-разрядных).  Предполагается,  что  доступ  к
младшим 16 разрядам возможен по субадресу A0,  а к старшим  -  по  A1.
Запись числа в адресный регистр памяти осуществляется по команде F17.

   В первой  строке  описано  имя  КАМАК-модуля  памяти  (MEM) и адрес
управляющего регистра CSR интерфейса  КАМАК.  Далее  следуют  описания
процедур чтения и записи (RD и WT),  а также записи в адресный регистр
модуля памяти (MAW). Ниже записана интерактивная процедура определения
положения  модуля в каркасе и вычисления его КАМАК-адреса (START).  На
запрос MEMO BIN-> надо ввести номер  станции,  где  расположен  модуль
памяти.  Это  число  во  входной  буфер  записывает оператор QUERY,  а
INTERPRET  преобразует  его  и  передает  результат  в   стек.   Далее
полученное число умножается на 32 и складывается с содержимым регистра
CSR.  Оператор 'MEM записывает в  стек  адрес  константы  MEM,  а  "!"
записывает  адрес  модуля КАМАК.  Оператор MCLEAR очищает все регистры
модуля памяти.  В самой  тестовой  программе  (MTEST)  0  MAW  очищает
адресный  регистр  модуля  памяти.  Проверка проводится путем записи и
последующего чтения по субадресам 0 и 1 кодов 0, 1, 2, 4, 8, 16 и т.д.
(побитовый  контроль).  При  совпадении записанного и считанного кодов
тестирование продолжается для следующих адресов. В случае несовпадения
сообщается  адрес,  субадрес,  а  также  записанный  и  считанный коды
(операторы  ERR  и  RED).  Тестирование  выполняется   на   процессоре
"Электроника-60" менее 10 с.

   Основу взаимодействия   программы   с   периферийным  оборудованием
составляют  прерывания.  К  сожалению,  в   базовых   словарях   Форта
отсутствуют  стандартные  процедуры обслуживания прерываний.  Конечно,
можно написать программу обработки прерываний на  Форт-ассемблере,  но
это   не  всегда  удобно,  ведь  тогда  надо  дополнительно  загружать
несколько  экранов  этой  библиотеки.  По  этой   причине   в   версию
Форт-интерпретатора, работающую на ЭВМ типа СМ или ДВК, разумно ввести
оператор,  который позволял бы  формировать  программы  для  работы  с
прерываниями на Форте:

      : [[ LIT DOIN LATEST PFA CFA LIT 24 CMOVE LIT 22 ALLOT HERE
           DUP LIT 6 - ! ; IMMEDIATE

   Несколько необычна структура [[,  но такой  вид  она  имеет  внутри
интерпретатора.  Именно  поэтому  здесь  применен оператор LIT.  Сразу
вслед за описанием  [[  помещается  программа  на  Ассемблере,  первый
оператор которой имеет метку DOIN:

   DOIN:   JSR   R5,        @#SAVREG ; Сохранение содержимого
				     ; всех регистров
           MOV   #INIST,    R5       ; Инициализация стека
				     ; прерываний
           MOV   @#USER,    R3       ; Восстановление
				     ; указателя области USER
           MOV   (PC)+,     IP       ; Уход в программу
				     ; пользователя
           HALT
           NEXT                      ; Макроопределение перехода
	                             ; к следующей Форт-процедуре

   Кроме того, вводится Форт-примитив, который имеет имя ]] и содержит
только  одну  команду  RTS  PC (ЭВМ типа СМ или ДВК).  Как же выглядит
программа обслуживания прерывания на Форте?  Пусть имя этой  программы
XXX:

      : XXX [[ НОМЕ 50 SPACES ." Московское время "
            TI 7 EMIT ]];

где HOME  -  слово,  устанавливающее  курсор на экране в верхнее левое
положение;  TI - оператор,  который выдает на экран время в виде ЧЧ:ММ
(часы:минуты).

   Программа, записанная   между   [[   и  ]],  служит  для  обработки
прерываний.  На этапе трансляции оператор [[ первым  делом  запишет  в
стек  адрес  программы  DOIN  (LIT  DOIN),  далее  адрес CFA слова XXX
(LATEST PFA CFA) и наконец начиная с этого  адреса  в  новое  описание
вставляется  программа DOIN (LIT 24 CMOVE,  программа DOIN содержит 20
байт),  изменяется  указатель  HERE.  В  завершение  на   место   HALT
записывается ссылка на процедуру,  следующую за [[. Так как прерывание
может произойти в момент,  когда указатели стека  параметров  и  стека
возвратов   имеют  произвольное  значение  (например,  при  исполнений
-FIND), последовательность слов после [[ пользуется специальным стеком
-  стеком  прерываний.  Это  же касается и указателя области USER.  На
программу прерывания не накладывается никаких ограничений. Не следует,
разумеется, переполнять стек прерываний, все остальное разрешено.

   Теперь, самое  время  вспомнить  про векторы прерываний:  ' XXX CFA
'100 !  (запись адреса программы прерывания в  ячейку  с  восьмеричным
адресом 100),  '340 '102 ! (запись значения PS в ячейку с восьмеричным
адресом 102).  Теперь, если организовать прерывание один раз в минуту,
то  в  верхней  правой  части  экрана  периодически  будет  печататься
"Московское время ЧЧ:ММ" и одновременно будет даваться звуковой сигнал
(7 EMIT).

   Таким образом,  программа  обработки  прерывания  может иметь любое
имя,  после которого  обязательно  следует  оператор  [[.  Завершается
программа  оператором  ]],  который  возвращает  управление прерванной
программе,  предварительно восстанавливается состояние всех  регистров
общего  назначения.  В конце описания ставится ";" никаким исполняемым
операциям  ";"  здесь  не  соответствует.  Программа  работает   и   в
автономной версии Форта вне рамок какой-либо операционной системы.

   При создании   контроллеров  внешних  устройств  и  спецпроцессоров
широко используется микропрограммирование,  а  это  вызывает  довольно
серьезные  проблемы  комплексно-аппаратной  наладки таких систем [33].
Трудности  здесь  связаны,   с   одной   стороны,   с   использованием
разнородного  математического  обеспечения (микроассемблеры,  например
ADMASM,  управляющие программы  внешних  устройств  и  диагностические
программы),  а  с  другой  - с не вполне отлаженной аппаратурой (поиск
ошибок  в  микропрограммах),  когда  нельзя  с   полной   уверенностью
установить,  аппаратная  или  программная ошибка имеет место.  В такой
ситуации гибкость и быстрая адаптация диагностического  матобеспечения
является привлекательным качеством.

   Как можно использовать Форт в такой ситуации?  В качестве примера в
приложении   4   представлена   тестовая   программа    для    отладки
микропрограммного    32-разрядного    процессора.    Процессор   имеет
независимую память для данных (входных и  выходных)  и  микропрограмм.
Микропрограмма  может загружаться вручную (в диалоговом режиме) или из
файла,  подготовленного  с  помощью  микроассемблера  [45],  в  модуль
памяти,  выполненный  в  стандарте  КАМАК.  Взаимодействие между ЭВМ и
системой КАМАК идентично  описанному  выше.  Доступ  к  нужному  файлу
происходит через процедуру FILCH.  Чтение файла производится с помощью
оператора  BLOCK  по  1024  байт.   По   завершении   чтения   система
возвращается  в  состояние,  когда  именем файла по умолчанию является
FORTH.DAT (оператор DEFOL).  Формат записи соответствует используемому
интерпретатором М1804 (AMDASM).



                    8.1. ГИСТОГРАММИРОВАНИЕ


   При исследовании различных распределений результаты измерений имеют
вид  гистограмм.  Гистограмма  представляет  собой  обычно  одно-  или
двумерный массив чисел,  каждое из которых равно  количеству  событий,
лежащих   в   определенном   интервале   по   одному   или  нескольким
экспериментальным параметрам (амплитуде, времени, частоте и пр.).

   Пусть необходимо отобразить массив размером М слов (например, M=16)
с  именем  HH  в  виде  гистограммы.  Это  можно  сделать,  поставив в
соответствие  каждому  числу  в  массиве  строку  символов  X  длиной,
пропорциональной  этому  числу.  Сначала  определим максимальное число
отсчетов в массиве (N MAX)  и  масштаб  гистограммы,  т.е.  скольким
отсчетам соответствует один символ X.  Опишем оператор (HIST), который
построит  гистограмму  на  экране  или  печатающем  устройстве.   Ниже
приводится текст одной из возможных реализаций:

   16 CONSTANT K                  ( число каналов в гистограмме)
   0 VARIABLE HH 32 ALLOT              ( массив для гистограммы)
   : CMAX        ( оператор для определения максимального числа
                   отсчетов в каналах гистограммы)
          0 NMAX !               ( присвоение X переменной NMAX)
          K 0 DO    ( начало цикла перебора каналов гистограммы)
          HH I 2* + @ ( занесение в стек содержимого очередного
			канала гистограммы)
          DUP NMAX @ >               ( это число больше NMAX ? )
          IF NMAX !          ( если да, то меняем значение NMAX)
          ELSE DROP THEN ( в противном случае удаляем это число
                           из стека)
          LOOP ;
   : FILHI            ( тестовое заполнение массива гистограммы)
	  HH 40 ERASE 8 0 DO I 1+ HH I 2* + ! LOOP
               8 0 DO 8 I - HH 16 +  I 2* + ! LOOP
   : LINE 0 DO '130 EMIT LOOP ;    ( печать строки символов X ,
                        обращение N LINE печатает N символов X )
   : HIST CMAX ." HISTOGRAMM" CR 0 DO       ( печать заголовка
		          и начало цикла по каналам гистограммы)
          DUP I 2* + @         ( извлечение очередного числа из
				 гистограммы)
	  DUP 3 .R SPACE       ( печать числа отсчетов в канале)
          60 NMAX @ */                        ( масштабирование)
          -DUP IF       ( если нужно отпечатать хотя бы один X )
          LINE CR THEN LOOP DROP ;

   Конечно, это примитивная  гистограмма,  так  как  здесь  не  указан
масштаб,  исходные данные и т.д., но при желании этот недостаток легко
устранить. При обращении FILHI HH K HIST будет отпечатано

    HISTOGRAMM

        1 XXXXXXX
        2 XXXXXXXXXXXXXXX
        3 XXXXXXXXXXXXXXXXXXXXXX
        4 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        5 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        6 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        7 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        8 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        8 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        7 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        6 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        5 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        4 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        3 XXXXXXXXXXXXXXXXXXXXXX
        2 XXXXXXXXXXXXXXX
        1 XXXXXXX

   Рассмотрим более  сложный вариант печати гистограмм,  когда каждому
числу из указанного массива ставится  в  соответствие  колонка  (а  не
строка)  символов  X.  Это  более  традиционный  способ  представления
гистограмм.  Здесь при выводе на печать нет ограничения на масштаб  по
числу   отсчетов,  так  же  как  в  описанном  ранее  методе  не  было
ограничения на число каналов гистограммы.

   Предположим, что для гистограммы  зарезервировано  16  строк  и  16
колонок.  Практически  на  экране  24  -  25 строк и 60 - 132 колонки.
Зарезервируем в  памяти  16x16  байт.  Это  можно  сделать  с  помощью
оператора  0  BUFFER.  Не  беда,  что  буфер  будет много больше,  чем
требуется,  ведь мы занимаем его только  на  время.  Заменив  0  перед
BUFFER   на  номер  свободного  экрана,  можно  будет  легко  записать
полученную  гистограмму  на  диск.  Опишем  слово,  которое  заполняет
таблицу   16x16   кодами   пробела  или  X  в  соответствии  с  формой
гистограммы. Масштабный коэффициент в этом случае 16/MAX. Именно такой
коэффициент обеспечивает то, что каналу с максимальным числом отсчетов
будет соответствовать колонка с 16 X.  Ниже приводится текст  описания
оператора FILTAB:

   0 VARIABLE BUF                           ( указатель буфера)
   : FILTAB CMAX ( поиск канала с максимальным числом отсчетов)
            0 BUFFER             ( выделение временного буфера)
            DUP 16 16 * BLANKS   ( заполнение буфера пробелами)
            DUP BUF !              ( запоминание адреса буфера)
            HH 16 0 DO               ( начало цикла no каналам)
            DUP I 2* + @ ( занесение числа отсчетов в канале в
			   стек )
	    16 NMAX @ */                     ( масштабирование)
            -DUP IF                   ( если число отсчетов $0)
            0 DO  ( цикл заполнения колонки кодами символов X )
            BUF 6 240  ( занесение в стек адреса буфера, 240=
                         16*16 -16 - адрес левого нижнего края
                         таблицы)
            + J                        ( индекс внешнего цикла)
            + I 16 * -  ( вычисление истинного текущего адреса
			  элемента таблицы)
            '130 ( код "X") SWAP C!    ( занесение X в таблицу)
            LOOP THEN LOOP DROP DROP ;
   : TYHI FILTAB K 0 DO BUF @ I 16 * + 16     ( размер колонки)
          TYPE CR                      ( печать строки таблицы)
          LOOP ;

который укладывает X в таблицу 16x16

		              XX
		              XX
		             XXXX
		             XXXX
		            XXXXXX     2
		            XXXXXX     3
		           XXXXXXXX    4
		           XXXXXXXX
		          XXXXXXXXXX
		          XXXXXXXXXX
		         XXXXXXXXXXXX
		         XXXXXXXXXXXX
		        XXXXXXXXXXXXXX
		        XXXXXXXXXXXXXX
		       XXXXXXXXXXXXXXXX
		       XXXXXXXXXXXXXXXX



   Оператор TYHI  заполняет  таблицу  и  печатает  гистограмму в виде,
приведенном выше. В этом варианте печать числа отсчетов в канале также
трудоемкая  задача,  так как (1-4)-разрядные числа должны печататься в
столбик, например так, как это показано для 234 справа от гистограммы.


                        8.2. ВРЕМЯ И ДАТА


   При проведении экспериментов и в процессе технологического контроля
важно  фиксировать  время и дату измерений.  Для хранения информации о
времени и дате в автономной версии выделено три ячейки непосредственно
перед "нижней" границей словаря,  первые две для времени. При работе с
операционной системой можно воспользоваться системным сервисом.

   При стартовой загрузке Форт-системы в ячейку с  абсолютным  адресом
'100  (как  и  в  ОС  КТ-11)  записывается  адрес  программы обработки
прерываний от внутренних часов  ЭВМ.  Для  начальной  установки  часов
служит оператор TIME,  для оперативного отображения служит обращение к
TIME TIME ЧЧ ММ СС,  например TIME 9 43 00. Выходной формат данных для
TI имеет вид ЧЧ:ММ:СС.

   : C CONSTANT ; 1 C JAM 2 C FEB 3 C MAR 4 C APR 5 C MAY 6 C
         JUN 7 C JUL 8 C AUG 9 C SEP 10 C ОСТ 11 C NOV 12 C DEC

   : TI FEHCE @ 6 -     ( вычисление адреса первой ячейки, где
                          лежит код времени)
        DUP @         ( запись в стек первого из кодов времени)
        SWAP 2+ @      ( запись в стек второго [старшего] кода
                         времени)
        50 DIV 3600 M/MOD DROP           ( в стеке число часов)
        2 .R                                    ( печать часов)
        58 EMIT                           ( печать символа ":")
        60 /MOD 2 .R                            ( печать минут)
        58 EMIT 2 .R ;                         ( печать секунд)
   : TIME !CSP                      ( фиксация состояния стека)
          IHTERPRET            ( интерпретация введенного кода)
          CSP @ SP@ - DUP 4 >     ( определение и анализ числа
				    введенных цифр)
          IF 6 = IF 0 THEN
          SHAP 60 * + 0 ROT 0 3600 MUL D+ 50 MUL    ( упаковка
		                                входных данных)
          FENCE @ 6 -  ( в стеке адрес первой из ячеек времени)
          >R R 2+ I R> ! ( запись результатов в ячейки времени)
          ELSE SI! TI THEN ;

   Соответствующие операторы для даты имеют имена DATE и DA. Обращение
DATE DD MON YY,  например 18 JAN 89. Алгоритм работы оператора DA схож
с TI. Отличительной особенностью DA является выделение имени месяца из
ряда описаний констант-месяцев.

   : DATE INTERPRET    ( интерпретация введенного кода даты)
	  82 - SMAP 32 * + 32 * +
          FEHCE @ CFA ! ; ( запись результата в ячейку даты)
   : DA   FENCE @ CFA
	  @ 32 /MOD 32 /MOD ROT 2 .R 45 EMIT 1- 10 * 7 -
          ' JAN + 3 TYPE 45 EMIT
          82 + 2 .R ;

   Выходной формат имеет вид,  например, 18-JAN-89. Форматы хранения и
представления информации о времени и дате аналогичны используемым в ОС
RT-11.

   При работе с ОС (в частности,  КТ-11) можно пользоваться системными
запросами, но для этого должен быть загружен Форт-ассемблер:

   OCTAL
   CODE DATA   12 400 * # RO MOV   374 EMT ( системный запрос)
		      RO S-) MOV NEXT C;
   ( DATA заносит в стек код даты)
   DECIMAL
   : DAT DATE DUP '37 AND 72 + SWAP 32 / '37 AND SWAP 32 / '17
         AND SMAP 2 .R '55 EMIT DUP 10 < IF '60 EMIT 1 .R ELSE
         2 .R THEN '55 EMIT . ;

   DAT извлекает,  дешифрует и отображает  на  экране  (или  печатает)
дату.  Если  сегодня  7  июля  1990 г.,  то при обращении DAT <ВК> ЭВМ
отпечатает 7-07-90 ОК.
           - -- -- --


                       8.3. ГРАФИКА И МУЗЫКА


   Сегодня трудно  представить  современную  вычислительную машину без
графических внешних устройств (монитор,  графопостроитель, графическая
печать  и  т.д.).  К  сожалению,  до сих пор не существует приемлемого
стандарта на входной формат данных и программный  интерфейс  для  этих
устройств.  Поэтому  для  каждого устройства приходится создавать свой
пакет  графических  программ,  а  если  сюда   добавить   многообразие
интерфейсных схем, то станет ясно, что и для таких программных средств
адаптивность является одним из важнейших  качеств.  В  рамках  системы
Форт  имеется  специальный  пакет  программ  для  графических операций
GRAFORTH.  Некоторые операторы,  связанные  с  построением  простейших
графических   объектов,   стали   в  Форте  стандартными  [19].  Любой
графический  образ  в  простейшем  случае  можно  представить  в  виде
совокупности точек.

   Оператор для  отображения  точки  на  экране  (или  другом  внешнем
графическом устройстве) имеет имя PLOT.  Обращение к нему: X Y L PLOT,
где X и Y - значения координат "x" и "y"; L - код цвета/яркости точки,
L=0 означает гашение изображения в данной точке.  X=Y=0  соответствует
нижнему   левому   краю  графического  поля  либо  верхнему  левому  в
зависимости от типа графического адаптера.  В любом случае  X  и  Y  -
числа целые и положительные.

   Другим графическим оператором является DRAW,  который рисует прямые
линии,  обращение к нему:  X Y L DRAW,  где X и Y -  координаты  конца
линий; L - код цвета/яркости, как и в случае PLOT. Линия начинается из
точки,  заданной текущим положением курсора. Если положение курсора не
известно,  а  графический  адаптер не позволяет его считать,  то можно
использовать комбинацию PLOT и DRAW,  например 100 100 0 PLOT 50 50 10
DRAW.  По  этой  команде  будет нарисован диагональный отрезок прямой.
Если теперь выдать команду 100 100 0  DRAW,  то  этот  отрезок  прямой
будет  стерт.  В  некоторых  реализациях  параметрами  оператора  DRAW
являются приращения координат X и Y по отношению к текущему  положению
курсора.  Структура  L-кода  индивидуальна  для  различных графических
адаптеров,  поэтому  прежде  чем  пользоваться  графическим   пакетом,
который   вы   приобрели,  необходимо  произвести  его  настройку  под
имеющийся адаптер.

   В графическом  пакете  программ  обычно   имеются   операторы   для
включения-выключения  графического  режима,  например  G-MODE и Т-MODE
(графический и текстовый режимы).  Полезным оператором может оказаться
LABEL,  который  временно  переключает  монитор  в  текстовый  режим и
печатает строку текста длиной L.  Обращение к нему:  ADR L X Y  LABEL,
где  ADR  -  адрес первого байта текста;  X и Y - координаты положения
первого символа в строке.  Нетрудно описать слова, перемещающие курсор
в графическом режиме вправо, влево, вверх или вниз на один стандартный
шаг (RIGHT,  LEFT,  UP и DOWN),  а также операторы ON и  OFF,  которые
включают  и выключают режим рисования,  т.е.  при ON любое перемещение
курсора приводит к вычерчиванию  отрезка  прямой.  Размер  шага  можно
задать переменной STEP.

   Изображение можно  сопровождать музыкой.  Для этого введен оператор
ВЕЕР.  Обращение:  F D ВЕЕР,  где F - частота,  Гц;  D -  длительность
звучания  в некоторых единицах,  например в секундах.  Простые мелодии
можно описать массивом,  состоящим  из  определенного  количества  пар
чисел, первое задает длительность, а второе - частоту. Вне зависимости
от того, как реализуется воспроизведение, через программируемый таймер
или   через   звукосинтезатор,  исходная  запись  мелодии  описывается
последовательностью чисел.  Ниже приводится  текст  программы  (TUNE),
которая исполняет первые такты мелодии "Подмосковные вечера":

      1 VARIABLE TU 6223 , 1 , 5232 , 1 ,  4153 , 1 , 5232,
      2 , 4662 , 1 , 5232 , 1 , 5532 , 2 , 4153 , 2 , 4662 ,
      2 , 6223 ,
      3 CONSTANT ADJ ( подстройка частоты)
      : FREQ ADJ / 182 67 PORT DUP '377 AND 66 PORT 256 / 66 PORT ;
      : WAIT 0 DO I DROP I DROP LOOP ;
      : NOTA FREQ 15000 * WAIT ;
      : TUNE 97 READ 3 OR 97 PORT 20 0 ( воспроизведение мелодии)
             DO TU I 2 * + DUP @ SMAP 2+ @ NOTA 2
             +LOOP 97 READ '177774 AND 97 PORT ;

   Предполагается, что интерпретатор  имеет  процедуры  PORT  и  READ.
Первая из них берет из стека номер порта (P) и посылает туда байт (B),
лежащий  в  стеке.  Обращение:  B  P  PORT.  Оператор  READ  считывает
состояние   порта,   номер   которого  находится  в  стеке.  Результат
записывается в стек.  Для записи мелодии описываем массив TU,  который
содержит в четных словах длительность звука, а в нечетных - частоту.

   Программа использует  программируемый таймер персональной ЭВМ (порт
готовности - 67,  а порт загрузки  -  97).  Слово  FREQ  устанавливает
частоту  звукового сигнала.  В качестве исходного параметра FREQ берет
из стека коэффициент деления частоты  задающего  генератора.  Оператор
NOTA  задает частоту и длительность звука,  обращение:  T D NOTA,  где
T=1,2,3,...  - множитель,  задающий длительность сигнала; D - делитель
частоты,   определяющий   частоту  звучания.  Последовательно  задавая
частоту и длительность сигнала, можно воспроизвести нужную мелодию. По
завершении цикла воспроизведения необходимо выключить звук,  для этого
сбрасываются  в  нуль  два  младших  разряда  регистра,   управляющего
динамиком (порт 97).


                           8.4. ТЕЛЕИГРЫ


   Эффективность Форта  при  решении  графических задач предопределяет
широкое его использование при написании телеигр [5].  Это прежде всего
динамичные игры, где требуется скорость реакции. Событие в таких играх
происходит,  как правило,  на фоне статических  декораций  (лабиринты,
границы  площадок  и  полей,  иллюстративный  фон,  меню  и справочные
данные,  например счет и т.д.).  Эти декорации можно заменять частично
или полностью,  но делается это сравнительно редко. К другой категории
относятся подвижные объекты,  положение которых вычисляется программой
или  задается  игроком.  Причем результаты работы программы зависят от
сложившейся ситуации и предшествующих действий игрока  (или  игроков).
Поэтому  такие  телеигры  -  это  логические  интерактивные программы,
результат работы которых  отображается  в  виде  графических  образов.
Знакомство  с этим разделом полезно,  даже если читатель телеиграми не
интересуется,  так  как  сходные   проблемы   возникают   в   системах
автоматизации  проектирования,  в  тренажерах  (а  это  уже  настоящие
телеигры!),  а также в  системах  управления,  работающих  в  реальном
масштабе времени, где реакция и скорость отображения реальной ситуации
на экране должны быть максимально быстрыми (пульт  управления  атомной
электростанцией,   ускорителем   или  другой  аналогичной  установкой,
машинное моделирование сложных  процессов).  Одним  словом,  проблемы,
решаемые при создании телеигр, весьма серьезны.

   Условно программы для телеигр можно разделить на две части.  Первая
анализирует ситуацию,  воспринимает прерывания с клавиатуры,  игрового
манипулятора  или  "мыши",  рассчитывает  движение  объектов  с учетом
ограничений.  Вторая представляет ситуацию на экране кадр  за  кадром,
генерирует  звуковое сопровождение,  выдает сообщения (например,  счет
игры) и подсказки игроку. Решение второй задачи сильно зависит от типа
дисплея  ЭВМ  (алфавитно-цифровой  или  графический,  черно-белый  или
цветной,  имеется ли возможность полифонического звукового  синтеза  и
т.д.).    Характерной    особенностью    программ   телеигр   является
многозадачность  -  отображение  информации,  звуковое  сопровождение,
обработка  прерываний  и  расчет  новых  положений  объектов  ("мяча",
"врагов" или помех).

    Любой кадр содержит статическую составляющую,  на  воспроизведение
которой  время процессора и канала связи не занимается,  и переменную.
Последняя должна быть объектом особых забот, так как скорость обмена с
дисплеем невелика.

    Посмотрим, как  в  обобщенном  виде  выглядит  структура программы
телеигры:

      : TEST POSITION LIMITS-TEST ;
      : GO BEGIH LOOL_AT_LIST INPUT TEST CHANGES 0 UNTIL ;
      : GAME SET_START_STATUS GO ." GAME IS OVER " CR ;

   POSITION вычисляет положение объектов на игровом поле;

   TEST сверяет вычисленное положение объектов с игровой обстановкой и
в случае нарушения условий (LIMITS-TEST) прекращает игру;

   LOOK_AT_LIST выбирает  в   соответствии   с   положением   объектов
очередные условия из списка и отображает их на игровом поле;

   SET_START_STATUS задает и отображает начальные условия игры;
   INPUT ожидает  ввода  с терминала,  кодирует и засылает результат в
стек;

   CHANGES изменяет  обстановку  согласно алгоритму и в соответствии с
внешними воздействиями.

   Цикл GO бесконечный,  но если внутри оператора TEST будет выполнена
команда  R> DROP,  то по завершении процедуры ;S управление передается
не CHANGES, а оператору, следующему за GO в описании GAME.

   Рассмотрим, как это делается,  на примере  игры  "Шар  в  коробке".
Алгоритм  этой  задачи  является  основой многих игровых программ типа
"теннис",  "баскетбол",  "футбол", "сквош". Ниже приводится программа,
которая рассчитана на работу с дисплеем СМ7209:

   : $ VARIABLE ;   1 $ DY   1 $ DX    ( значения шагав по Y и X)
   : ESC 27 EMIT ;                 ( выдача кода ESC на терминал)
   : GRAF ESC 70 EMIT ;                   ( вход в псевдографику)
   : RC 13 EMIT ;          ( возврат каретки без перевода строки)
   : FIX RC '54433 PAD ! PAD 2+ ! PAD 4 TYPE !        ( Фиксация
                                               положения курсора)
   : LINE 80 0 DO DUP EMIT LOOP CR ;           ( рисование линии)
   : FRAME CRAP CR LINE 21 0 DO DUP EMIT 78 SPACES
     DUP EMIT CR LOOP LINE :                   ( рисование рамки)
   : CONTROL R# @ DUP 255 AND DUP 52 >   ( управление положением
				           курсора )
       IF DROP -1 DY ! RC  ( смена знака приращения, если курсор
			     достиг "дна")
       ELSE 34 <
          IF 1 DY ! RC THEN   ( смена приращения DY, если курсор
			        достиг "потолка")
       THEN 256 / DUP 109 >
       IF DROP -1 DX ! RC     ( смена приращения DX, если курсор
                                достиг правого края)
       ELSE 34 <
          IF 1 DX ! RC THEN       ( смена DX, если курсор достиг
			            левого края)
       THEN ;
   : SCL '20040 FIX ESC 74 EMIT ;    ( очистка [гашение] экрана)
   : NR ESC 71 EMIT ;       ( возвращение дисплея к нормальному
                              режиму )
   : STEP R# @       ( запись в стек текущей координаты курсора)
          FIX           ( установка курсора-шара в нужное место)
          SPACE                   ( гашение изображения курсора)
          DX @ 256 * DY @ + R# +! ( вычисление новой координаты
				    курсора)
	  R# @ FIX 97 EMIT        ( перемещение курсора в новое
			            положение и его отображение)
          CONTROL ;          ( контроль границ и смена знака DX
		               и/или DY)
   : TTT SCL '22043 R# ! '141 FRAME         ( отображение рамки)
          BEGIN STEP ?TERM '105 =       ( нажата клавиша <E> ? )
          UNTIL NR ;

   При реализации  алгоритма  на  персональной  ЭВМ  IBM  PC программа
несколько упрощается (так как  операторы  FIX  и  SCL  присутствуют  в
базовом словаре).

   Слово FRAME   рисует  рамку  размером  80x23  (рабочая  зона  78x21
знакомест),  GRAF переводит дисплей из  обычного  в  псевдографический
режим (NORM возвращает его в исходное состояние).

   Переменные DX  и  DY  хранят значения приращений по оси X и Y.  FIX
перемещает курсор в точку с заданными  координатами,  а  SCL  -  гасит
экран в начале игры.

   TTT производит  запуск игры и после подготовки входит в бесконечный
цикл шагов (STEP),  выход из которого возможен,  если нажать клавишу Е
(END).

   Положение курсора  задается  системной переменной R#,  используемой
для той же цели в экранном  редакторе.  Курсор  (шар)  перемещается  в
"коробке"  прямолинейно  (|/_\X|=|/_\Y|=  1),  при  достижении  стенки
коробки он отражается под прямым углом.

   Чтобы превратить эту программу в  реальную  игру  можно,  например,
ввести  две вертикально расположенные "ракетки" в правой и левой части
коробки,  перемещаемые вверх и вниз с помощью манипуляторов  или  двух
пар клавиш терминала.  Надо будет заставить "шар" отражаться не только
от стенок,  но и от "ракеток".  "Ракетка"  может  рассматриваться  как
фрагмент  стены  с  переменными  координатами.  Нажатие  той  или иной
клавиши может контролироваться так же,  как это делается для клавиши E
в  приведенном  тексте.  Разумеется,  это  лучше  делать  через прямой
"перехват" прерываний при нажатии соответствующих клавиш. При работе в
условиях  более  сложной  геометрии  (например,  лабиринты)  в  памяти
формируется двумерная таблица (см. описание игры "Жизнь"). Все объекты
перемещаются  из  ячейки  в  ячейку  этой  таблицы.  В  байтах таблицы
фиксируется,  что там находится ("игрок", "враг и его тип", "стенка" и
ее  свойства  и  т.д.).  Если объект по своим размерам не помещается в
одной ячейке на экране и  имеет  сложную  структуру,  тогда  отдельная
программа   отображает   этот   объект,  "привязав"  его  положение  к
координатам,  соответствующим положению оговоренной ячейки.  На основе
представленного текста,  дополнив его и усложнив, вы без труда сможете
создать широкий спектр игр.

   Игра "Жизнь",  предложенная  Дж.Конвеем,  заключается  в   описании
зарождения, жизни и смерти простых объектов согласно простым правилам.
"Среда  обитания"  объектов  -  прямоугольное  поле  из   mXn   клеток
(существуют и трехмерные версии игры).  Сам объект - это одна клетка в
таблице.  Если объект имеет двух или  трех  живых  соседей,  то  и  он
остается  живым  в  следующем поколении (на очередном кадре).  Объект,
имеющий 0,  1 или более 3 живых соседей,  умирает (в последнем  случае
из-за  "перенаселения").  Соседями  считаются  клетки,  имеющие друг с
другом хотя бы одну общую точку  границы.  Если  же  "мертвый"  объект
имеет трех живых соседей, то он "оживает". Вот и все правила. Остается
описать такую таблицу,  "заселить"  ее  и  наблюдать,  как  она  будет
эволюционировать.  Одна из Форт-реализаций игры "Жизнь" представлена в
[5].

   Чтобы описать  таблицу,  введем  оператор  TABLE,   который   может
пригодиться  и  для  других целей.  В сущности это упрощенный оператор
2ARRAY (см. табл.22).

   : TABLE <BUILDS                   ( задание имени таблицы)
           OVER ,         ( ввод в описание таблицы ее длины)
           * ALLOT    ( резервирование нужного объема памяти)
           DOES>     ( начало программы, работающей в режиме
                        исполнения для любой вновь описанной
                        таблицы)
	   DUP @         ( в стеке адрес начала таблицы и ее
		           длина в байтах)
	   ROT         ( перенос кода номера столбца на верх
		         стека)
           * + + 2+ ; ( вычисление адреса элемента таблицы с
                         заданными номерами столбца и строки)

   Обращение к  слову  TABLE производится,  например,  в форме:  NX NY
TABLE AREA,  где NX - длина строки;  NY - длина столбца;  AREA  -  имя
таблицы.  Обращение к AREA:  R C AREA,  где R - номер ряда;  C - номер
колонки.  По сравнению с 2ARRAY здесь нет проверки того,  что  элемент
находится  в  пределах  границ  таблицы.  Вы можете дополнить описание
TABLE таким контролем.  Для этого надо записать  в  список  параметров
число рядов,  введя между "," и "*" команду "DUP ," Программа проверки
должна быть встроена в текст после оператора DOES> (в описание TABLE).
Текст остальной программы представлен ниже:

   1001 VARIABLE RS ( заготовка для генератора случайных  чисел)
   40 CONSTANT DX               ( размер таблицы по горизонтали)
   8 CONSTANT DY                  ( размер таблицы по вертикали)
   DX DY TABLE AREA                     ( описание поля таблицы)
   : SHOW '20040 R#  !  DY 0    ( отображение таблицы на экране)
           DO DX 0                            ( цикл по строкам)
              DO                             ( цикл по столбцам)
                I J AREA C@        ( извлечение кода из таблицы)
                DUP 2 AND
                 IF DROP
                 ELSE R# @  I SWAB + FIX   ( фиксация положения
                                             курсора)
                    1 AND   ( проверка наличия "живого" объекта)
                    IF  '141 EMIT               ( отображение *)
                    ELSE SPACE  ( если в данном месте нет живого
                                  объекта)
                    THEN
                 THEN
              LOOP 1 R# +!     ( перевод указателя на следующий
                                 объект)
           LOOP ;
   : NORM DY 0 DO  DX 0
                   DO I J AREA DUP C@ DUP 128 AND
                      IF 1 XOR 1 AND ELSE 2 OR THEN
                      3 AND SWAP C!
                   LOOP
               LOOP  ;
    : TEST DY 0 DO DX 0     ( оператор для определения и пометки
                              "живых" и "мертвых" объектов)
                  DO 0 J 2+ DY MIN J 1- 0 MAX
                    DO J 2+ DX MIN J 1- 0 MAX
                      DO I J AREA C@        ( запись в стек кода
                                              объекта)
                         1 AND    ( выделение флага "жив/мертв")
                         +            ( подсчет "живых" соседей)
                      LOOP
                    LOOP DUP I J AREA DUP C@ 1 AND
                         IF ( если был "жив")
                           ROT 3 < ROT 4 -> OR        ( проверка
                                      условия выживания объекта)
                         IF DUP C@ 128 OR SWAP C!
                              (установка флагов в байте объекта)
                         ELSE DROP
                         THEN
                      ELSE                ( если объект "мертв")
                          SWAP 3 =
                          IF           ( если выполнено условие
                                         "воскрешения")
                             DUP C@ 128 OK SWAP C! DROP
                           ELSE 2 DROP
                           THEN
                       THEN
                 LOOP
               LOOP ;

   : RND RS @  2725 U* 13947  S->D  D+ DROP DUP RS ! 0 > ;
   : INIT DY 0 DO DX   0 DO RND I J AREA C! LOOP   LOOP   ;
   : LIFE GRAF INIT              ( заполнение таблицы с помощью
                                    генератора случайных  чисел)
          SHOW          ( отображение результата  заполнения на
                          экране)
          BEGIN                    ( начала бесконечного  цикла)
          TEST         ( проверка состояния объектов и  пометка
                         "живых" и "мертвых")
          SHOW NORM       ( коррекция таблицы с  использованием
                          меток,  расставленных оператором TEST)
          ?TERM 69 =             ( с терминала введена буква Е?)
          UNTIL NR ;        ( если нет, то продолжение цикла, в
                             противном случае прерывание работы)

   Функции операторов  GRAF,  NR,  ESC  и  FIX  описаны  выше.  RND  -
примитивный  генератор  случайных  чисел,  используемый  в   некоторых
библиотеках  FIG-FORTH  и  дополненный операторами,  которые позволяют
формировать "случайные" последовательности 0 и 1.  Переменные DX и  DY
задают размеры таблицы (40 колонок и 8 рядов). Оператор SHOW - хороший
пример использования слов I и J  для  вложенных  циклов.  Здесь  J  во
внутреннем цикле позволяет пользоваться индексом внешнего цикла.  '141
EMIT выдает в нужном месте экрана символ *,  если там  был  пробел,  в
противном   случае   туда  заносится  пробел.  Каждая  ячейка  таблицы
представляет собой байт,  младший бит которого указывает, "жив" объект
или   "мертв"   (1   соответствует   состоянию  "жив").  Следующий  по
старшинству бит используется для того,  чтобы указать,  изменилось  ли
состояние  объекта  по  сравнению  с  предшествующим  (1 соответствует
отсутствию изменения).  Дело в том,  что из соображений быстродействия
на  дисплей  передаются только изменения картинки,  а не вся картинка.
Старший бит байта =1 отмечает  тот  факт,  что  состояние  "жив/мертв"
данного  объекта  должно  быть  изменено.  После  определения "судьбы"
объекта  сразу  нельзя  изменять  его  состояние,  так  как   "старая"
информация  нужна  для  выяснения "будущего" других объектов (оператор
TEST). Если использовать две таблицы вместо одной, можно избежать этих
трудностей и заметно ускорить работу программы.

   Наблюдение за  эволюцией  таблицы  показывает,  что мало-помалу там
остается  только  два  вида  образований:  "маяки"   и   "стационарные
станции". Примером последней может служить группа вида

      ██ ██ , где у каждого объекта три "живых" соседа. Примером
"маяка" является группа

		     ███ --> ███
		     █ █     ███
		     ███ <-- ███

   Все элементы этого "кольца" имеют двух "живых" соседей, центральный
элемент будет попеременно появляться и исчезать.

   Упражнение 1.
   Пусть имеется  модуль  аналого-цифрового   преобразователя   (АЦП),
выполненного  в  стандарте КАМАК и установленного в станции 4 каркаса.
По команде F2 этот модуль посылает в ЭВМ 10-разрядный код,  полученный
в  результате  преобразования,  а  выходной регистр сбрасывает в нуль.
Предполагается,  что  КАМАК-интерфейс  имеет   структуру   управляющих
регистров,  описанную выше. По завершении преобразования модуль выдает
запрос обслуживания,  который вызывает прерывание.  Опишите  программу
HISTO,  которая  в  случае  прерывания считывает код из АЦП,  выбирает
элемент массива HI,  соответствующий этому коду,  и добавляет к числу,
лежащему в указанном элементе, 1. Массив HI описан с помощью команды 0
VARIABLE 2048 ALLOT.

   Р е ш е н и е.  Предположим,  в  CSR  интерфейса  ЭВМ  записан  код
команды КАМАК F2 (выполнена команда 2 CSR !),  а КАМАК-адрес АЦП имеет
форму константы с именем ADC (4 MODL ADC):


   : HISTO [[ 1 ADC   ( в стеке прерываний 1 и КАМАК-адрес АЦП)
           @           ( запись в стек кода, считанного из АЦП)
           HI +     ( вычисление адреса, номер которого должен
                      быть увеличен на 1)
           +! ]] ;

   Если требуется  контроль  считанного  кода,  оператор  HISTO  можно
видоизменить:

    40 CONSTANT PEDESTAL ( размер пьедестала) 900 CONSTANT TOP

    : HISTO [[ 1 ADC @ PEDESTAL - 0 MAX     ( если значение кода
                   меньше пьедестала событие заносится в 0-канал)
            TOP MIN   ( если код превышает значение TOP, событие
                        заносится в канал с номером TOP)
            HI + +! ]] ;

   Чтобы проверить наличие модуля в нужном месте, достаточно выполнить
команду TEST_P:

   : TEST_P ADC @ DROP CSR @ '100 AND 0=     ( проверка наличия
                                               отклика "X")
            IF ." NO "x"-response of MODULE" THEN  ;


   Упражнение 2.
   Напишите программу для вычерчивания окружности, эллипсов и дуг.

   Упражнение 3.
   Вспомните детство и нарисуйте домик.

   Упражнение 4.
   Если вы  хорошо рисуете,  попытайтесь нарисовать автопортрет,  если
плохо, то лицо человека, который вам наименее симпатичен.

   Упражнение 5.
   Используя в   качестве   основы  программу  "Подмосковные  вечера",
составьте программу для какой-либо другой мелодии.

   Упражнение 6.
   Попытайтесь переделать  программу  "Шар  в  коробке"  в  игру  типа
"теннис".  В простейшем случае для перемещения  "ракеток"  используйте
клавиши  [/\]  [\/]  для  одного  игрока и <Q> и <A> для другого.  Для
ускорения перемещений "мяча" перепишите основные процедуры,  используя
Форт-ассемблер.

