                  Глава 2. ОПЕРАЦИИ С ПАМЯТЬЮ

              2.1. ОПИСАНИЕ КОНСТАНТ И ПЕРЕМЕННЫХ



   В Форте  обычно  числа  хранятся  в  стеке,  но  иногда   возникает
потребность иметь константы или переменные, что традиционно для других
языков.  Для этого в Форте имеются два слова VARIABLE  (переменная)  и
CONSTANT (константа) (см. табл.23). Обращение к ним: m VARIABLE <NAME>
и n CONSTANT <name>,  где n и m  -  целочисленные  начальные  значения
переменной  и константы (начальное значение переменной при ее описании
задается не во всех версиях Форта). Введем переменную с именем REGOUT,
указывающую на адрес модуля КАМАК [42]:

      171 VARIABLE REGOUT

   Теперь в словаре появилось слово с именем REGOUT, и при обращении к
нему в стек будет записан адрес числа 171,  если,  конечно,  до  этого
обращения  значение  переменной не было изменено.  В некоторых версиях
Форта (например,  в Форт-83) начальное значение переменной  (в  данном
случае 171) не вводится.

   В Форте  можно  работать  с  символьными  и  абсолютными  адресами.
Примером символьного  адреса  может  служить  REGOUT.  Если  выполнить
команду  REGOUT  @  .  <ВК>  (оператор  @  замещает  адрес в стеке его
содержимым),  то ЭВМ выдаст 171 ОК.  Команда типа OCTAL 1000 @ .  <ВК>
132  OK  представляет  собой  случай  обращения по абсолютному адресу.
Опишем константу BASCAM,  которая указывает  на  начало  поля  адресов
КАМАК:

      OCTAL 164000 CONSTANT BASCAM

   При обращении  к  BASCAM  в  стек будет записано восьмеричное число
164000. Теперь напишем программу вычисления адреса КАМАК по известному
субадресу и номеру станции:

      : CAMADR 32 * SWAP 2 * + BASCAM + ;

   Предполагается, что  КАМАК-адрес  равен BASCAM + 32 * NST + 2 * SA.
Здесь NST - номер станции в каркасе КАМАК,  где размещен  блок,  адрес
которого вычисляется;  SA - субадрес объекта внутри этого блока. Такой
способ адресации пригоден только для ЭВМ,  где для  внешних  устройств
выделено определенное поле адресов. При работе с персональными ЭВМ эта
схема адресации неприемлема. Примером обращения к CAMADR может служить
команда  вычисления КАМАК- адреса модуля,  размещенного в станции 10 и
имеющего субадрес 1:

      1 10 CAMADR

   Результат вычисления будет помещен  в  стек.  Присвоим  этот  адрес
переменной  REGOUT.  Для  этого  достаточно  выдать  команды REGOUT !.
Оператор !  запишет число,  которое находится в стеке по адресу, также
расположенному  в стеке.  В нашем случае адрес в стек записал оператор
REGOUT.  Если мы хотим  посмотреть,  чему  равно  значение  переменной
REGOUT, надо выдать команду REGOUT @ . <ВК> или REGOUT ? <ВК>. Из этих
записей видно,  что оператор ? эквивалентен @. и может быть описан как
?  @.;.  По  команде "?" считывается содержимое ячейки,  адрес которой
находится в стеке,  и печатается на экране ее значение. Таким образом,
до  выполнения  команды  в  стеке  хранится  адрес,  после - ничего (в
таблицах "ничего" обозначается прочерком).

   Другой пример.  Для управления некоторым  внешним  по  отношению  к
КАМАК  устройством  надо  записать  в  выходной  регистр  станции  2 с
субадресом 0 восьмеричный код 15.  Решением  может  служить  следующая
программа:

      OCTAL
      0 2 CAMADR REGOUT! 15 REGOUT @ !

   Может возникнуть вопрос:  почему в первом случае мы пишем REGOUT !,
а  во втором - REGOUT @!  ?  (большие пробелы перед знаками препинания
местами вводятся для того,  чтобы их нельзя было спутать с операторами
Форта  ".",  "?",  "!"  или  ",").  В  первом случае переменной REGOUT
присваивается значение КАМАК-адреса,  во втором - производится  запись
по  этому  адресу.  Если запись производится многократно,  команда 0 2
CAMADR  REGOUT  !  должна  быть  выполнена  только  раз  при   запуске
управляющей программы.

   Иногда абсолютная  адресация  используется  при  работе  с внешними
устройствами или при обращении к системным переменным типа JSW в RT-11
(0  44  !).  При  работе  с  абсолютными  адресами  следует  проявлять
определенную осторожность: в некоторых версиях Форта команда 40 1001 !
вызовет прерывание (обращение по нечетному адресу).

   Операторы C@   (извлечь  байт)  и  C!  (записать  байт)  -  аналоги
операторов @ и !  (табл.  3),  но выполняются для  байтов,  а  не  для
16-разрядных чисел, т.е. извлекаются из ячейки и записываются в нее не
числа, а байты.

Таблица 3. Операторы для работы с памятью
----------------------------------------------------------------------
Имя        Состояние стека          Версия     Функция
----------------------------------------------------------------------
@          адр --> n                9, 3, F   Замещает адрес в стеке
                                              его содержимым

C@         адр --> -                9, 3, F   Извлекает байт
					      информации из ячейки,
					      адрес которой находится
                                              в стеке

!          n адр --> -               9, 3, F  Записывает число n в
					      ячейку с адресом "адр"

C!         b адр --> -               9, 3, F  Записывает байт b по
					      адресу, указанному в
					      стеке.

+!         n адр --> -               9, 3, F  Добавляет к содержимому
					      ячейки с адресом "адр"
					      число n

,(запятая) n --> -                   9, 3, F  Копирует число n в
					      первую свободную ячейку
					      словаря

C,         b --> -                   9, 3,    Копирует байт b в
					      очередной свободный байт
					      словаря

ALLOT      n --> -                   9, 3, F  Добавляет n байтов к
					      полю параметров слова,
					      описанного последним

FILL       адр n b --> -             9, 3, F  Записывает n байт b в
					      память начиная с адреса
					      "адр"

ERASE      адр n --> -               9, 3, F  Записывает n 0-байтов в
					      память начиная с адреса
					      "адр"

BLANKS     адр n --> -               F        Записывает n кодов
					      "пробел"

BLANK                                9, 3, M  (32) в память начиная с
					      адреса "адр"

Примечание - стандарт Форт-79; 3 - стандарт Форт-83; F - FIGFORTH- M -
             MMSFORTH.
----------------------------------------------------------------------

   Оператор +!   (плюс-присвоить)   добавляет   16-разрядное  число  к
содержимому ячейки,  адрес которой  (ADR)  хранится  в  стеке.  Формат
обращения  N ADR +!.  До исполнения команды в стеке находятся N и ADR,
после ничего (табл. 3).

   Приращения содержимого ячейки может быть как положительным,  так  и
отрицательным, например по команде -5 ADR +! к значению переменной ADR
добавится -5.  Хотя оператор +!  относится к числу примитивов  базовые
словаря,  тем не менее даже его можно описать, используя уже известные
слова:

   : +!                                ( в стеке n ADR       )
       DUP                             (         n ADR ADR   )
       @      ( запись в стек содержимого адреса n ADR (ADR) )
       ROT                             (         ADR (ADR) n )
       +                            ( приращение ADR (ADR)+n )
       SWAP                           (          (ADR)+n ADR )
       ! ;   ( запись результата по адресу, хранящемуся стеке)

где n - константа,  которая добавляется к содержимому ячейки по адресу
ADR.  ADR  может  быть  записан  в  стек  при  обращении к переменной,
например REGOUT.

   Следует подчеркнуть различие между  переменной  и  константой.  При
появлении   в   списке   исполняемых  слов  имени  переменной  в  стек
записывается ее адрес,  а в случае константы  -  значение.  Существует
несколько    способов    описания    переменных    и   констант.   Это
продемонстрировано в таблице на примере числа 8:


----------------------------------------------------------------------
Описание              Текст в словаре                    Состояние
                                                         стека
----------------------------------------------------------------------
:88;                  201   270  LINK   CALL   LIT, 8*       8
8 CONSTANT 8          201   270  LINK   CONST       8*       8
8 VARIABLE 8          201   270  LINK   VAR         8*      PFA
----------
* Записано в PFA.
----------------------------------------------------------------------

   Малопонятные на данном этапе письмена в центральной  части  таблицы
оставьте  пока  без  внимания.  Числа  во  второй  и  третьей колонках
восьмеричные. Все три описания в первой колонке запишут число 8 в одну
из ячеек памяти. Но доступ к этой информации и израсходованные ресурсы
(память и время) будут разными. Первый способ самый неэкономный как по
памяти,  так  и по скорости извлечения нужного значения в стек.  Самый
экономный  -  второй  (число  8  описано  как  константа).  В   случае
переменной  (третий  вариант)  при  обращении к 8 в стек будет записан
адрес 8, а не само значение. Для получения требуемого значения в стеке
следует  написать  и  исполнить 8 @.  Первое описание может показаться
несколько сюрреалистическим, но парадокс заключается в том, что именно
так чаще всего описываются константы в программе.

   Пусть слово   INCH   преобразует   длину  в  дюймах  (число  дюймов
предполагается целым) в длину в  миллиметрах  и  выдает  результат  на
экран:

      : INCH 254 10 */ .;


   Обращение: 10 INCH даст 254 ОК.  Здесь  числа  записаны  в  стек  и
извлекаются  по  первому способу.  Именно это послужило причиной того,
что числа  1,  2,  3  (иногда  и  некоторые  другие)  описываются  как
константы  в  базовом словаре.  Таким образом,  если в вашей программе
какое-либо число  встречается  часто,  а  вам  небезразлична  скорость
исполнения программы,  опишите это число как константу. Например, 1024
CONSTANT 1К или 1024 CONSTANT 1024.  В последнем случае имя  константы
1024.


              2.2. УПРАВЛЕНИЕ СИСТЕМОЙ СЧИСЛЕНИЯ


   Среда переменных,   определенных   в  системе  Форт,  особое  место
занимает  BASE,  задающая  основание  системы   счисления.   В   Форте
определены  три  оператора,  управляющие системой счисления и задающие
десятичную,  шестнадцатеричную и восьмеричную системы:  DECIMAL, HEX и
OCTAL. Описания этих слов весьма просты (табл. 8):


               : DECIMAL 10 BASE ! ;

               : HEX     16 BASE ! ;

               : OCTAL    8 BASE ! ;


   Переменная BASE  используется при вводе и выводе чисел на экран или
печать.  В  процессе  работы  система  счисления   может   многократно
изменяться,  поэтому  в  какой-то  момент  времени  вы можете с трудом
интерпретировать результат из-за  неуверенности  относительно  текущей
системы  счисления.  Как  же  можно  оперативно  определить  основание
системы счисления?  Первое,  что приходит в голову, это BASE @ . Ответ
очевиден:  10 ОК.  Но что означает 10? Ведь такой результат мы получим
при любой системе счисления. Правильный ответ может дать процедура:

      : BAS? BASE @ DUP DECIMAL . BASE ! ;

которая отпечатает основание системы счисления в десятичном виде и при
этом  оставит  переменную  BASE в том состоянии,  которое она имела до
проверки.  (Читателю,  желающему испытать  себя,  предлагаем  написать
программу,   которая   будет  поименно  называть  действующую  систему
счисления  (DECIMAL,  OCTAL  или  HEX).  Для  этого,   правда,   нужно
познакомиться с главами, где описаны операторы условия и операторы для
работы с текстовыми строками.)

   Рассмотрим простейший   способ   описания   массивов.   Для   этого
используется  оператор  VARIABLE  в  сочетании с ALLOT.  Например,  по
команде 0 VARIABLE AA 126 ALLOT будет описан массив с именем AA длиной
128  байт.  Причем  первые  два  байта  на  стадии  описания  нулевые,
содержимое остальных пока не определено.  Оператор N ALLOT резервирует
в словаре N байт,  N для ЭВМ типа ДВК или СМ должно быть четным, а для
персональных ЭВМ ЕС 1841 - любым.  Возможна и комбинация,  когда число
байт в массиве вычисляется в процессе выполнения программы:

      0 VARIABLE LL
      ........
      16 16 * LL!
      .........
      0 VARIABLE ВВ LL @ ALLOT

   В данном  примере  длина  массива ВВ равна 258 (LL = 256),  так как
команда 0 VARIABLE ВВ уже зарезервировала два байта для  значения  ВВ.
Если  попытаетесь переопределить длину массива ВВ с помощью 0 VARIABLE
ВВ LL @ ALLOT,  в словаре появится новый массив с тем же именем ВВ,  а
доступ  к старому станет невозможным (во всяком случае через обращение
ВВ).  После того как массив описан,  с ним можно  работать.  Например,
записать  число  5  в  ячейку 12 массива ВВ (нумерация начинается с 0)
можно с помощью команды 5 ВВ 12 2 * + !  (использовано умножение на 2,
так как запись производится в ячейку 12, а не в байт.)

   Для переноса массивов из одной области памяти в другую используются
операторы CMOVE,  MOVE (перенести) и <CMOVE (в Форт-83 CMOVE>). Первый
есть  во всех версиях,  служит для переноса последовательности байтов,
второй - слов, и поэтому он быстрее, а третий начинает перенос с конца
массива.  Форма обращения для всех трех операторов одна и та же:  ADR1
ADR2 N CMOVE, где ADR1 - адрес первого байта массива-источника; ADR2 -
адрес  первого  байта массива-адресата;  N - число пересылаемых байтов
(или слов в случае MOVE). Все эти три числа должны быть в стеке, после
выполнения команды они удаляются из стека.  Все три параметра переноса
могут быть заданы символьно или абсолютно:

      0 VARIABLE A 12 ALLOT
      0 VARIABLE В 120 ALLOT
      .......
      A В 12 CMOVE
      A В 12 + 12 CMOVE

   В обоих вариантах перенос байтов происходит из массива A  в  массив
В.  Последний  перенос  записывает  массив  A,  начиная  с 12-го байта
массива В.  В обоих случаях N = 12.  Для данных массивов 1<=N<=14.  Но
если  N>14,  предсказать,  что  будет  передано в массив В после 14-го
байта,  весьма трудно.  Никаких сообщений вы не получите,  последствия
могут  быть  катастрофическими.  Возможна  команда типа 1500 2500 1000
CMOVE,  которая перешлет 1000 байт из области памяти,  начинающуюся  с
адреса  1500,  в  область,  начинающуюся  с  адреса 2500.  Но лучше не
злоупотреблять абсолютной адресацией:  это слишком опасное упражнение,
тем более,  что, пользуясь абсолютной адресацией, нужно знать, с какой
страницей или сегментом памяти вы имеете дело.

   Оператор MOVE перемещает всегда четное число байт,  но  делает  это
почти  в  2  раза быстрее,  чем CMOVE.  Оператор <CMOVE служит главным
образом  для  переноса  перекрывающихся  массивов  или  для  раздвижки
массива  и  освобождения места для нового элемента.  При переносе байт
между перекрывающимися массивами надо тщательно выбирать тот или  иной
оператор    пересылки    (осмотрительность    -   важная   добродетель
программиста).

   Имеется ряд операторов для заполнения массивов  памяти  идентичными
символами.   Универсальным   оператором  такого  типа  является  FILL.
Обращение к нему:  ADR N sym FILL,  где  ADR  -  адрес  первого  байта
памяти,  куда будет засылаться код символа sym;  N - число заполняемых
байтов, например

      DECIMAL 0 VARIABLE AAA 128 ALLOT
      AAA 130 65 FILL или AAA 130 ASCII A FILL

   Слово ASCII выводит в стек код ASCII (см. ч.II, гл.7) следующего за
оператором символа, но этот оператор имеется не во всех версиях Форта.
Описанная  процедура заполняет все 130 байт массива AAA кодами символа
A.

   Здесь уместно сказать о кодировании буквенных  символов.  Латинские
буквы  обычно  кодируются  в  соответствии  с  американским стандартом
ASCII,  буквы русского алфавита  по-разному.  Отчасти  это  связано  с
многообразием   периферийной   аппаратуры,   отчасти  с  особенностями
операционных систем.  В версиях Форта,  с которыми  пришлось  работать
автору, использовалось два способа. В первом переключение с латинского
на русский алфавит выполнялось кодом ^N,  а обратно кодом ^O  (дисплей
"Электроника ИЭ-15",  OC RT-11, см. приложение 5), во втором (он более
распространен) - коды  русских  букв  отличаются  от  кодов  латинских
наличием 1 в старшем бите байта (ЭВМ IBM PC, OC MS-DOS). Этим вариации
не  исчерпываются,  так  как  существует   несколько   разных   таблиц
соответствия   латинского   и   русского   алфавитов   для  клавиатур,
многовариантен и вывод на печатающее устройство,  но  это  уже  другая
тема.   Пример  таблицы  кодов  смотри  в  гл.5.  Важно,  что  имеется
возможность создать командный язык, состоящий только из русских слов.

   Для обнуления  массивов  предусмотрен  оператор  ERASE   (стереть),
который является, по существу, частным случаем слова FILL (заполнить).
Обращение:  ADR N ERASE.  Значения параметров те же,  что и для  FILL.
Описание ERASE имеет вид:

      : ERASE 0 FILL;

   Напишем AAA 130 ERASE,  и описанный выше массив будет обнулен.  При
работе с массивами символов (строками) аналогичную  функцию  выполняет
команда  ADR N BLANKS (заполнить пробелами),  которая выполняет массив
байтов кодами пробела (32 в десятичной  системе  счисления).  Описание
BLANKS имеет вид:


      : BLANKS BL FILL;

где BL - системная константа, равная 32.

   Существует два близких  родственника  оператора  ALLOT  -  это  ","
(записать в словарь код) и "C," (записать в словарь байт). Запишем:

      '40530 VARIABLE HA '55C, '130C, '101C

где "C," записывает число в очередной свободный байт словаря. Апостроф
перед  числом  указывает  интерпретатору,  что  его  следует   считать
восьмеричным вне зависимости от действующей системы счисления; "+" или
"-" перед числом означает,  что  оно  записано  в  десятичной  системе
счисления (FIG). Если теперь выдать команду HA 5 TYPE <ВК>, то получим
XA =/= XA ОК.

   Функция оператора ",",  та же,  что и "C,",  но для чисел,  активно
используется в процессе интерпретации (например,  при реализации слова
COMPILE) для записи последовательности кодов в словарь Форта.

   Упражнение 1.
   Опишите оператор с именем KBDB для вычисления квадратного трехчлена
Ax^ + Bx + C,  где A, В и C- константы, равные 7, 8 и 1, а х - число в
стеке.  Результат  должен  появиться  на  экране  сразу  после нажатия
клавиши <ВК>.

   Решение.

      7 CONSTANT A   8 CONSTANT В   1 CONSTANT C
      : KBDB DUP A * B + * C + . ;

   Упражнение 2.
   Напишите программу для расчета определителя элементами а,  а+1, а+2
и а + 3, а = 2.

   Решение.

      2 CONSTANT CONST               ( значение а)
      CONST DUP VARIABLE D2 DUP 1+ , DUP 2+ , 3 + ,

      D2 - имя массива матрицы

      : DET2 D2 @ D2 6 + @ *     ( перемножение элементов основной
			           диагонали)
             D2 2+ @ D2 4 + @ * -;

   Эта задача не из числа практических:  результат равен -2 при  любых
значениях CONST.  Оператор, пригодный для произвольного массива, имеет
вид

      : DE2 DUP @ OVER 6 + @ * OVER 2+ @ ROT 4 + @ * -;


   При обращении  D2 DE2 .  <ВК> будет -2 ОК.  Разумеется,  при другом
содержимом матрицы D2 результат будет иным.
