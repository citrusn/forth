                       Глава 7. ИНТЕРПРЕТАЦИЯ

                7. 1 . ЗАГРУЗКА ПРОГРАММЫ В СЛОВАРЬ


   При загрузке  системы Форт первой исполняется программа COLD (INI),
которая  очищает  все  буферы,  устанавливает  в  исходное   состояние
указатели  стеков  возврата и параметров,  формирует указатель области
USER,  загружает векторы прерывания  (если  требуется)  и  присваивает
некоторым системным переменным (S0,  R0,  TIB,  WIDTH, WARNING, DP), а
также указателям начала и конца экранных  буферов  (версия  FIG-FORTH)
рабочие   значения.   Последнее  открывает  возможность  динамического
перераспределения памяти  и  приспособления  имеющейся  у  вас  версии
интерпретатора  к  конфигурации ЭВМ.  Программа может быть исполнена и
непосредственно из системы Форт.

   Программу COLD условно можно разбить на две части: первая от начала
до   завершения   записи   системных   переменных  и  остальная  часть
(называемая иногда WARM [14]),  служащая для загрузки переменных USER,
векторов  прерывания и других вспомогательных операторов.  В некоторых
версиях Форта имеется слово WARM,  которое  передает  управление  этой
части программы.

   После выполнения    стартовых   операций   производится   установка
десятичной системы счисления,  а словарь  Форта  делается  контекстным
(выдается  команда  FORTH  DEFINITIONS).  Весьма  полезным завершением
программы COLD (INI)  является  уход  на  загрузку  некоторого  экрана
(например,  экрана 1),  где записана программа стартовой загрузки. Эта
программа может варьироваться с помощью редактора и подстраиваться под
текущие   требования   конкретной  задачи.  Это  может  быть  загрузка
редактора.  Форт-ассемблера или каких-либо других библиотек.  Если для
стартовой  загрузки  одного  экрана  мало,  в  конце  экрана 1 следует
написать М  LOAD,  где  М  -  номер  экрана,  содержащего  продолжение
программы стартовой загрузки.

   Команда LOAD  (см.  табл.8)  используется  при  загрузке  не только
системы  Форт,  но  и  любых  библиотек  или  программ   пользователя.
Рассмотрим, как она работает:

   : LOAD BLK @ IN @    ( в стеке номер загружаемого экрана N,
                           старые значения переменных BLK и IN)
          0 IN !        ( обнуление указателя экранного буфера)
          ROT                            ( в стеке BLK, IN, N )
          BLK !                      ( BLK=N, в стеке BLK, IN )
          INTERPRET    ( загрузка и интерпретация текста блока
                        с номером BLK слово за словом)
          IN !           ( восстановление прежнего значения IN)
          BLK ! ;       ( восстановление прежнего значения BLK)

   Таким образом,  если  при  загрузке  экрана  i встретится команда j
LOAD,  то производится интерпретация экрана j, а затем загрузка экрана
i продолжится.  Если команда j LOAD выдана в пультовом режиме (BLK=0),
то после загрузки система Форт вернется в пультовой режим.

   LOAD является основной командой загрузки операторов в словарь.  Так
как загружаемый экран N интерпретируется,  то все описания типа :  NNN
XXX  ;,  CONSTANT  и  VARIABLE  загружаются   в   словарь,   остальные
воспринимаются  как программы непосредственного исполнения.  Это можно
использовать для  присвоения  нужных  значений  системным  переменным,
записи векторов прерывания и задания режима работы системы. В качестве
примера ниже представлена программа стартового загрузчика, размещенная
на экране 1:

   DECIMAL TTY ( сброс флага печати) CURRENT @ CONTEXT ! [
   : PNX 2+ DUP @ ;
   : CNTX CONTEXT @ ;
   : USAV DUP               ( чтение с диска и запись в словарь
			        двоичного образа секции словаря)
	  IF 6 0     ( загрузка последовательности из 6 экранов)
             DO DUP BLOCK   ( чтение в буфер содержимого экрана)
             DUP @ SWAP PNX
             SWAP PNX R# !                  ( распаковка данных)
             PNX DP !          (установка нового указателя HERE)
             PNX CONTEXT @ !              ( установка контекста)
             2+ ROT ROT CMOVE    ( перенос информации из буфера
                                   в словарь)
             R# @ 0=          ( проверка условия конца загрузки)
             IF LEAVE
             THEN 1+
          LOOP
       THEN DROP;

   Первая строка   исполняется   непосредственно,   остальная    часть
загружается в словарь.

   Могут оказаться  полезными  и  специальные  сообщения,  введенные в
текст  экранов,  например  типа  SCR#  N,  позволяющие  контролировать
процесс загрузки, команды ." Е"." D"." I"." T"." О"." R" (или ." E" ."
D"."."."." и т.д.),  помещенные в начале  текстов  экранов  редактора.
Первая  из  команд  записывается  на  экране 1 редактора,  вторая - на
экране 2, соответственно шестая на экране 6. По завершении загрузки на
экране  появится  надпись  EDITOR.  При сбое по последней напечатанной
букве легко определить, где он произошел.

   Более эффективным средством может стать специальный  оператор  GDE,
который работает с модифицированным оператором LOAD:

      : GDE ."S#=" PREV @ @ . R# @ 64 /. "LINE=".;

распечатывая номера экрана и строки,  где имела место ошибка. Оператор
CDE должен быть выполнен сразу после появления сообщения об ошибке.

   Частичное или полное удаление загруженной части словаря возможно  с
помощью оператора FORGET (забыть):

   : FORGET CURRENT @ CONTEXT @ - '30 ?ERROR         ( проверка
                      соответствия переменных CURRENT и CONTEXT)
            [COMPILE] ' ( определение PFA слова, следующего за
			  FORGET)
	    DUP FENCE @ U< ( проверка того, что указанное слово
                             хранится за пределами базового
                             словаря. FENCE указывает верхний
                             край базового словаря)

            '25 ?ERROR       ( сообщение об ошибке, если слово
			         оказалось в защищенной области)
            DUP NFA       ( определение адреса поля имени слова)
            DP !                     ( изменение указателя HERE)
            LFA @            ( указание на предшествующее слово)
            CONTEXT @ ! ;        ( изменение переменной CONTEXT)

   Обращение: FORGET <NAME>,  где <NAME> - имя оператора в загруженной
части словаря.

   Оператор U< применен вместо "<",  так как  адреса  FENCE  @  и  PFA
<NAME>   могут   оказаться   по  разную  сторону  от  32  Кбайт,  т.е.
восприниматься как числа разных знаков.  Для ЭВМ с  памятью  более  64
Кбайт   эта   часть  оператора  должна  быть  усложнена:  надо  учесть
содержимое сегментных регистров для каждого из адресов. При исполнении
FORGET  удаляются  все  слова  начиная  с  указанного  вплоть до конца
словаря (CONTEXT @ @).


                   7.2. ИНТЕРПРЕТАЦИЯ ПРОГРАММЫ


   В режиме "покоя" система Форт ожидает ввода,  это делается в рамках
исполнения процедуры QUIT.  Все, что вводится с терминала, поступает в
кольцевой буфер (см.  рис.1),  откуда коды извлекаются  словом  QUERY,
которое  является частью QUIT и,  в свою очередь,  пользуется услугами
оператора EXPECT.  Последний осуществляет выборку из кольцевого буфера
с помощью слова KEY. После завершения ввода строки при нажатии клавиши
<ВК> строка окажется во входном Форт-буфере TIB. Управление передается
оператору   INTERPRET   (табл.24),  который  и  выполняет  последующую
обработку введенного текста.

Таблица 24. Управляющие операторы
----------------------------------------------------------------------
Имя             Состояние   Версия           Функция
                  стека
----------------------------------------------------------------------
CONSTANT XXX      n --> -   9, 3, F  Формируя константу с именем XXX,
             XXX:                    равную n. При обращении к XXX в
                  - --> n            стек записывается число n

VARIABLE XXX      n --> -   9, 3, F  Формирует переменную с именем XXX,
             XXX:                    равную n. При обращении к XXX в
                  - --> адр          стек записывается адрес n

CREATE   XXX      - --> -    9, 3, F  Формирует слово с именем XXX
             XXX:                    (заголовок и CFA). При обращении
                  - --> адр          к XXX в стек записывается его
                                     адрес

INTERPRET         - --> -   F        Интерпретирует последовательность
				     слов до тех пор, пока там что-то
                                     есть

WORD              s --> -   9, 3, F  Считывает одно слово из входного
                  (s --> адр)        или экранного буфера и размещает
                                     его начиная с адреса HERE. Первый
                                     байт содержит число символов в
                                     слове

EXECUTE           адр --> - 9, 3, F  Исполняет слово, CFA которого
				     хранится в стеке

[                 - --> -   9, 3, F  Устанавливает режим компиляции
		  (I)
]                 - --> -   9, 3, F  Устанавливает ражим исполнения

Примечание. I - слово немедленного исполнения; 9 и 3 - стандарты
            Форт-79 и Форт-8З, F - FIG-FORTH.
----------------------------------------------------------------------

   Интерпретация производится последовательно слово за словом (слово -
это последовательность символов, завершаемая кодом пробела или нулем).
Из  входного  или  экранного  буфера (что определяется переменной BLK)
слово  переносится  в  конец  словаря,  на  адрес  которого  указывает
оператор  HERE.  Введенное  слово  имеет вид k XXXXXXX,  где k - число
символов в слове; XXXXXXX - символы, образующие слово. Далее поведение
программы  зависит от того,  в каком режиме она находится - исполнения
или интерпретации.  Если  это  режим  исполнения  и  слово  в  словаре
найдено,   осуществляется   переход  к  исполнению  команд  (EXECUTE),
содержащихся в его описании. Если это режим интерпретации, то в случае
обнаружения  имени  вновь описанного слова в словаре,  ЭВМ предупредит
программиста об этом (MSG# 4 для FIG-FORTH), но тем не менее приступит
к   его   описанию   (COMPILE).  Могут  происходить  непредусмотренные
совпадения имен, если максимальная длина имен выбрана малой (системная
переменная WIDTH) и символы,  лежащие за этой границей, отбрасываются.
Эта работа  проделывается  в  некоторых  интерпретаторах  помимо  воли
программиста и без оповещения его об этом.  Поэтому нежелательно WIDTH
<  15,  обычно  WIDTH  приблизительно  =  30.  Вышеуказанные  операции
производятся словом CREATE,  которое, кроме того, формирует поле связи
с предшествующим описанием (LFA),  а также поле команды (CFA) Описание
слова приобретает форму, которая описана в гл.6 ч.1.

   Если в  тексте  описания  встретится имя слова,  которого в словаре
нет,  интерпретатор попытается его воспринять как число и при неуспехе
выдаст сообщение об ошибке (MSG# 0 b FIG-FORTH).

   Переключение системы   Форт   в  режим  интерпретации  производится
оператором ":", который можно описать следующим образом (на самом деле
это  ненастоящее  описание,  так  как  описать  слово  ":",  используя
оператор ":", нельзя):

   : :                              ( второе ":" - имя слова)
        ?EXEC    ( система в режиме исполнения? Если нет, то
		   сообщение об ошибке)
	CSP ! CURRENT @ CONTEXT !        ( CONTEXT = CURRENT)
        CREATE       ( формирует имя нового слова и поле LFA)
        ]                          ( вход в режим компиляции)
        (;CODE) ; IMMEDIATE          ( формирование поля CPA)

   Обычно по  окончании  описания  оператора  ":"   в   интерпретаторе
размещена программа DOCOL [14] (или $COL),  адрес которой записывается
в CFA любого слова,  описание которого начинается с ":".  Оператор ":"
является словом немедленного исполнения.

   Выход из режима интерпретации осуществляет оператор ";":

   : ; ?CSP COMPILE ;S    ( завершает описание слова, записав в
                            PFA нового слова ссылки на оператор ;S)
       SMUDGE [ ; IMMEDIATE

   (Здесь справедливо  замечание,  высказанное  выше  к описанию ":".)
Если оператора ";" нет, будет выдано сообщение об ошибке.

   Операторы CSP! и ?CSP в ":" и ";" контролируют сохранение указателя
стека параметров в процессе интерпретации слова;  SMUDGE (SMUG) делает
новое слово узнаваемым при очередных поисках  в  словаре.  Оператор  [
переключает систему в режим исполнения и обнуляет системную переменную
STATE.  ] присваивает  этой  системной  переменной  значение  '300  (в
некоторых   версиях   другое   число)  и  переводит  систему  в  режим
интерпретации.

   Другим важным оператором является уже упомянутый CREATE:

   : CREATE -FIND                      ( поиск слова в словаре)
            IF                              ( если оно найдено)
               DROP NFA      ( запись адреса поля имени в стек)
               ID.                              ( печать имени)
               4 MESSAGE                     ( печать "MSG# 4")
           THEN HERE DUP C@     ( запись в стек числа символов
				  в слове)
	   WIDTH @   ( максимально допустимое число символов в
		       в имени )
	   MIN            ( укорочение имени, если оно слишком
			    длинное)
	   1+ ALLOT             ( выделение нужного числа байт)
           ?ALLIGH    ( выравнивание выделенного числа байт на
                        четную границу, что важно для ЭВМ типа
			СМ)
           DUP '240 TOGGLE             ( коррекция байта имени)
           HERE 1- '200 TOGGLE    ( коррекция последнего байта
				    имени)
	   LATEST ,                    ( Формирование поля LFA)
           CURRENT @ !            ( коррекция значения CURRENT)
           HERE 2+ , ;                   ( заполнение поля CFA)

   Поле команды CFA переписывается при  исполнении  (;CODE),  например
при  работе  оператора  ":",  CONSTANT  или VARIABLE.  Оператор TOGGLE
служит для приведения к соответствующему  виду  первого  и  последнего
байтов имени вновь описываемого оператора.  При обращении ADR b TOGGLE
извлекается байт из ячейки с адресом  ADR,  выполняется  операция  XOR
(Исключающее ИЛИ) над этим байтом и байтом b, а результат записывается
снова в ячейку с адресом ADR.

   В заключение рассмотрим алгоритм самого оператора INTERPRET:

   : INTERPRET BEGIN              ( начало бесконечного цикла)
            -FIND          ( поиск очередного имени в словаре)
               IF                        ( если слово найдено)
                 STATE @ <      ( в стеке байт длины, STATE ;
			    проверяется, не является ли слово
                           оператором немедленного исполнения)
                  IF                     ( если обычное слово)
                   CFA ,        ( запись CFA найденного слова
                                  в новое описание)
		  ELSE   ( если слово немедленного исполнения)
                       CFA EXECUTE    ( исполнение найденного
                                        слова)
                  THEN
               ELSE     ( если слово на найдено, поверяется -
                          может быть это число ?)
		    HERE NUMBER DPL @ 1+   ( преобразование
                       последовательности кодов ASCII в число)
                 IF                ( если число двойной длины)
                    DLITERAL ( запись последовательности "LIT,
                                число" в описана нового слова)
                 ELSE DROP LITERAL  ( запись в описании числа
                                      одинарной длины)
                 THEN
               THEN
               ?STACK             ( указатель стека в норме ?)
               0 UNTIL ;

                      ┌─────╨─────┐     ┌───────┐
                      │    Диск   │────>│ блок #│
                      └─────╥─────┘     └───┬───┘
                                            │
                                           \│/
		                    ┌────────────────┐
		                     \    BUFFER    /
		               ┌┐      \ ──────── /
               ╔═══════════════││ \┌────┴────────┴─────┐  O═o═══o
               ║  ╔════════════││ │                    ├┐ ║ ║┌─┐║
               ║  ║  ╔═════════││ │  I N T E R P R E T │╞═O ║└╥┘║
               ║  ║  ║  ╔══════││ │                    ├┘   ╠─╨─╣
               ║  ║  ║  ║ ╔════││ /└──┬────────────┬───┘    │   │
            ┌──╨──╨──╨──╨─╨──┐ └┘     │ FORTH & Co │        └╥─╥┘
             \  DICTIONARY  /       ┌─┴────────────┴─┐       ║ ║
       ───────┴────────────┴────────┴────────────────┴──────═╩─╩═──


   Как же  программа после завершения интерпретации может уйти в режим
ожидания   ввода?   Это   осуществляется   при   интерпретации   слова
немедленного  исполнения  с  нулем  в  поле имени.  Для этого оператор
EXPECT пишет два нулевых байта  в  конце  строки  во  входном  буфере,
аналогичные   нули   имеются   в   конце   экранных  буферов.  Поэтому
интерпретатор рано или поздно встретит это слово. Уход из бесконечного
цикла здесь происходит с помощью R> DROP и процедуры ;S.

   Определенный интерес представляет собой оператор COMPILE, который в
режиме компиляции вводит исполнительный адрес следующего за ним  слова
в компилируемое описание:

      : COMPILE ?COMP I R> 2+ >R @ , ;

   Примером использования  оператора  COMPILE  может  служить описание
оператора ASCII,  который в режиме компиляции  записывает  в  описание
слова  команду  записи  в стек кода символа,  следующего за оператором
ASCII, а при исполнении записывает этот код в стек:

   : ASCII BL WORD        ( выделение слова, следующего за оператором
                            ASCII)
           HERE 1+ C@            ( запись в стек кода первого символа
                                   этого слова)
           STATE @ IF                         ( если режим компиляции)
                     COMPILE LIT ,                ( запись в описание
                  исполнительного адреса оператора LIT и кода символа)
		   THEN ; IMMEDIATE

   Ниже приведен  пример  использования  оператора  ASCII.  Слово TEST
будет отображать бесконечную последовательность букв  A  до  тех  пор,
пока вы не нажмете клавишу E:

      : TEST BEGIN ASCII A EMIT ?TERM ASCII E = UNTIL ;

   Для программистов,  которые заняты прикладными задачами,  структура
интерпретатора - тема достаточно  абстрактная  и  скучная.  Транслятор
представляется  им весьма сложной программой,  что до какой-то степени
справедливо,  когда речь идя о  современных  трансляторах  для  языков
высокого   уровня.  Теоретически  можно  создать  интерпретатор  Форт,
который  займет  всего  несколько  сотен  байт  [23].   Как   правило.
Форт-интерпретатор  можно  разделить  на  три  части.  Первая содержит
тексты примитивов,  реализующих наиболее часто  используемые  операции
(+, -, *, /, >, < и т.д.). Эти примитивы организованы в соответствии с
требованиями словаря Форта и  написаны  на  Ассемблере.  Вторая  часть
служит  для  описания  процедур  уже  в рамках идеологии Форта.  Здесь
описание   слов   имеет   форму   интерпретируемых    Форт-операторов,
использующих ссылки на примитивы.  Эти описания легко смоделировать на
Форте.  Третья часть интерпретатора  содержит  программы,  управляющие
вводом-выводом.  Обычно  Форт-интерпретатор  имея модульную структуру,
которая диктуется структурой словаря.  Модульность позволяет добавлять
новые   базовые  процедуры  в  интерпретатор.  Если  вы  имеете  текст
интерпретатора и знаете,  как  устроен  словарь,  то  написание  новой
процедуры  (или примитива) не составит труда.  Дополнительное удобство
создает возможность предварительного моделирования процедуры на Форте.
В  данной  книге приведено немало текстов операторов базового словаря,
которые можно рассматривать как описания-модели.

   Если вы  столкнулись  с  проблемой  написания  интерпретатора   для
процессора,  не имеющего трансляторов для языков высокого уровня, Форт
будет   самым   подходящим   языком.   Опытный   программист   напишет
Форт-интерпретатор  месяца  за  два.  Сначала  пишутся  и отлаживаются
примитивы,  затем процедуры ввода-вывода и наконец все  остальное.  На
этой  последней фазе уже можно моделировать операторы на Форте.  Текст
Форт-интерпретатора для IBM PC приведен в приложении 9.



           7.3. ВЗАИМОДЕЙСТВИЕ С ОПЕРАЦИОННОЙ СИСТЕМОЙ


   Хотя Форт  имеет  много  черт  операционной системы (ОС) и даже при
определенных  условиях  может  функционировать  автономно,  обычно  он
использует   ОС   ЭВМ,   на  которой  работает.  Взаимодействие  с  ОС
начинается,  когда программист вводит с клавиатуры  команды  RU  FORTH
(или просто FORTH). Уже на этом этапе разные ОС требуют разных команд.
Более  серьезные  отличия  проявляются  при  работе  с   периферийными
устройствами,  в частности с дисками.  СССР - страна стандартов,  их у
нас так много,  что почти на каждой ЭВМ свой стандарт записи. Поэтому,
если к вам попала дискета с нужной вам программой, выясните сначала ее
"происхождение",  если стандарты несовместимы, попытайтесь получить ее
копию  на  магнитной  ленте.  Репертуар  стандартов для магнитных лент
заметно беднее,  и здесь больше шансов на успех.  Форт не относится  к
числу   распространенных   языков,   и  в  силу  этого,  вероятно,  вы
столкнетесь с проблемой использования программ,  написанных на  других
языках, например Фортране, Паскале, Ассемблере.

   Специфика Форта  накладывает некоторые ограничения на возможности и
способ реализации связи  с  этими  программами.  Существует  несколько
методов  решения  этой  задачи.  Один  из  вариантов  -  использование
вспомогательной программы XLINK,  написанной на Ассемблере и связанной
с  Фортом  с  помощью редактора связей (LINK).  Эта программа содержит
обращения к  интересующим  нас  программам.  При  изменении  имен  или
количества  таких программ достаточно изменить соответствующие команды
вызова в программе XLINK и повторно воспользоваться редактором связей.
Программа,  к  которой  планируется обращение из системы Форт,  должна
быть представлена в виде объектного модуля.  При обращении к редактору
связей  в  список  модулей  кроме FORTH следует включить XLINK и имена
программ, к которым обращается XLINK.

   В примере,  представленном ниже,  осуществлена  возможность  вызова
двух  подпрограмм,  написанных  на MACRO-11.  Форма обращения к ним из
системы Форт: n VLINK K + AWAY, где n - число параметров подпрограммы,
хранящихся  в  стеке  и  удаляемых  оттуда  программой  XLINK;  AWAY -
оператор,  обеспечивающий  сохранение  содержимого  регистров   общего
назначения  и  передачу  управления  внешней программе;  K - константа
переадресации,  при обращении к первой из подпрограмм  (TTT)  K=0,  ко
второй  (TTM)  K=16.  Для  удобства  записи  программы полезно описать
константы TTT и TTM, равные соответственно 0 и 16:

      DECIMAL 0 CONSTANT TTT 16 CONSTANT TTM

тогда вызовы программ TTT и TTM будут иметь форму

      0 VLINK TTT+AWAY и 0 VLINK TTM+AWAY

   Если обращений  к  внешним   программам   много,   полезно   ввести
вспомогательные слова TTT и TTM:

      :TTT OVLINK AWAY; и :TTM OVLINK 16+AWAY;

   0 после  имен  соответствует  числу параметров,  необходимых данным
внешним подпрограммам.  Теперь  для  обращения  к  этим  подпрограммам
достаточно   написать   TTT  или  TTM.  Имена  TTT  и  TTM  могут  уже
использоваться  в  новых  словах  как  элементы   списка   исполняемых
процедур, например

      : HOW AREYOU 0= IF TTT ELSE TTM THEN ;

   Ниже приведен  упрощенный  текст  программы  XLINK,  написанный  на
MACRO-11:

              .TITLE XLINK
              .MCALL .PRINT
              .GOBL TTT,TTM
              .MACRO NEXT
              MOV  (SP)+        R4
              MOV  (R4)+        R2
              MOV  (SP)+        R5
              MOV  (R5)+        R1
	      ADD  R1,          R5     ; "очистка стека"
              JMP  @(R2)+              ;  возврат в Форт
              .ENDM
        XLINK::    JSR PC, TTT         ;обращение к TTT
                   NEXT
                   JSR PC, TTM         ;обращение к TTM
                   NEXT
              .END

   Если Форт   может  воспользоваться  чужой  программой  относительно
легко,  то обратная возможность проблематична.  Обычная Форт-программа
неразрывна со словарем,  собственно она является его частью, в которой
описано,  к  каким  словам  и  в  какой   последовательности   следует
обратиться. Дерево этих ссылок завершается примитивами, написанными на
Ассемблере.   Такая   структура   программы   практически    исключает
возможность   использования  ее  программами,  написанными  на  других
языках.  Имеются способы преодолеть этот барьер.  Первый  шаг  в  этом
направлении  позволяют  делать  программы,  которые удаляют из словаря
имена слов и поля связи (а также описания, ссылки на которые в словаре
отсутствуют). Такой словарь уже не может пополняться. Программа в этом
виде компактнее,  но еще недоступна для программ,  написанных на чужом
языке.

   Существуют программы   [35],   которые,  используя  дерево  ссылок,
формируют новую программу, состоящую только из обращений к примитивам.
В   результате   получается,  как  правило,  еще  более  компактная  и
быстродействующая   программа.   Если   в    программе-преобразователе
следовать  определенным правилам,  то можно будет получить программные
модули,  доступные для использования наряду с другими,  написанными на
любом   из  языков,  поддерживаемых  действующей  ОС.  Преодолев  этот
недостаток,   мы   получим   продукт,   который   уже   не    является
Форт-программой,  и  вместе с тем лишимся и всех преимуществ Форта.  В
этом  отношении  несколько  особняком  стоят  программы,  составленные
исключительно  на  Форт-ассемблере,  так  как их текст включает только
машинные команды.

   Когда компактность  и  быстродействие  являются   определяющими   и
планируется   длительная   эксплуатация   программы   без   каких-либо
модификаций,  описанные выше  преобразования  программ  представляются
разумными.  Более того, в процессе преобразования могут быть применены
алгоритмы оптимизации,  которые сделают уже отлаженную  программу  еще
эффективнее.


               7.4. ДЕКОМПИЛЯТОР ДЛЯ СЛОВАРЯ ФОРТА


   Нельзя сказать,  что  декомпиляторы  были  самые нужные инструменты
программиста.  Однако  время  от  времени  возникает  ситуация,  когда
необходимо  разобраться,  как  работает  то  или  иное  слово базового
словаря или библиотеки,  загружаемой  в  оттранслированном  (двоичном)
виде.

   Из-за многообразия форм описаний (примитивы, переменные, константы,
массивы,  структуры ":  NNN  ...";  и  т.д.)  создание  универсального
декомпилятора  довольно сложная проблема.  Возможности Форта и на этом
поприще продемонстрированы  в  приложении  9  на  примере  простейшего
декомпилятора  с  именем  DECOD,  который  ориентирован  в основном на
декомпиляцию структур типа :  NNN ...  ;. Много ли вы знаете примеров,
когда декомпилятор занимает несколько строк? Стиль, в котором написана
эта программа,  нельзя назвать хорошим,  но она написана и отлажена за
пару  часов.  Форма  обращения к оператору:  DECOD XXX,  где XXX - имя
слова в загруженной части словаря,  структура которого вас интересует.
Декомпилятор    -   эффективное   средство   диагностики   повреждений
загруженной части словаря.

   Если вы  попытаетесь декомпилировать переменную,  константу или еще
что-то  отличное  от  структуры  ":  NNN  ...  ;  DECOD  назовет   это
примитивом.  В  качестве  упражнения  вы можете усовершенствовать этот
декомпилятор и научить его распознавать переменные и константы.



         7.5. ЗАПИСЬ НА ДИСК ЧАСТЕЙ СЛОВАРЯ В ДВОИЧНЫХ КОДАХ


   Загрузка любой библиотеки складывается из чтения экранов с диска  в
буферы,  интерпретации  содержимого буфера и пополнения словаря.  Этот
процесс  можно  ускорить,  если  исключить  интерпретацию,  которая  в
некоторых  случаях  может  занимать 50%  общего времени загрузки.  Для
этого нужная часть словаря  записывается  на  диск  в  двоичных  кодах
(двоичный образ),  чтобы при необходимости можно было быстро загрузить
ее в память. Для записи части словаря (EDT) на диск служит программа

   32 VARIABLE BAN 53 , 53 , 54 , 55 , 56 , 57 , 60 , 61 , 62 ,
    63 , 64 , 65 , 66 , 67 , 68 , 79 ,    ( "запретный" список)
    40 LOAD                           ( загрузка редактора EDT)
    : CNK                       ( сверка с "запретным" списком)
	  1 BAN 2+ DUP BAN @ + SWAP
           DO OVER I @ =
             IF LEAVE DROP
		." S# " . ." ? " 0       ( если экран в списке)
             THEN 2
          +LOOP ;
   : LIST CHK IF LIST THEN ;          : LOAD CHK IF LOAD THEN ;
   : EDT  CHK IF EDT  THEN ;          : L@      R# @ 1014 MIN ;
   : NXP  OVER ! 2+ ;
   : SVE                        ( запись части словаря на диск)
	  CURRENT @ CNTX - 24 ?ER
	  [COMPILE] '              ( запись в стек PFA слова с
				     именем <NAME>)
	  NFA                  ( замена PFA на NFA этого слова)
          HERE  ( запись в стек адреса первой свободной ячейки
		  словаря)
	  OVER                     ( в стеке N, NFA, HERE, NFA)
          - DUP           ( в стеке N, NFA, HERE-NFA, HERE-NFA)
          DUP 6100 >      ( контроль размера сохраняемой части
			    словаря)
	  IF ." SO MUGH ? " 2DROP        ( если лимит превышен,
					   задача игнорируется)
          ELSE R# ! 0         ( запись размера части словаря в
				ячейку R#)
	    DO                  ( начало цикла, в стеке N, NFA)
               DUP 3 PICK             ( в стеке N, NFA, NFA, N)
               BLOCK      ( резервирование блок-буфера, запись
			    в стек его адреса)
               2DUP !       ( запись NFA в первое слово буфера)
               2+ L$    ( вычисление числа переносимых в буфер
			  байт =K)
               >R R NXP
	       L$ MINUS R# +!    ( из содержимого R# вычтено К)
               R# @ NXP         ( запись длины остатка массива
				  в следующий адрес буфера)
               HERE NXP     ( запись значения HERE в очередной
			      адрес буфера)
	       CONTEXT @ @ NXP    ( запись контекстного адреса
				     в следующую ячейку буфера)
	       R CMOVE          ( запись части словаря в буфер)
               UPDATE             ( установка флага "спасения")
               SWAP 1+ SWAP R + R>
            +LOOP
          THEN FLUSH ;           ( запись всех буферов на диск)
   : SAVE 64 SVE ;
   ( 64 USAV CR FORGET L$ ." EDT IS HERE"       1 WARNIRG ! ;S)


                          ╔═══════════════╗
                          ║ Базовая часть ║
                          ║    словаря    ║
         Диск             ║               ║
    ╔═══════════╗ SAVE    ╟───────────────╢ <-слово k────┐
    ║  Экран S3 ╟───<─────╢               ║              │
    ║           ╟───>─────╢    Зона 3     ║              │
    ╚═══════════╝ USAVE   ║               ║              │
    ╔═══════════╗         ╟───────────────╢ <-слово j    │
    ║  Экран S2 ╟───<─────╢               ║              │SAVE
    ║           ╟───>─────╢    Зона 2     ║              ├───┐
    ╚═══════════╝         ║               ║              │   │
    ╔═══════════╗         ╟───────────────╢ <-слово i    │   │
    ║  Экран S1 ╟───<─────╢               ║              │   │
    ║           ╟───>─────╢    Зона 1     ║              │   │
    ╚═══════════╝         ║               ║ <-CONTEXT @ @│   V
                          ╚═══════╤═══════╝ ─────────────┘   │
          ┌─────────>─────────────┘         <-HERE           │
          │                     Диск                         │
    ╔═════╧═════╗           ╔═══════════╗    ╔═══════════╗   │
    ║    Ln     ║ ─ ─ ─ ─ ─ ║    L2     ╟────╢     L1    ╟───┘
    ╚═══════════╝           ╚═══════════╝    ╚═══════════╝
    |<──────────────── Серия экранов ───────────────────>|


   Рис. 8. Схема сохранения и восстановления двоичных секций словаря

   Следует иметь  в виду,  что считываемая в такой форме с диска часть
словаря может быть добавлена только к тому  же  словарю,  от  которого
была  отделена.  Схема  сохранения-восстановления словаря приведена на
рис.8.

   Процедура S1 SAVE  <Слово  i>  записывает  на  диск  часть  словаря
начиная  со  слова  <Слово  i>  и  до конца словаря.  Здесь S1 - номер
экрана,  начиная с  которого  происходит  запись.  Последнее  слово  в
словаре начинается с ячейки,  на которую указывает CONTEXT @ @,  адрес
первой свободной ячейки в словаре определяется словом HERE. Записанная
часть  словаря может быть удалена из словаря с помощью операции FORGET
<Слово i>. Это будет работать, если слово i не лежит в запретной зоне,
заданной системной переменной FENCE.  Процедуру записи можно повторить
для слова с именем <Слово j> .  На  экране  S2  будет  сохранена  зона
словаря 2. Далее аналогичная операция может быть проделана для зоны 3.
Восстановление словаря выполняется в обратном порядке.

   Пусть на экране S3 (на самом деле это  может  быть  серия  экранов)
записан  редактор,  на  экране  S2 - Форт-ассемблер,  а на-экране S1 -
рабочая  библиотека.  Теперь,  если   нужно   только   редактирование,
восстанавливаем   зону   словаря   3   с   экрана  S3.  При  работе  с
Форт-ассемблером восстанавливаем зоны 3 и 2,  а если нужна  и  рабочая
библиотека,  то  зоны  3,  2  и  1.  Нельзя  восстановить  зону 1,  не
восстановив 3 и 2,  или зону 2,  не восстановив зону  3.  Попытка  это
сделать   обязательно   приведет   к  сбою  системы,  поэтому  полезно
защититься от такой возможности программно.  После загрузки  двоичного
образа  какой-либо  библиотеки  можно  обычным  путем  с  помощью LOAD
дополнить словарь недостающими операторами. По команде L1 SAVE Слово k
на  диске  сформируется  оттранслированный образ словаря со слова k до
HERE (серия экранов в нижней части рис.8).

   Чтобы исключить ошибки  при  попытках  чтения,  редактирования  или
загрузки  экранов,  содержащих двоичные образы секций словаря,  заново
переопределены слова LIST,  LOAD и  EDT.  Список  "запретных"  экранов
описан в массиве BAN и включает также экраны,  где хранится автономная
версия Форта, имеющая чисто двоичную форму.

   При записи секции словаря (редактора EDT,  как в  приведенном  выше
примере) секция программы, ответственная за восстановление этой секции
в словаре, должна быть закомментирована (в примере с EDT это последняя
строка  программы).  После загрузки системы Форт и указанной программы
выдается команда SAVE BAN,  и редактор в двоичных кодах будет  записан
на серии экранов начиная с 64. После этого с помощью редактора следует
закомментировать всю приведенную программу,  кроме  последней  строки,
которая  и  будет  использоваться  для  чтения  секции  и  записи ее в
словарь.  Оператор USAV описан на экране стартовой загрузки (экран 1).
Теперь  после  загрузки  системы  Форт  достаточно дать команду 3 LOAD
(приведенная программа записана на экране 3),  и редактор будет быстро
загружен.

   Оператор CNK проверяет, нет ли данного экрана в "запретном" списке,
и,  если есть,  выдается отклик в виде S# N ?, и команда LOAD, EDT или
LIST   игнорируется.   Ошибочные   обращения   к  "запретным"  экранам
происходят,  когда  оператор  забывает,  в  какой  системе   счисления
работает,  и,  например,  пытается отредактировать экран 70, работая с
восьмеричной системой счисления.

   При желании можно  написать  программу,  которая  будет  записывать
нужные секции словаря в отдельные файлы.

   При работе  с  SAVE/USAV  нужно  помнить,  что,  если операция SAVE
проведена сразу  после  загрузки  системы  Форт,  то  и  USAV  следует
использовать  в  тех  же условиях.  Если вы не уверены,  что состояние
словаря отвечает  этим  требованиям,  выполните  команду  COLD  (INI),
которая вернет словарь к базовому состоянию.


                   7.6. ВЫПОЛНЕНИЕ ПРОГРАММЫ


   В языках  типа Фортрана или Паскаля процедура исполнения начинается
обычно  с  загрузки  в  память  подготовленной  программы   с   диска.
Подготовка  включает  трансляцию  исходного  текста  и  редактирование
связей.  В интерпретаторах типа Бейсик  отдельные  фрагменты  или  вся
программа сначала преобразуются в машинные коды, после чего начинается
ее исполнение.  В Форте  исполнима  только  программа,  загруженная  в
словарь.  Элементы словаря можно условно разделить на примитивы, где в
поле параметров  записана  последовательность  машинных  кодов,  и  на
описания  типа  двоеточия,  в  поле параметров которых список процедур
(CFA),  подлежащих  исполнению.  Особый   класс   Форт-слов   образуют
переменные,  константы,  массивы,  исполнительные  векторы,  слова без
заголовков и т.д.,  часть из которых не нашла отражения в этой  книге.
Если  система  находится  в  режиме  исполнения (STATE=0) и во входном
потоке (входной или экранный буфер) встретилось слово с именем  <NNN>,
процедура  его  исполнения  начинается с поиска имени <NNN> в словаре.
При  успешном  завершении  поиска  в  стек  записывается   CFA   слова
(Форт-79),  после  чего  управление  передается оператору EXECUTE (см.
описание слова INTERPRET в  7.2),  который и  исполнит  слово  <NNN>.
Если  слово  является примитивом,  в его CFA (поле программы) хранится
адрес PFA (т.е.  CFA+2),  куда и передает управление оператор EXECUTE.
Исполнение  любого  примитива завершается процедурой NEXT (см.  гл.5),
которая  передает  управление  следующему  слову.  Теперь   рассмотрим
исполнение слов типа двоеточия.

   В поле CFA записан адрес исполнительной программы (DOCOL или $COL),
которая подготавливает исполнение списка процедур,  хранящегося в поле
параметров  описания.  Эта  программа может служить примером слова без
заголовка.  Описание типа двоеточия завершается ссылкой на  слово  ;S,
которое  является  примитивом  и засылает адрес следующей процедуры из
стека возвратов в счетчик инструкций (IP).  Если в описании содержатся
ссылки  только  на  примитивы,  переход  от исполнения предшествующего
слова к последующему происходит через процедуру NEXT,  которая в  этом
случае  является  единственным  источником  непроизводительных  потерь
времени.  При наличии в списке слов типа двоеточия в работу включаются
также  процедуры типа DOCOL и потери времени возрастают.  Наличие этих
связующих программ - отличительная особенность Форта,  с  помощью  них
цепочка  примитивов  базового словаря образует программу,  реализующую
задание,  описанное в слове  программы  пользователя.  Именно  поэтому
Форт-программы называют иногда "шитыми" (или цепными) кодами.

   Комплект программ   DOCOL,   NEXT   и   др.   образует   внутренний
Форт-интерпретатор, работающий в режиме исполнения программы. Функцией
внешнего интерпретатора является синтаксический разбор входного потока
и компиляция.  При исполнении программы внешний интерпретатор передает
управление внутреннему.  По завершении исполнения система возвращается
в состояние ожидания (QUIT).


                  7.7. ОТЛАДКА ФОРТ-ПРОГРАММ


   Отладка программы на любом языке - процесс  весьма  индивидуальный,
сильно зависящий от вкусов, опыта и традиций. Форт с его особенностями
ставит  программиста  в  определенные  рамки.  К  таким   ограничениям
относится   максимальное   число  символов  (64)  в  экранной  строке,
отсутствие в тексте  программы  кодов  "Возврат  каретки"  и  "Перевод
строки".  На первый взгляд,  это не столь важное ограничение. Но нужно
принимать  во  внимание,  что,  стремясь  к  экономному  использованию
дискового  пространства,  программист будет стараться заполнять строку
на экране.  А это неизбежно приведет к ухудшению читаемости программы,
усложнит поиск нужного описания.

   Все знают,  что  комментарии  -  неотъемлемая  часть программы.  Но
всегда ли мы следуем разумному  правилу:  комментировать  программу  в
процессе   ее   написания?   В   Форте   комментированию  препятствует
ограниченный объем экрана - 1024 символа,  включая пробелы.  Ведь  чем
больше  объем  комментариев,  тем  меньше  "видимый"  на экране текст.
Именно это и стало причиной введения  в  некоторых  реализациях  Форта
"теневых"  экранов с комментариями к текстам на "основных" экранах.  В
такой ситуации можно порекомендовать следующее.

   При отладке не жалеть  места  для  комментариев.  Имена  всех  слов
должны максимально отвечать функции слова,  в рабочей версии они могут
быть условными (хотя последнее и небесспорно).  В  какой-то  мере  это
будет   способствовать  защите  авторских  прав,  ведь  разобраться  в
программе с условными именами и без комментариев крайне сложно, а люди
хотя  и  любопытны,  но  ленивы.  Предлагаемая  методика  предполагает
дополнительную переработку отлаженной  программы  (например,  удаление
комментариев). Эту работу можно поручить специальной программе. Другой
путь - хранение отлаженной программы на диске в виде двоичного  образа
секции  словаря или полная переработка текста с удалением имен,  ячеек
связи.  Но в любом случае лучше оставить  программу  с  комментариями,
пожертвовав  местом  на  диске,  чем  написать,  отладить  и  оставить
программу без комментариев. Через год вы будете смотреть на нее как на
чужую,  и  любая  переделка займет больше времени,  чем самые обширные
комментарии.  Это ни в коем случае  не  относится  к  именам  базового
словаря. Держать в памяти имена операторов, функция которых неочевидна
из  названия,  весьма  обременительно.  Даже  имена  таких  операторов
базового  словаря,  как  @  и  !,  могут  вызвать неудовольствие,  что
проявилось  в  их  замене  в  системе  GRAFORTH  на  PEEKW   и   POKEW
соответственно.

   Основным инструментом   при   отладке   программы  является  печать
промежуточных результатов,  состояния стека и содержимого переменных и
массивов в процессе тестовых прогонов. Так как в Форте возможны ссылки
только на слова,  описанные и загруженные в словарь,  именно эти слова
должны  отлаживаться  первыми.  Только  после отладки слов-компонентов
следует приступать к проверке операторов, куда эти слова входят.

   Следует избегать слишком  длинных  описаний.  Каждое  слово  должно
выполнять    определенную    функцию.    Причем   имя   слова   должно
соответствовать   этой   функции.   Функционально   сложные   описания
целесообразно  разбивать  на  части  (по крайней мере при отладке).  В
длинном описании можно временно исключать некоторые  секции,  заключив
их в скобки (т.е. превратив их на время в комментарий).

   Для распечатки  стека  следует  использовать  команды  S.  или  O.,
которые  не  изменяют  его  состояния.  Оператор  O.,  идентичный  S.,
представляет  числа  в  восьмеричном виде,  оставляя основание системы
счисления неизменным:

      : S.DUP U.; или : S.DUP.:
      : О.BASE @ OCTAL S. BASE !;

   Напомним, для  положительных  чисел  оператор U.  эквивалентен ".",
т.е.  он удаляет число  из  стека  и  отображает  его  на  экране.  Но
отрицательные числа U. распечатывает иначе, например

      DECIMAL -5 U.<BK> 65531 OK
                        ----- --
      OCTAL -5 U.< ВК> 17777З ОК
                       ------ --

U. рассматривает старший бит кода как обычный двоичный,  а не как знак
числа.  Это  целесообразно  при  распечатке частей словаря,  программ,
управляющих кодов и т.д.  Когда  для  наглядности  удобно  осуществить
двоичное   представление   чисел   на   экране   (или  печати),  можно
воспользоваться оператором В в виде

      : В.BASE @ 2 BASE ! OVER U. BASE ! ;

   Например: DECIMAL 15 В. < BK> 1111 OK.
                                 ---- --

   Чтобы распечатать   второе   сверху  число,  можно  воспользоваться
командой OVER .  или OVER U. . Для распечатки чисел, положение которых
в  стеке  произвольно,  подходит  команда k PICK U.,  которая также не
изменяет состояния стека (k - номер позиции в стеке начиная сверху).

   Для контроля состояния стека в различных точках  программы  полезен
оператор  DEPTH,  который  выдает  в  стек  полное  количество  чисел,
хранящихся в стеке до исполнения этой команды.  Для  распечатки  всего
содержимого стека пригодно слово STY,  оставляющее стек без изменений.
Первое выдаваемое число соответствует верху стека. Если в вашей версии
Форта нет слов DEPTH и STY, вы можете их описать сами:

      : DEPTH SO @ SP @ 2+ -2/;

   SO - системная переменная, равная базовому значению указателя стека
параметров:

   : STY DEPTH -DUP         ( определение глубины заполнения стека)
	 IF 0
	     DO I 8 MOD 0=                  ( подготовка табуляции)
                IF CR  ( ввод возврата каретки для того, чтобы при
                        большой глубине заполнения стека результат
                        имел вид таблицы по 8 чисел в строке)
                THEN I 1+ PICK 7 U.R
	     LOOP
          THEN ;

   При DEPTH=0 STY ничего не печатает.

   Другим полезным  при  отладке  словом  может  стать  PRS,   которое
распечатывает n верхних слов стека без модификации указателя:

   : PRS DEPTH MIN    ( защита от перехода через нижнюю границу
			стека)
         -DUP
         IF ( если не 0) 0
	    DO I 1+ PICK U.            ( печать числа без знака)
	    LOOP
         THEN ;

   Это слово  лучше  использовать,  когда  стек  загружен  на  большую
глубину и его полная распечатка нецелесообразна.  А  что  будет,  если
стек пуст,  а вы выдали команду .  <ВК>?  Ничего страшного, ЭВМ выдаст
сообщение типа STACK EMPTY или MSG#  1.  При  переполнении  стека  ЭВМ
выдаст  сообщение  STACK  OVERFLOW  или  MSG#  2.  Если такая ситуация
сложится  в  процессе  выполнения  программы,   возможны   повреждения
словаря, а выполнение программы в любом случае будет прервано.

   При работе  с массивами чисел Форт не контролирует переход через их
границы,  что,  конечно,  может вызвать большие неприятности,  так как
возможны повреждения словаря.  В Форте, как впрочем и во многих других
языках,  забота о границах массивов лежит  на  программисте.  И,  если
указатель элемента массива вычисляется, полезно проверять результат на
соответствие границам массива,  во всяком случае  при  отладке.  Такая
проверка  может  быть встроена в описание самого массива.  Важно также
иметь в виду,  что некоторые версии Форта не контролируют переполнение
при  арифметических  операциях.  Если  есть опасность переполнения при
нормальной работе программы,  используйте  числа  двойной  длины.  При
повреждении словаря возможны разнообразные последствия. На ЭВМ типа СМ
это  могут  быть  прерывания  с  попаданием  в  ловушку  (TRAP)  из-за
недопустимого  адреса  или  команды.  В  случае попадания в ловушку на
экране появится сообщение TRAP-ERROR m N1 N2, где m - код ловушки (M=4
означает  неверный  адрес,  а  m=10  - недопустимую команду);  N1 = PC
(программный счетчик) и N2 = PS (регистр состояния).  При попадании  в
ловушку,  если  "повреждения"  не  слишком  велики,  можно  попытаться
выполнить команду COLD (INI). Подумайте, почему это могло произойти, и
проверьте  вашу  гипотезу.  В  случае  серьезных "разрушений" придется
перезагрузить систему с  диска  или  даже  воспользоваться  копией  на
другом диске, предварительно изготовив еще одну. Особенно внимательным
надо быть при отладке программ,  производящих запись на диск. Следует,
например,  помнить,  что  последовательность  "K  BUFFER  ...  UPDATE"
приведет к записи на экран K и  утрате  прежних  записей.  Копирование
экранов также стирает экран-адресат. Поэтому при отладке всегда имейте
копию программы на отдельном диске.  Причем при работе  с  ОС  полезно
иметь  под  рукой  и  ее  копию,  так как ошибкам свойственно наносить
максимально большой  урон.  Доступность  из  системы  Форт  абсолютных
адресов  создает  не  только  определенные  удобства,  но  и серьезные
трудности.  Неправильно вычисленный адрес присваивания может повредить
словарь  или какой-либо элемент ОС,  хранящийся в памяти.  Копия файла
FORTH.DAT  крайне  необходима  при  редактировании  текста  редактора.
Почему  бы  не  внести какой-то новый редактирующий оператор,  если вы
считаете,  что так вам  будет  удобнее  работать?  Но  если  совершена
ошибка,  а старой копии не сохранилось,  то у вас не останется средств
внести исправления,  ведь редактор с ошибкой вряд ли будет работать. В
этом   случае  хорошей  альтернативой  может  быть  "двоичная"  версия
редактора,  загружаемая оператором USAV. При редактировании совершенно
нового  (пустого) экрана,  где никогда не было текстов Форта,  полезно
сначала выполнить команду WIPE, так как на экране могут присутствовать
"невидимые"  (не  имеющие печатного образа) символы,  которые способны
сбивать работу интерпретатора.

   Очистить экран (здесь имеется в виду буфер на диске)  можно,  и  не
входя в редактор, для этой цели пригоден оператор SCLR:


   : SCRL ." S# S. ." CLEAR ? <Y/CR> "           ( входной диалог)
          KEY '131 =                      ( нажата клавиша "Y" ? )
          IF BUFFER                       ( резервирование буфера)
             1K BLANKS                           ( очистка буфера)
             UPDATE FLUSH   ( установка флага "спасения" и запись
                              на диск)
          THEN ;

   На команду N SCLR ЭВМ сначала выдаст запрос

      S# N  CLEAR  ?  <Y/CR>,
      -- -  -----  -

где N - номер экрана, подлежащего очистке (заполнению кодами пробела),
а после получения подтверждения <Y> выполнит эту команду.  SCLR  может
помочь,  если  данный экран не читается из-за ошибки по четности,  так
как SCLR записывает данные  на  диск,  не  читая  старого  содержимого
экрана.

   Особый класс  ошибок  составляют  конфликты из-за основания системы
счисления.  Так,  попытка  исполнить  команду  OCTAL   287   .   будет
интерпретатором пресечена:  в восьмеричной системе счисления число 287
не   имеет   смысла.   Аналогичные   проблемы   могут   возникнуть   с
шестнадцатеричной системой.  Определенную гарантию могут дать признаки
системы счисления  "+",  "-"  и  "'",  их  можно  использовать  и  для
преобразования  чисел  из  одной  системы  в  другую.  Так,  если надо
преобразовать серию десятичных чисел в восьмеричные, достаточно выдать
команду OCTAL,  а далее печатать с пульта числа со знаком "+" или "-".

   Например:

      OCTAL +18 . < ВК>  22 OK - 17 . <ВК> -21 0К +64 . <ВК> 100 OK
                         -- --              -- --            --- --
   и т.д.

   Если требуется восьмерично-десятичное преобразование, то можно
воспользоваться командами

      DECIMAL '20 .  <ВК> 16 0К'200 . <ВК> 128 ОК.
                          -- --            --- --

   В версиях,  где признаков счисления нет,  можно описать специальные
слова, например

      : DH NEC . DECIMAL ;

преобразует число    из   десятичной   системы   (она   предполагается
действующей) в шестнадцатеричную:

      15 DH <ВК> F OK и 17 DH <ВК> 11 OK.
                 - --              -- --
   Рассмотрим пример   ввода   отладочных   распечаток   в   программу
упорядочения элементов массива, имеющего имя AR и длину 66 байт:

   0 VARIABLE AR 64 ALLOT
   : FILLING 64 0 DO 64 I - AR I + C! LOOP ;
   : ORDER BEGIN 0 R# ! 64 0
                  DO AR I ." I=" S. + C@ ." A=" S.
                     AR I + 1+ C@ ." B=" S. CR >
                     IF 1 R# ! AR I + C@ >R
                        ." A" I' 1+ S. AR + ." =" C@ S.
                        AR I' + C! R> S. AR I + 1+ C!
                     THEN
                  LOOP R# @ 0=          ( Все упорядочено?)
           UNTIL ;

   : TT 64 0 DO I 20 MOD 0=
                IF CR        ( "BK", если индекс кратен 20)
                THEN AR I + S@ .
           LOOP ;

   Оператор FILLING заполняет массив кодами с 64 до 0,  а TT позволяет
распечатать массив,  расположив по 20  элементов  в  строке.  Оператор
ORDER  сортирует и укладывает числа в порядке возрастания их значений.
Введенные в слово ORDER распечатки  дают  исчерпывающую  информацию  о
процессе сортировки и переукладки.  Но разумно ли такое решение?  Ведь
если запустить сейчас ORDER,  придется запастись терпением и временем:
ЭВМ согласно программе выдаст такое количество информации,  что пользы
от  этого  практически  не  будет.  Естественный  путь   при   отладке
многоцикловых  программ  -  на  первом  этапе  ограничить число циклов
одним-двумя.  И  только  после  того,  как  установлена   корректность
поведения  программы  для  ограниченного  числа циклов,  можно,  убрав
лишние отладочные печати,  запустить программу в  окончательном  виде.
При  отладке  программы слово за словом надо следить,  чтобы каждое из
них сохраняло указатель стека параметров,  а, если и меняло, то только
запланированно.  Если  в  стеке  по  завершении  работы слова остаются
ненужные коды, они должны быть удалены с помощью DROP или 2DROP.

   Алгоритм упорядочивания сводится к поочередному сравнению  значений
элементов.  Если  предшествующий  элемент больше последующего,  то они
меняются местами.  Внутренний цикл DO...LOOP осуществляет перебор всех
элементов   массива   и,  если  переставлены  хотя  бы  два  элемента,
выставляет  флаг  R#=1.  Это  указывает  на  необходимость   очередной
итерации,  которую  и  запускает  оператор UNTIL.  В этом примере стек
возвратов используется для хранения промежуточных результатов,  но так
как в цикле DO...LOOP применен индекс цикла (I),  то после >R и вплоть
до R> извлечь его можно только с помощью команды I',  что и делается в
операторе    ORDER.    Распечатка    номера    элемента    выполняется
последовательностью команд ." A" I'1  +  S.  ."  ="  AR  +  C@  S.,  в
результате начало распечатки имеет вид A1=64.


                   7.8. ДИАГНОСТИКА ОШИБОК


   В Форте имеется развитая система диагностического контроля, которая
при желании может быть дополнена пользователем.  К сожалению,  пока не
выработано  единого стандарта на сообщения об ошибках и на методику их
регистрации.  Ниже описан  диагностический  аппарат  одной  из  версий
FIG-FORTH.

   Главным оператором,  который  оформляет сообщение и выход в систему
при выявлении ошибок,  является ERROR.  Включение в  работу  оператора
ERROR осуществляется оператором ?ERROR (?ER):

      : ?ERROR SWAP IF ERROR ELSE DROP THEN ;

который предполагает  наличие  в  стеке флага и кода ошибки (последний
находится на верху стека). Флаг ошибки - это любое число, не равное 0.
Например, опишем заново операцию деления:

      : /-DUP 0= 26 ?ERROR /;

   Не беда,  что при его загрузке будет получено предупреждение MSG# 4
(IT ISN'T UNIQUE),  зато при попытке деления на нуль будет  выдаваться
сообщение  MSG# 26 (0 DIVISION) и выполнение программы будет прервано.
Аналогичное  усовершенствование  вы  можете  внести  самостоятельно  в
описание операции извлечения квадратного корня (см.  3.2).  (Напомню,
на ЭВМ типа СМ деление на нуль (в Форте,  так же как и в MACRO-11)  не
вызовет  прерывания,  результат  вычисления  будет заведомо неверным.)
Перечень диагностических сообщений FIG-FORTH  представлен  в  табл.25.
Кроме   перечисленных  в  таблице  сообщений  в  системе  присутствует
диагностика  ошибок  при  работе  с  внешними  устройствами   (диском,
цифропечатью и т.д.).  Но они,  с одной стороны, сильно варьируются от
версии к версии,  а с другой - достаточно легко понимаемы,  поэтому их
описание  здесь  опущено.  Исключение составляют сообщения:  DISK READ
ERROR # N и DISK WRITE ERROR # N, где N - код ошибки (ОС RT-11):

Таблица 26. Диагностические сообщения
----------------------------------------------------------------------
Сообщение при                                            Сообщения при
  WARNING=0            Значения                            WARNING=1
----------------------------------------------------------------------
MSC# 0     Слово не узнано.
           Число не узнано.
           Нет соответствия системе счисления

MSC# 1     Попытка извлечь нечто из пустого стека   EMPTY STACK

MSC# 2     Переполнение стека или словаря           STACK OR DIRECTORY
						    OVERFLOW

MSC# 4     Повторное описание слова (не является    IT ISN'T UNIQUE
	   фатальной ошибкой)

MSC# 17    Используется только при компиляции       COMPILATION ONLY

MSC# 18    Используется только при исполнении       EXECUTION ONLY

MSC# 19    IF и THEN или другие операторы           CONDITIONALS
	   не имеют пары                            AREN'T PAIRED

MSC# 20    Определение не завершено                 DEFINITION ISN'T
						    FINISHED

MSC# 21    Нелегальный аргумент слова FORGET        PROTECTED
	   Слово в защищенной части словаря         DIRECTORY

MSC# 22    Должно использоваться только             USED AT LOADING
           при загрузке                             ONLY

MSC# 26    Деление на 0                             0 DIVISION
----------------------------------------------------------------------

   N = 1 Данного диска нет в системе
   N = 2 Отсутствует управляющая программа внешнего устройства
   N = 3 Отсутствует файл DK:FORTH.DAT (или его заменяющий)
   N = 5 Что-то со стеком
   N = 6 Неудача при чтении
   N = 7 Ошибка при записи

   Определенный интерес представляет описание слова MESSAGE, которое в
FIG-FORTH служит для выдачи развернутых текстовых сообщений  длиной  в
одну строку:

   : MESSAGE IN @ R# ! ( сохранение указателя входного буфера в
			 R#)
	     WARNING @ IF                     ( если WARNING $0)
             -DUP IF   ( если код диагностического сообщения не
		         равен 0)
	     4 OFFSET @ -             ( выбор экрана с текстами
				      диагностических сообщений)
             .LINE                           ( печать сообщения)
             ELSE ." MSG # 0" THEN    ( если код ошибки равен 0)
             ELSE ." MSG # " . THEN ;  ( печать сообщения, если
					 WARNING =0)

   Управление работой  MESSAGE производится через системную переменную
WARNING.

         ┌───────────────────┐      ┌──────────────────────┐
         │ I N T E R P R E T │ ═══> │ Вам  M E S S A G E ! │
         └───────────────────┘      └──────────────────────┘

   Оператор .LINE,  используемый в слове MESSAGE,  печатает строку L с
экрана S, обращение имеет вид L S .LINE:

   : .LINE R>             ( запись номера экрана в стек возврата)
           64 1024 */MOD    ( частное указывает, на каком экране
			     по отношению к первому лежит
                             нужный текст)
	   R> +       ( запись в стек абсолютного номера экрана,
		            откуда будет проведено чтение строки)
           BLOCK +        ( считывание экрана в буфер и запись в
		            стек адреса начала нужной строки)
           64       ( в стеке адрес начала текста и длина строки)
	   -TRAILING         ( из 64 вычитается число пробелов в
		               конце строки)
	   TYPE ;                                ( печать строки)

   Из описания .LINE видно,  что этот  оператор  способен  распечатать
любую  строку из цепочки экранов,  начинающуюся с S.  Поэтому он может
быть полезен и для  других  целей.  Диагностические  сообщения  обычно
размещаются  на экранах 4 и 5.  Если это не так,  задачу можно решить,
поменяв значение OFFSET или исправив число,  стоящее  перед  OFFSET  в
описании   MESSAGE.   Коду  L  соответствует  в  MESSAGE  код  ошибки.
Использованная в .LINE команда ADR N -TRAILING сокращает значение N на
число пробелов между последним значащим символом и адресом ADR+N.

   Этот оператор  особенно  полезен  при  печати,  так  как  исключает
холостые пробеги каретки.  Видоизменив .LINE, можно получить оператор,
пригодный для печати любых текстов (см.,  например, INDEX), записанных
на  диске.  Вспомните   о   нем,   если   будете   писать   какую-либо
HELP-программу или другие слова, которые выдают подсказки оператору за
пультом ЭВМ.

   Упражнение 1.
   Опишите оператор LOAD, который производит загрузку экрана S начиная
со строки L. Обращение: S L SLOAD.

   Р е ш е н и е.

   : SLOAD BLK @ IN @            ( в стеке S L (BLK) и (IN) )
           ROT 64 * IN !           ( в стеке S (BLK) и (IN) )
           ROT BLK !        ( в стеке остались (BLK) и (IN) )
           INTERPRET ( интерпретация текста экранного буфера
                       начиная со строки L)
           IN ! BLK ! ;

(BLK) и  (IN)  -  номера  экрана  и  указателя  буфера  до обращения к
оператору SLOAD.

   Упражнение 2.
   Используя SCLR,  напишите  оператор,  который  заполняет  пробелами
серию экранов длиной K начиная с N. Присвойте ему имя SCB. При отладке
примите   необходимые  меры  безопасности  (запаситесь  копией  вашего
рабочего диска).

   Упражнение 3.
   Напишите программу,  которая распечатывает полное содержимое стека,
одновременно приводя его в базовое состояние (очищая его).

   Упражнение 4.
   Напишите описание оператора для преобразования восьмеричных чисел в
десятичные.

   Упражнение 5.
   Используя .LINE,  напишите  программу  LST,  которая  бы  выполняла
работу процедуры LIST.

   Упражнение 6.
   Сформируйте слово с именем LD, которое загружает последовательность
экранов, описанную в виде счетной строки с именем SLST.

   Р е ш е н и е . Пусть имеется счетная строка

   7 VARIABLE SLST 73 , 77 , 81 , 63 , 40 , 90 , 83 ,

(в списке 7 экранов). Тогда

   : LD SLST @            ( в стеке число загружаемых экранов)
        0 DO SLST 2+ I 2* + ( запись в стек адреса очередного
			      элемента списка)
        @ LOAD LOOP ;

   Если номера  экранов  не  превышают  256,  список может состоять из
байтов и в описании счетной строки следует заменить "," на C,.

   Упражнение 7.
   Как можно описать слово, размещенное на двух или более экранах?

   Р е ш е н и е.  Это можно сделать, используя команды переноса - -->
или  [N  LOAD],  которые  вводятся  в  конце  описания  на  экране  i,
продолжение  описания  располагается на экране i+1 для - --> или N для
LOAD.  Оператор - --> является,  как правило,  оператором немедленного
исполнения.  Операторы [ и ] осуществляют переход в режим исполнения и
компиляции соответственно. В этом случае скобка ] должна размещаться в
самом  начале  экрана  N.  Для LOAD,  а также для операторов DO,  IF и
других аналогичных это может привести к ошибкам,  так как  в  процессе
компиляции  они  засылают  в  стек флаги контроля парности операторов.
Более длинное описание LOAD:

   : LOAD BLK @ R IN @ R 0 IN ! BLK ! INTERPRET R> IN ! R> BLK ! ;

исключает эти  проблемы.  Поэтому  использование   оператора   -   -->
предпочтительнее.
