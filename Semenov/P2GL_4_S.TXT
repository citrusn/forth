          Глава 4. ВСПОМОГАТЕЛЬНЫЕ ОПЕРАТОРЫ И ПРОГРАММЫ

               4.1. ВЫХОДНОЕ ПРЕДСТАВЛЕНИЕ ИНФОРМАЦИИ


   Все операции в любой цифровой ЭВМ производятся над двоичными кодами
- сегодня это технически проще.  Но представьте себе, на экране вместо
FORTH IS HERE появится

      01001111 01000110 01010100 01010010 00100000 01001000
      01010011 01001001 01010010 01000101 00100000 01000101

или вместо числа 17 - код 10001? Вы, конечно, предпочтете, чтобы текст
был  написан  буквами,  а  цифры  в  десятичном (за редким исключением
восьмеричном или шестнадцатеричном) представлении. И в любом случае вы
хотите иметь возможность управлять процессом представления результатов
на экране (или печати).

   Некоторые операторы представления символов и  текстов  уже  описаны
(EMIT,  TYPE,  ."  ,..."  и  др.),  в  прикладном  плане рассмотрены и
некоторые операторы представления чисел ".",  "?", "S.", "U.R" и пр.).
Для написания многих программ этого вполне достаточно. Но программисту
приходится решать  и  неординарные  задачи.  Допустим,  надо  написать
программу для базы данных.  Банк данных должен пополняться, поэтому на
магнитном диске следует хранить указатели свободных зон оперативной  и
внешней  (дисковой)  памяти,  предназначенных для записи новых данных.
Можно,  конечно,  хранить эти данные в двоичной  форме  и  по  запросу
выводить  в  удобной  форме  на  экран,  но возможно и более наглядное
решение.

   На одном из  экранов  в  начале  текста  программы,  например  1-м,
описываются  переменные или массив переменных,  определяющие начальные
адреса свободных ячеек для записи информации.  При загрузке  программы
эти  переменные  оказываются включенными в словарь и в процессе работы
корректируются,  отражая реальное состояние системы на текущий момент.
По  завершении  работы  с  базой  данных  эти  переменные  заносятся в
буквенно-цифровом виде на выделенный  для  этого  экран  (1-й)  и  при
желании могут быть прочитаны с помощью стандартной команды LIST.

   В качестве   примера  рассмотрим  тексты  программы-справочника  по
интегральным схемам (ИС) [34].  Программа позволяет получать данные  о
наличии   ИС   и  зарубежных  аналогов,  динамике  расхода,  ожидаемых
поступлениях,  об основных параметрах,  цоколевке  ИС  и  т.д.,  имеет
встроенный  аппарат  пополнения  списка  ИС,  редактирования  данных и
внесения изменений (расход-приход). Эту программу нельзя рассматривать
как  базу  данных,  так  как  она  не имеет аппарата настройки на тип,
характер и структуру хранимой информации,  узко  специализирована  для
цифровых ИС и рассчитана на малые объемы памяти.  Но с другой стороны,
текст программы  занимает  шесть  экранов  (около  90  строк).  А  для
информации  о  500 типах ИС требуется на диске всего 200 блоков по 512
байт.  Современные базы данных представляют значительно больше  услуг,
но   указанная   программа   рассчитана  на  использование  на  стенде
инженера-наладчика с микроэвм и мини-диском.

   Прежде чем записать в текст на диске  какое-либо  число  нужно  его
преобразовать  в  последовательность  кодов  ASCII,  ведь  только  они
доступны для непосредственного воспроизведения на экране.  Аналогичная
задача возникает при реализации, например, оператора ".".

   Такое преобразование осуществляется посредством процедур <#, #S, #,
#>, SIGN и HOLD (табл.19). Все они используют временный буфер с именем
PAD,  положение  которого  жестко  связано с верхней границей словаря,
определяемой оператором HERE.

Таблица 19. Операторы преобразования чисел для выходного представления
----------------------------------------------------------------------
Имя   Состояние    Версия                Функция
        стека
----------------------------------------------------------------------
<#      u --> u    9, 3, F  Начинает процесс преобразования числа в
                            последовательность кодов ASCII. Исходное
                            число в стеке должно быть двойной длины
                            без знака

#                  9, 3, F  Преобразует одну цифру и записывает ее в
                            выходной буфер (PAD), выдает цифру всегда,
                            если преобразовывать нечего, записывается
                            0

#S                 9, 3, F  Преобразует число до тех пор, пока не
                            будет получен 0. Одна цифра выдается в
                            любом случае (0)

#>      --> адр n  9, 3, F  Завершает преобразование числа. В стеке
                            остается число полученных символов и
                            адрес, как это требуется для оператора
                            TYPE

SIGN               9, 3, F  Вводит знак "минус" в выходной буфер, если
                            третье число в стеке <0. Обычно
                            используется непосредственно перед #S

HOLD    S --> -     9, 3, F Вводит в текущую ячейку выходного буфера
                            символ, код которого в стеке. Должен
                            использоваться между <# и #>

Примечание 9 и 3 - стандарты Форт-79 и Форт-83, F - FIG-FORTH.
----------------------------------------------------------------------

   Оператор HOLD, используя системную переменную HLD, которая является
указателем позиции в выходном буфере (обычно PAD),  вводит в  выходной
буфер байт из стека и уменьшает на 1 значение указателя HLD.

   Оператор <# присваивает начальный адрес PAD-буфера переменной HLD:

      : <# PAD HLD ! ;

подготавливая все  для  преобразования.  При этом предполагается,  что
преобразуемое число занимает две верхние ячейки в стеке  параметров  и
не имеет знака.

   Оператор #  преобразует  одну цифру и помещает результат в выходной
буфер,  выдает 0,  если преобразовывать нечего  (или  встретится  код,
которому    нельзя    поставить   в   соответствие   никакую   цифру).
Преобразование осуществляется с учетом основания  действующей  системы
счисления BASE. Представление о работе # можно получить из описания:

      : # BASE @ M/MOD ROT'11 OVER < IF 7 + THEN'60 + HOLD ;

   Оператор #S  преобразует  число  до  тех  пор,  пока  в  результате
очередного преобразования не будет получен 0:

      : #S BEGIN # 2DUP OR 0= UNTIL ;

   Таким образом один 0 будет передан на выход в любом случае.

   Оператор SIGN посылает в выходной буфер  код  знака  "минус",  если
третье   сверху   число  в  стеке  отрицательное.  Обычно  SIGN  стоит
непосредственно перед #S.

   Оператор #>  завершает  преобразование,  в   результате   в   стеке
оказывается адрес начала строки символов, отображающих преобразованное
число,  а также их количество.  Таким образом содержимое  стека  может
быть  непосредственно  использовано  оператором  TYPE  для отображения
результата преобразования  на  экране  (или  печати).  Поясним  работу
операторов #> и SIGN следующим описанием:

             : #> 2DROP HLD @ PAD OVER - ;
             : SIGN ROT 0< IF '55 HOLD THEN ;

   Теперь вспомним  о  задаче,  с  которой  начался  разговор,   -   о
преобразовании   числовых  кодов  в  последовательность  кодов  ASCII.
Предположим,  в стеке указан адрес,  начиная с которого нужно записать
эту последовательность. Это может быть адрес в пределах буфера экрана,
что позволяет записать новый образ числа на диск. Пусть эта информация
должна быть занесена на строку 2 экрана 12, первые две строки которого
приведены ниже:

      : $ VARIABLE ; 0 $ BF 152 ALLOT 0 $ .Е 0 $ NSC : R@ R# @ ;
      27 $ BLP 813 $ PNT 88 $ PBL 948 $ OFS 42 $ PIB 775 $ PIO

   Оператор VARIABLE  переопределен,  чтобы сделать последующие записи
более компактными. Предположим, что в данный момент переменная BLP=28,
тогда  перезапись  текста  экрана можно произвести с помощью следующей
программы:

      12 BLOCK  ( в стеке адрес первого байта буфера, куда считан
                  экран 1.2)
      64 +                 ( в стеке адрес первого байта строки 2
                             [ADR])
      BLP @ ( в стеке значение переменной BLP = 28)
      0 <# #S #>    ( число 28 преобразовано в последовательность
               кодов ASCII. В стеке адрес буфера и число символов)
      R# !                           ( запись числа символов в R#)
      4 R# @ - ROT                        ( в стеке BUF 4-R#@ ADR)
      DUP 3 BLANKS            ( заполнение места, где записано 27
                                пробелами)
      + R# @                          ( в стеке BUF ADR+4-R#@ R#@)
      CMOVE        ( передача символов, число которых равно R# @,
                     из буфера с адресом ВОТ в буфер экрана,
                     начиная с ADR+4-R#@)

   Теперь, если выполнить команды UPDATE и FLUSH,  а затем просмотреть
экран,  дав  команду  12  LIST,  то  на месте числа 27 будет число 28.
Данный фрагмент можно записать короче,  если работать только со стеком
и  не  использовать  R#.  Эту  работу можно было выполнить,  используя
редактор EDT,  предварительно выяснив  значение  переменной  BLP.  Но,
во-первых,  таких  изменяемых  переменных в данной программе шесть,  а
во-вторых,  надо это делать каждый  раз  своевременно  и  безошибочно,
иначе   данные  в  справочнике  начнут  укладываться  друг  на  друга.
Автоматическая коррекция имеет ясные  преимущества,  да  и  сохранение
наглядности  немаловажный фактор.  Посмотрев на экран 12,  легко можно
узнать,  что  новые  имена  ИС  теперь  запишутся  на  экран   28.   В
рассмотренном  примере  все  корректируемые  переменные лежат на одной
строке на фиксированных местах, что предельно упрощает программу.

   В данной программе выборка задания осуществляется через меню.  Ниже
приведен пример выдачи данных на экран после запроса <наличие>:

      155TM7             SN7475 4-BIT LATCH, BIPOLAR OUT
      УХОД   НАЛИЧИЕ  ПАРАМЕТРЫ  TAB.ИСТИН.  СХЕМА  ЦОКОЛЬ  РЕДАКТОР
      ИМЕЕМ     = 56
      ЗАЯВКА    = 100
      ПОЛУЧЕНО  = 50
      ВЫДАНО    = 15
      ГОД НАЗАД = 75
      2 Г. НАЗАД= 48

   При этом курсор указывает на первую букву слова  <УХОД>.  Используя
клавиши  [->]  и  [<-],  можно  установить курсор на одно из слов этой
строки.  Положение  курсора  определяется  переменной  CURSOR,  равной
номеру  слова,  на которое указывает курсор,  умноженному на 2.  Слову
<УХОД> соответствует CURSOR  @  =0,  а  слову  <РЕДАКТОР>  -  12.  Для
реализации меню опишем слово TASK:

      : TASK OUT HAVE PARAM TRUTH SCHEME PINAGE EDIT ;

   Предполагается, что  все  слова,  входящие  в TASK,  описаны ранее.
Теперь по команде TASK CURSOR @ + @ EXECUTE управление будет  передано
процедуре, на имя которой указывает курсор.

   Ниже приведен фрагмент текста, содержащего начало списка заголовков
описаний ИС:

      : ALF ; ' ALF $Z !
      0 $ 155ЛАЗ 76 $ 155ЛА8 152 $ 155ЛЕ1 228 $ 155ТМ7 304 $ 155ЛЕ
      3 380 $ 155ЛП5 456 $ 155ЛЛ1 532 $ 155ЛИ1 608 $ 155ЛА13 684 $
      155ЛА11 760 @ 155ТЛЗ 836 $ 155ЛА12 912 $ 155ЛА9 988 $ 155АГ1

записанных сомой   программой-справочником.   Именно   поэтому   между
описаниями равные интервалы и переносы со строки на  строку  выполнены
чисто  функционально.  Заголовок  представляет  собой  имя переменной,
которое соответствует типу ИС,  а значение определяет номер  экрана  и
номер байта на этом экране,  с которого начинается описание для данной
ИС.  При загрузке программы-справочника  экраны  с  заголовками  также
загружаются.   Когда   при  запросе  печатается  имя  ИС,  то  в  стек
записывается код,  характеризующий место,  где находится информация  о
данной ИС, извлечь же эти данные уже нетрудно.

   Этот принцип   можно   реализовать  и  в  упрощенных  справочниках,
например,  для поиска зарубежных аналогов отечественных ИС. Достаточно
сформировать описания слов вида

      : 155ТМ7 ." SN7475 " ;  : 155ЛАЗ " SN7400 " ; и т.д.

и поместить их на экраны N,  N+1 и т.д.  Теперь,  если загрузить такую
цепочку экранов и напечатать, например, 155ЛАЗ <ВК>, ЭВМ выдаст SN7400
ОК. Если в начале 1-го экрана (N) поместить пустое слово :ALFA;, то по
завершении работы с таблицей  аналогов  достаточно  напечатать  FORGET
ALFA  и таблица будет удалена из словаря.  Можно также описать слова :
ANALOG N LOAD ;  и :  END FORGET ALFA ;, первое из которых должно быть
загружено  заранее.  Тогда,  набрав  на  пульте  ЭВМ  ANALOG <ВК>,  вы
загрузите таблицу аналогов,  а дав команду END  <ВК>,  удалите  ее  из
словаря.  Таблица  аналогов может быть и более сложной,  в этом случае
желательно написать управляющую программу,  которая будет  формировать
ее текст. Ниже рассмотрен упрощенный вариант такой программы.

   Введем переменную, которая является указателем в пределах экранного
буфера:  0 VARIABLE POINT. Опишем также слово ENTER, которое переносит
введенный с терминала текст в нужное место экранного буфера, указанное
переменной POINT.

   65 VARIABLE BLOK                       ( работа на экране 65)
   : BLO BLOK @ BLOCK ;

   : ENTER QUERY     ( ввод текста с терминала во входной буфер)
           BL WORD ( выделение слова и пересылка его в область,
		     указанную переменной HERE)
	   HERE COUNT        ( в стеке HERE+1 и число введенных
			       символов)
           >R BLO POINT @ +   ( вычисление адреса начала записи)
           R CMOVE           ( запись введенного текста в буфер)
           R> POINT +! ;                  ( коррекция указателя)
   : BEGI                   ( оформление начала нового описания)
	   '20072 ( код ": ")
           BLO DUP 1024 +       ( в стеке адреса начала и конца
                                  экранного буфера)
           >R POINT @ +          ( в стеке текущий адрес буфера)
           DUP R> OVER -      ( в стеке ADR ADR и число байт до
                       конца буфера. ADR - текущий адрес буфера)
           BLANKS           ( заполнение свободной части буфера
                              пробелами)
           ! 2 POINT +! ;          ( запись кода ": " в буфер и
                                     коррекция указателя)

   '27040 VARIABLE ANA '20042 , '21040 VARIABLE FIN '35440 ,
   ( массив ANA содержит последовательность символов < ." >, а
   FIN - последовательность < " ;>)
   : ANALOG ANA BLO POINT @ + 4 CMOVE          ( ввод < ." > в
					      в новое описание)
	   4 POINT +! ;          ( коррекция указателя массива)
   : $LOAD BEGI ." IC" ENTER    ( оформление начала описания и
				  ввод имени ИС-оригинала)
	  ANALOG " ANALOG>" ENTER         ( ввод имени аналога)
          FIN BLO POINT @ + 4 CHOVE    ( оформление завершения
				     описания - засылка < " ;>)
          6 POINT +! UPDATE FLUSH ;     ( коррекция указателя,
                                     запись результата на диск)

   Оператор $LOAD делает запрос на ввод, запись полученной информации,
оформление описаний и запись результатов  на  диск.  При  обращении  к
$LOAD, если на запрос IC> ответите 155ИМ1, а на ANALOG - SN7480, то на
строке 1 экрана 65 обнаружите  155ИМ1  ."  SN7480  ";.  При  повторном
обращении  к  $LOAD и вводе данных о другой ИС,  на экране 65 вслед за
первой появится следующее аналогичное  описание.  Это  только  модель.
Реальная  программа  $LOAD  должна  быть  дополнена  циклом  для ввода
последовательности  описаний,  а  также  командами  контроля  значения
переменной  POINT  и  оформления  перехода  на  следующий  экран (ввод
последовательности символов --> в конце текста экрана). При заполнении
очередного   экрана   должна   выполняться   процедура  1  BLOK  +!  и
корректироваться  код  65  на  экране,  где  записана  эта   программа
(описание переменной BLOK). Последовательность операторов UPDATE FLUSH
следует  выполнять  только  после  заполнения  экрана  или  завершении
работы.

   При желании  программу  можно легко дополнить операторами,  которые
будут загружать и удалять из словаря описания  именно  тех  серий  ИС,
какие вас интересуют. Можете выполнить эту работу сами.



     4.2. ОТОБРАЖЕНИЕ ТЕКСТОВ ПРОГРАММ И ВЫВОД ДАННЫХ НА ПЕЧАТЬ


   Для работы  со  словарем  из-за  особенностей  виртуального   файла
FORT.DAT  необходимо  иметь  под рукой средства,  которые бы позволяли
легко ориентироваться в среде Форта.  Дело в том,  что  в  виртуальном
файле   FORTH.DAT   может   содержаться   большое   число   экранов  с
разнообразными библиотеками. Найти нужный текст иногда непросто.

   Можно в начале диска,  например на экране 2,  с  помощью  редактора
создать  оглавление  этого файла.  Но,  если его нет,  к вашим услугам
оператор INDEX (табл.20).

Таблица 20. Сервисные операторы
----------------------------------------------------------------------
Имя   Состояние         Версия          Функция
        стека
----------------------------------------------------------------------
VLIST   - --> -         F        Отображает полный список слов
WORDS                   9, 3     в текущем словаре, заданном
                                 переменной, CURRENT


INDEX   n1 n2 --> -     9, 3, F  Выводит на экран верхние
                                 строки экранов начиная с n1 и
                                 кончая n2

THRU    n1 n2 --> -     9, 3, MV Последовательно загружает экраны
                                 начиная с n1 и кончая n2

HERE    - --> адр       9, 3, F  Выдает адрес первой свободной
                                 ячейки в словаре

PAD     - --> адр       9, 3, F  Выдает адрес буфера для
                                 промежуточного хранения
                                 последовательностей символов

COUNT   адр --> адр+1 u 9, 3, F  Преобразует последовательность
                                 символов, чья длина записана
                                 в первом байте, в форму, приемлемую
                                 для TYPE. При этом в стеке остается
                                 адрес первого символа и число
                                 символов в последовательности

TEXT    s --> -                  Читает последовательность символов
                                 из входного потока, используя символ
                                 s в качестве разграничителя, затем
                                 заполняет PAD кодами пробелов и
                                 переносит в PAD входную строку

>BINARY d1 адр1 -->     9, 3     Преобразует текст начиная с адр1+1
или     d2 адр2                  в двоичную форму с учетом BASE.
CONVERT                          Результат записывается в стек в виде
                                 числа двойной длины. адр2 - адрес
                                 первого преобразуемого символа

-TEXT   адр1 u адр2              Сравнивает две строки начиная
        --> t                    с адр1 и адр2. Длины строк
                                 =u. f=TRUE, если строки не
                                 совпали

DUMP    адр u --> -     9, 3, М  Отображает u байт памяти начиная
				 с адреса "адр"

П р и м е ч а н и е . см. примечание к табл.19. MV - MVPFORTH,
                      М - MMSFORTH.
----------------------------------------------------------------------

   При обращении  N1  N2  INDEX этот оператор напечатает первые строки
экранов начиная с N1 и кончая N2 включительно. INDEX будет эффективен,
если   на  первых  строках  экранов  помещена  специальная  справочная
информация или хранящийся там текст не оставляет сомнения о  характере
информации,  записанной  на экране.  Понятно,  что пустая (заполненная
пробелами) первая строка  -  наихудший  вариант,  желательно  помечать
пустые  экраны  специальными признаками,  например ;S <EMPTY>,  или ;S
ПУСТО,  или ." EMPTY".  Оператор  ;S  избавляет  вас  от  комментариев
интерпретатора,  если вы по ошибке загрузите такой экран, последний из
предлагаемых вариантов выдаст сообщение EMPTY ОК.  Если по  каким-либо
причинам  ваша  версия  базового  словаря  не  имеет  оператора  INDEX
(указатель),  можно его описать и включить в текст экрана, содержащего
служебные операторы:

      : INDEX 1+ SWAP DO CR I 3 .R SPACE 0 ( указание на нулевую
                                             строку)
           I .LINE LOOP ; (см. табл. 20 )

   При распределении  информации  на  экранах  следует  придерживаться
определенных правил.  Приведенные ниже  соображения  относятся  прежде
всего  к  версии  FIG-FORTH.  Экран  1  полезно сохранить для программ
стартовой загрузки, экраны 4 и 5 заняты в FIG-FORTH текстами системных
сообщений,  которые  можно  при  необходимости  расширять  и дополнять
(используются системой Форт,  если  системная  переменная  WARNING=1).
Экран  3  удобно  использовать для "быстрой" загрузки двоичного образа
редактора, ассемблера или других часто используемых библиотек.

   Для просмотра полного списка операторов, хранящихся в данный момент
в словаре, предназначено слово VLIST (весь список):

      : VLIST CONTEXT @ @ ( запись в стек адреса начала просмотра
                            словаря )
              BEGIN CR      ( начало бесконечного цикла просмотра)
                3 0 DO  ( информация о трех операторах помещается
                          в одну строку)

                      DUP ID. ( печать имени очередного оператора)
                      13 OVER C@ '37 AND ( вычисление длины имени
                                             очередного оператора)
                      - SPACES            ( организация табуляции
                                            операторов словаря)
                      PFA DUP 6 U.R SPACE  ( печать PFA оператора)
                      '41 EMIT SPACE                 ( печать "!")
                      LFA @    ( запись в стек значения константы
                                 связи)
                      DUP 0=                     ( конец словаря?)
                      IF LEAVE          ( если да, выход из цикла)
                      THEN
                    LOOP -DUP 0=        ( это действительно конец
                                                         словаря?)
              UNTIL ;

   VLIST печатает имя оператора и адрес  его  поля  параметров  (PFA),
информация  о  других  словах  в  строке  отделяется  восклицательными
знаками. Перечень начинается с последнего загруженного в словарь слова
и завершается первым оператором базового словаря. Таким образом, слова
из словарей,  которые не являются в данный момент контекстными, хотя и
есть в памяти, в отображаемый список не попадут.

                         ╔═════════════════╗
                         ║   V L I C T     ║
                         ║                 ║
                         ║  OVER  33888 !  ║
                         ║  2OVER 33906 !  ║
                         ║  2DROP 33926 !  ║
                         ║  SWAP  33938 !  ║
                         ║  2SWAP 33960 !  ║
                         ║  DUP   33990 !  ║
                         ║                 ║
                         ╚═════════════════╝

   Рассмотрим, как  устроен  оператор  ID.,  печатающий   имя   слова,
записанное в соответствии с требованиями словаря Форт:

      : ID. COUNT        ( в стеке адрес первого байта имени)
            '37 AND           (вычисление числа байт в имени)
         TYPE SPACE ;  ( распечатка имени с пробелом в конце)

   При обращении  к ID.  в стеке должен находиться адрес первого байта
описания слова (NFA).  При выдаче списка операторов  с  помощью  VLIST
можно  обнаружить  одно  безымянное  слово  -  0 (цифра 0).  Это может
вызвать  недоумение:  зачем  в  словаре  слово,  к   которому   нельзя
обратиться?  С  клавиатуры  такое имя ввести действительно нельзя (так
как вводятся только коды ASCII).  Слово 0 используется для  завершения
(прерывания)  процедуры интерпретации-исполнения.  Так как ввод текста
осуществляется оператором EXPECT, то любая вводимая строка завершается
двумя нулевыми байтами.

   Экранные буферы  также  имеют  в  конце два нулевых байта,  которые
прерывают интерпретацию при загрузке экрана. Описание слова 0:

      : 0 BLK @                                   ( экранный буфер?)
          IF                                              ( если да)
             1 BLK +!  ( переключение, указателя на следующий экран)
             0 IN !                  ( обнуление указателя смещения)
             ?EXEC                   ( система в режиме исполнения?)
          THEN R> DROP ;                              ( уход в QUIT)

   Здесь имя 0 записано условно,  в отлично от других описаний слово 0
(так же как ":" или ";") нельзя непосредственно смоделировать в Форте,
ведь  в  приведенном  примере  оператор имеет имя,  код ASCII которого
равен '60,  а не 0.  Оно формируется и присутствует только  в  базовом
словаре интерпретатора.

   При документировании текстов программ оказывается удобным размещать
тексты экранов по три на странице.  Такую  процедуру  реализует  слово
TRIO:

      : TRIO 12 EMIT     ( прогон бумаги в печатающем устройстве
                       на начало новой страницы. В случае выдачи
                       на экран никакого действия не вызывает)
             3 OVER    ( в стеке N 3 N)
             + SWAP    ( в стеке N+3 N)
             DO I LIST ( распечатка текста очередного экрана)
             LOOP ;

   Обращение к этому слову имеет форму : N TRIO, где N - номер первого
экрана в этой триаде.  При реализации программы, так же как и в INDEX,
применен  полезный  прием.  Вместо обычного цикла для трех экранов 3 0
DO...LOOP,  организован цикл N+3 N DO...LOOP. Это сократило и ускорило
выполнение  программы,  в  чем читатель может убедиться сам.  В версии
FIG-FORTH процедура TRIO присутствует в базовом  словаре.  Приведенная
программа выдает тексты на экран по умолчанию,  что удобно для беглого
просмотра.

   Для управления выводом информации на печатающее устройство  введена
системная переменная PNT.  Если PNT=0,  информация выводится только на
экран,  при PNT =/= 0 - на экран и печатающее устройство одновременно.
Для  переключения  переменной  PNT  в ненулевое состояние используется
оператор  PRINT.   Присвоение   нулевого   значения   переменной   PNT
производится оператором TTY.  Любые обмены, происходящие между PRINT и
TTY, обязательно будут посланы и на печатающее устройство. Программист
должен только позаботиться, чтобы оно было включено. Если вы рассеяны,
ЭВМ напомнит вам о ваших обязанностях, но включить принтер не сможет.

   Можно записать арифметические действия в привычной форме,  например
2 *  2?  Конечно,  можно.  Опишем  сначала  оператор  CONVERT  (версия
FIG-FORTH):

      : CONVERT BL WORD HERE NUMBER DROP ;

   В некоторых версиях Форта операторы  HERE  и  DROP  будут  лишними.
Теперь переопределим основные арифметические операции:

                     : + CONVERT + ;
		     : - CONVERT - ;
                     : * CONVERT * :
                     : / CONVERT / ;

   При загрузке этой программы  вы  получите  букет  предупреждений  о
повторном  описании  уже  известных  операторов,  но  зато в пультовом
режиме сможете наслаждаться  привычной  формой  записи  арифметических
операции.  Аналогично можно переопределить операторы LIST, LOAD и т.д.
Однако,  чтобы использовать традиционную форму записи и  при  описании
слов,  нужны  более серьезные ухищрения,  возможны и более эффективные
реализации.  Но это хорошо лишь в качестве упражнения. Форт эффективен
именно благодаря своим особенностям и,  если вы хотите воспользоваться
его достоинствами, надо расстаться с некоторыми привычками.



                        4.3. РЕКУРСИЯ


   К числу   достоинств  Форта  относится  и  возможность  рекурсии  -
разрешение процедуре обращаться к самой себе в процессе исполнения. Но
если написать :  AGAIN 1+ AGAIN ;,  интерпретатор напечатает AGAIN?. А
это  означает,  что  он  с  этим   оператором   еще   незнаком   (ведь
интерпретация  слова AGAIN не завершена).  Чтобы обойти эту трудность,
воспользуемся оператором RECUR:

      : RECUR LATEST    ( определение адреса поля имени (NFA) для
                          слова, в котором встретится оператор RECUR)
              PFA CFA   ( определение адреса поля команды этого
                          слова )
              , :       ( занесение вычисленного адреса в поле
                          параметров на место слова RECUR и
                          обеспечение обращения оператора к самому
                          себе)
              IMMEDIATE ( оператор RECUR работает в режиме
                          интерпретации)

   Позаботимся и  о  том,  чтобы  своевременно  выйти  из рекурсивного
процесса, ведь рекурсия - еще один вид бесконечного цикла:

         : LEV R> DROP ;

         : TT DUP 1+ DUP . DUP 10 = IF LEV THEN RECUR ;

   При обращении к рекурсивной процедуре TT: 0 TT <ВК> получим

      1 2 3 4 5 6 7 8 9 10 OK
      - - - - - - - - - -- --

   Часть программы  10  =  IF  LEV THEN - процедура контроля состояния
процесса и  выхода  из  цикла  при  выполнении  определенного  условия
(содержимое   стека   10).  Существуют  и  другие  способы  выхода  из
рекурсивного цикла, например ту же процедуру можно переписать в виде

      : TT DUP 1+ DUP . DUP 10 < IF RECUR THEN ;

   Здесь управление  передается  на  рекурсивный  вызов   только   при
определенном условии (содержимое стека < 10).

   Пусть описаны слова A и B, причем в слове A есть ссылка на слово B,
а в слове В - на слово A.  Это простейший пример  косвенной  рекурсии.
Непосредственно  смоделировать  эту  ситуацию  с  помощью системы Форт
невозможно,  так как при описании A будет выдано сообщение об  ошибке,
ведь оператор B еще не описан.  Как быть, если все же очень нужно (или
очень хочется) написать такую программу? Обманем интерпретатор. Опишем
сначала пустой оператор : DUMMY 0 ;, а затем по порядку:

             : B DUMMY ;
             : A DUP 1+ DUP . DUP 10 < IF В THEN ;

и, наконец,  выполним команду 'A CFA  'DUMMY  !,  которая  подменит  в
операторе  DUMMY  ссылку  на  0  ссылкой  на A.  Обратившись 0 A <ВК>,
получим  распечатку,  идентичную  приведенной  для  прямой   рекурсии.
Разумеется,  между  именем  В и DUMMY может находиться текст некоторой
программы. Используя описанную технику приведения косвенной рекурсии к
прямой, можно написать довольно изощренную рекурсивную программу.

   Эта реализация  косвенной  рекурсии  не  является  полным аналогом.
прямой рекурсии, здесь при каждом цикле в стек возвратов заносится три
кода,  что  при  большом  числе итераций может привести к переполнению
стека возвратов.  Поэтому уход из цикла,  как в первом варианте прямой
рекурсии,  невозможен. Выполнив команду 'A CFA'В !, можно сделать цикл
рекурсии короче (без обращения к  DUMMY),  но  тогда  нельзя  помещать
какие-либо операторы между именем и DUMMY в описании В.


             4.4. ВЫБОР ЗАДАНИЯ ИЗ "ДЛИННОГО" СПИСКА

                      (ИСПОЛНИТЕЛЬНЫЕ ВЕКТОРЫ)


   Выше был  приведен  случай  выбора  и  исполнения  задания,  на имя
которого указывает курсор.  Но  сходные  проблемы  возникают  в  самых
разных  задачах.  Из них наиболее распространенная - это распознавание
последовательности  кодов,  посылаемых  при   нажатии   функциональной
клавиши,  и исполнение задания соответствующего этой клавише. Примером
такой задачи является  уже  описанный  экранный  редактор  (см.  также
приложение 1).  Рассмотрим текст операторов - анализаторов управляющих
кодов  (см.  также  описание  оператора  EDT  гл.4   ч.1).   Программа
предназначена   для  распознавания  ESC-последовательностей  различной
длины,  одиночных управляющих кодов, а также кодов ASCII и запрещенных
кодов.

   : TT 0          ( в стеке код символа и адрес списка управляющих
	             кодов)
	  DO 2DUP 1 + C@ =
	    IF ( символ узнан) 2DROP LEAVE I 12 - ( кодирование
                                                    номера символа)
            THEN
          LOOP DUP 0<
          IF 12 + 2* + @ EXECUTE ( вычисление адреса и
			 передача управления узнанной процедуре)
          ELSE DROP DUP 31 >
               IF ( ввод символа в текст буфера) SS
               ELSE DROP IL ( символ не узнан, дается звуковой
                              сигнал )
               THEN
          THEN ;

   ( Операторы-списки процедур)

   : T3 LINE .T EL WST ++ CUT DS BUP SEE PAGE DW IL ;
   : .P ' T3                                ( запись в стек PFA T3)
        KEY ( ожидание нажатия клавиши) L1 ( запись в стек
				      PFA списка управляющих кодов)
        14 + 12 TT ;
   : T2 ^ V << >> HP GLD DLL .P ; ( .P - процедура анализа
                         очередного символа ESC-последовательности)
   : P. ' T2                                ( запись в стек PFA T2)
        KEY ( ожидание нажатия клавиши) L1 6 + 8 TT ;
   : T1 P. ^L DEL ^W DEL ;

   Рассмотрим задачу в несколько более обобщенном виде.  Пусть описаны
процедуры  A,  B,  C,  ...,  K  и  пусть  в  каком-то  месте программы
вычисляется число N  (0<=N<=10),  которое  определяет  тип  процедуры,
подлежащей исполнению.  Предполагается, что каждой процедуре из списка
A, B, C, ..., K поставлено в соответствие число 0, 1, 2...,10. Выбрать
нужную процедуру можно следующим образом.  Опишем слово : TASK A В C D
Е F G H I К ;.  Доступ к нужному оператору  осуществит  команда  N  2*
'TASK  +  @  EXECUTE.  'TASK  задает адрес поля параметров слова TASK,
который указывает  на  код,  равный  CFA  слова  A.  Если  реализовать
аналогичную функцию, используя IF...ELSE...THEN, запись окажется более
длинной.  Причем с увеличением списка процедур длина  такой  программы
будет расти квадратично. Например:

      : TTT -DUP IF DUP 1 = IF DROP В ELSE DUP 2 = IF DROP C ELSE
            DUP 3 = IF DROP D ELSE DUP 4 =IF DROP E ELSE ......
             ..... THEN THEN ..... ELSE A THEN ; ( текст с целью
                                       экономии места сокращен)

   Здесь еще нет проверки того,  что N находится  в  нужном  интервале
значений.

   Это решение  приемлемо,  если  N<=4,  когда  значения N не являются
числами из натурального ряда.  Например,  при N=26 должна  выполняться
процедура C, при N=27 - процедура A, при N=33 - процедура В и т.д. При
длине списка  заданий  N>5  вычисляемый  оператор  EXECUTE  становится
предпочтительнее.  При числе альтернатив более 10 даже при значениях N
не из  натурального  ряда  вычисляемый  EXECUTE  остается  единственно
возможным.  В  последнем  случае надо только сначала преобразовать N в
число из натурального ряда.  Такое преобразование может быть выполнено
различными методами, например, определим слова

      N1 VARIABLE NN N2, N3, ... NM, ( описан массив NN
                                       из M чисел)

      N1 N2, ...NM не являются числами натурального ряда, т.е.

      N    -N  =/= 1.
       i+1   i

      : FIND M 0 DO DUP NN I 2* + @ = IF DROP I LEAVE THEN LOOP ;

   В результате  выполнения команды N FIND в стек будет записано число
из  натурального  ряда  0<=K<=M-1,  которое  и  будет  использовано  в
вычисляемом EXECUTE.


             4.5. ПОИСКОВО-ИНФОРМАЦИОННЫЕ ПРОГРАММЫ


   Применение ЭВМ   для   управления   и  контроля  не  обходится  без
справочно-информационных  программ.  Это  могут  быть   базы   данных,
программы  типа HELP,  которыми снабжаются практически все современные
пакеты  прикладных  программ,  или  более  простые  чисто   справочные
программы.

   Обычно данные  хранятся на диске в рамках того или иного экрана или
группы экранов. Простейшая информационная система может быть построена
следующим образом. Пусть на экране N хранится текст типа

               ." ВОКЗАЛЫ " : ВОКЗАЛЫ K0 LOAD ; CR
               ." ДРУЗЬЯ "  : ДРУЗЬЯ  K1 LOAD ; CR
               ." АВАРИЯ "  : АВАРИЯ  K2 LOAD ; CR и т.д.

   Последнее описание может содержать телефоны аварийных служб, скорой
помощи,  лечащего врача,  милиции и пр.  При загрузке экрана  N  будет
распечатана  левая  колонка  заголовков-рубрик,  сообщая о том,  какие
информационные операторы размещены на данном экране.  Выбрав рубрику и
напечатав,  например,  слово  "ДРУЗЬЯ",  мы загрузим экран K1 (в общем
случае это будет  цепочка  экранов),  который  может  содержать  новый
аналогичный  список  рубрик или непосредственно справочную информацию.
Если у вас много друзей, и вы хотите записать в файл их дни рождений и
другие семейные даты, а также любую другую информацию, то это может не
поместиться на одном экране, например:

      : ВАСЯ_СМИРНОВ ." дом. 319-24-22. раб. 122-00-02 Род. 7 июля
      1938." CR ." Дочери: Наташа род 9 нояб. и Татьяна род. 10
      дек." CR ." жена Лариса род 20 янв. Свадьба 14 авг. и т.д."
      CR ; -->

--> после  последней  записи  на  экране  автоматически обеспечит ввод
следующего по порядку экрана.  Если информация о друзьях  записана  не
подряд,  то вместо --> следует записать A LOAD, где A - номер экрана с
нужной информацией.  Чтобы текст оставался на экране и  не  вытеснялся
последующими  записями,  в  начале очередного экрана полезно поместить
команду KEY DROP.  Это потребует нажатия любой клавиши  для  просмотра
очередной  порции информации.  DROP нужно для стирания кода клавиши из
стека.  Когда вы убедились,  что экран  с  интересующими  вас  данными
загружен,  вы печатаете,  например, "ВАСЯ_СМИРНОВ" <ВК> и получаете на
экране весь приведенный выше текст.

   Описанная структура справочной  системы  доступна  для  начинающих.
Это,  конечно,  не база данных, но для личного телефонного справочника
она подходит вполне.

   Современное программирование развивается в направлении, при котором
для  освоения  того  или  иного  пакета программ требуется минимальное
знакомство с его описанием или его не требуется вовсе. Достигается это
за счет встраивания справочных систем HELP (см. приложение 5), которые
по запросу могут предоставить пользователю исчерпывающую информацию  о
тех  или  иных  функциях  системы  или подсказать возможные действия в
сложившихся   обстоятельствах.   Обычно   справочные   системы   имеют
иерархическую   структуру.  При  ее  вызове  сначала  выявляется  тема
запроса,  а  затем  уточняются  разделы  и   подуровни.   Ниже   будут
рассмотрены некоторые возможности формирования таких справочных систем
на Форте.

   Вызов программы  осуществляется   командой   HELP   (или   нажатием
соответствующей  клавиши),  загружающей  нужный  стартовый  экран (или
последовательность экранов) и в конце концов  выдающей  меню  тем,  по
которым   имеется   справочный   материал.  Возможны  варианты,  когда
пользователю предлагается самому напечатать тему запроса.  При  ошибке
ввода или при отсутствии информации по затребованной теме пользователь
получит соответствующее уведомление.  Как правило,  при таком  способе
нужную информацию можно получить после ряда проб и ошибок.  Через меню
дорога к цели  короче,  но  это  возможно  только  при  малых  объемах
справочных данных.

   Программа HELP,  приведенная  в  приложении  5,  предназначена  для
работы на терминале СМ7209 или на совместимом с ним  по  клавиатуре  и
управляющим  последовательностям.  Это  влияет  на  технику фиксации и
перемещения курсора по  экрану,  а  также  на  способ  переключения  с
русского  алфавита на латинский и обратно.  Загрузка стартового экрана
может проводиться различными способами (см.  гл.4 ч.1). При загрузке в
верхней  части  экрана  появится  текст меню в виде,  представленном в
конце программы HELP.  Курсор  устанавливается  перед  словом  "УХОД".
Используя клавиши [->],  [<-],  [/\],  [\/], можно установить курсор и
перед названием нужной вам темы и нажать  клавишу  <HELP>.  Выполнение
команд здесь проще, чем в экранном редакторе EDT. По положению курсора
определяется номер числа в массиве TS  (Text  Screens)  и  загружается
экран,  на который указывает это число. Количество элементов в массиве
TS определяет число входов в справочную систему (в данном  случае  11,
что  соответствует  числу  тем в меню).  Как видно,  при такой системе
адресации  к  справочному  материалу  не  требуется,  чтобы  экраны  с
информацией   были   расположены   подряд.   Операторы,   связанные  с
перемещением курсора (FIX,  NT,  EX), идентичны или сходны с теми, что
использованы  в  экранном  редакторе  EDT.  Слова  RU  и LA служат для
переключения дисплея на русский и латинский алфавиты соответственно.

   Справочный текст экрана  21  при  выводе  на  экран  выглядит  куда
пригляднее.  Главной заботой при размещении его на диске была экономия
места.  Когда полный текст-комментарий  на  экране  не  помещается,  с
помощью   оператора   -->   вызывается   следующий  экран.  Количество
вызываемых  друг  за  другом  экранов  не  ограничено.  При   загрузке
справочных   экранов  словарь  Форта  остается  без  изменений.  Когда
текст-комментарий отображен на экране полностью, курсор возвращается в
меню и устанавливается снова перед словом "УХОД". Если при этом нажать
клавишу <HELP>,  управление будет передано в систему  Форт,  но  часть
словаря,  созданная при загрузке справочной системы, будет сохранена и
вы можете ее снова вызвать командой HELP <ВК>.  Если хотите удалить из
словаря справочную систему,  выдайте команду FORGET $ <ВК>. $ - первое
слово,  описанное на экране справочника.  При  необходимости  создания
многоуровневой  системы  запросов можно при загрузке очередного экрана
сменить меню,  а по завершении  работы  на  данном  справочном  уровне
восстановить старое меню, соответствующее более высокому уровню.


                    4.6. РАБОТА С ФАЙЛАМИ


   До сих  пор  речь  шла  в основном о работе с файлом FORTH.DAT.  Во
многих  случаях  этого  файла  вполне   достаточно.   Для   работы   с
произвольными файлами возможны различные решения.  Все,  что связано с
файлами,  к сожалению,  специфично для  каждой  конкретной  реализации
Форт-интерпретатора.   Поэтому   прежде   чем   приступить  к  работе,
проконсультируйтесь с представителем фирмы, откуда вы получили систему
Форт, и запаситесь соответствующими описаниями и руководствами.

   Рассмотрим вариант для операционной системы RT-11 (TSX). Идея этого
варианта проста и основана на изменении  имени  виртуального  файла  в
программе-драйвере   диска.   Для   реализации  этих  функций  введены
операторы OFILE, CLOSE, DEFOL, FILCH и CHFILE:

   OFILE - открытие нового виртуального  файла;  перед  использованием
OFILE имя файла должно быть изменено с помощью оператора CHFILE.

   CHFILE - замена имени виртуального файла, например, RK : FORTH.DAT,
на новое,  адрес первого байта  которого  хранится  в  стеке  (команда
базового  словаря  Форта  (RT-11)).  Имя  файла должно быть записано в
кодах RAD50 (для персональных ЭВМ в кодах ASCII),  в этом  случае  имя
занимает  четыре  ячейки.  Устанавливает  каналы  обмена  с  диском  в
исходное состояние.  Если необходимо что-то сохранить  на  диске,  это
следует сделать до выдачи команды CHFILE.

   CLOSE - закрытие файла,  открытого ранее с помощью OFILE (EDT, LIST
и т.д.),  на диске возникает новый файл с тем что было в него записано
между командами OFILE и CLOSE.

   Для записи  в новый файл экранов из других виртуальных файлов можно
использовать оператор FILCH.  Текст  оператора  FILCH,  а  также  ряда
других вспомогательных слов представлен ниже:

   : RAD5 DUP 32 = ( преобразование кода ASCII, хранящегося в
                     стеке, в формат RAD50)
          IF DROP 0                ( если в стеке код пробела)
          ELSE DUP 36 =                    ( если это код "$")
               IF DROP 27
               ELSE DUP 45 > OVER 58 < AND
                    IF 18 -                       ( если код цифры)
                    ELSE DUP 64 > OVER 91 < AND
                         IF 64 -                  ( если код буквы)
                         ELSE DROP 0              ( если код не узнан)
                         THEN
                    THEN
               THEN
          THEN ;
   : R50 DUP C@ RAD5 40 * SWAP 1+ DUP C@ RADS ROT + 40 * SWAP
         1+ C@ RAD5 + ;   ( формирование слова в формате RAD50)
   : NUM HERE NUMBER DROP ; ( преобразование строки символов в
			      число )

   см. Приложение 7

   : ADR HERE 1+ PAD ;                : MOV HERE C@ CMOVE ;
   : RCON PAD CFA 12 0 DO 2+ PAD I + R50 OVER ! 3 +LOOP ;
   : FILCH PAD 20 BLANKS     ( заполнение буфера PAD пробелами)
           ." FILE=" QUERY     ( ввод имени файла с клавиатуры)
           '72 WORD ADR MOV '56 WORD ADR 3 + MOV 32 WORD ADR 9
           + MOV              ( передача имени файла, удаление
			        разделительных кодов ":" и ".")
           RCON    ( преобразование имени файла в RAD50-формат)
           PAD ( имя в буфере PAD) CHFILE ;     ( запись имени)

   Оператор RAD5 преобразует код ASCII в код RAD50,  а R50  объединяет
три   кода   RAD50   в   одно   слово.   Операторы  ADR  и  MOV  чисто
вспомогательные,  способствуют более компактной записи  программы,  их
функции    очевидны    из    описания.   Оператор   RCON   преобразует
последовательность из 12 кодов ASCII в последовательность  из  четырех
слов  в  кодах  RAD50.  Исходная  и  конечная последовательности кодов
хранится  в  буфере  PAD.  Слово  NUM  преобразует  последовательность
символов, записанную, начиная с HERE, в число одинарной длины.

   Оператор FILCH  работает  в диалоговом режиме.  Если нужно изменять
имя файла без  вмешательства  оператора,  это  имя  в  соответствующим
формате  должно  быть записано в массив,  например NEWFILE,  а команда
NEWFILE CHFILE выполнит работу, эквивалентную FILCH.

   Копирование экранов  в   пределах   одного   файла   осуществляется
оператором  COPY (см.  приложение 1).  Обращение:  М N COPY,  при этом
экран М записывается на место N.  Содержимое экрана  N  теряется.  Для
перемены  мест экранов М и N может служить оператор SWAS,  обращение к
которому аналогично: М N SWAS.

   : SWAS >R ( запись N в стек возвратов)

          BLOCK           ( вызов в буфер информация, записанной
                            на экране M)
          CFA DUP @            ( запись в стек параметров адреса
                              заголовка экрана и его содержимого)
          I BLOCK            ( вызов в "соседний" буфер экрана N)
          CFA !                      ( присваивание ему номера M)
          UPDATE                    ( установка флага "спасения")
          R> '100000 OR            ( операция UPDATE для блока N)
          SWAP !                   ( запись заголовка в буфере N)
          FLUSH ;     ( запись содержимого обоих экранов на диск)

   Теперь рассмотрим   возможность   обмена   экранами   между   двумя
виртуальными файлами (оператор SCOP):

   : SCOP ." FROM " FILCH ( запрос ввода имени файла и номера экрана)
          32 WORD NUM ( выделение кода, следующего за именем файла и
                        преобразование его в число)
          BLOCK CFA   ( считывание нужного экрана в буфер и запись в
                        стек адреса идентификатора буфера)
          ." TO " FILCH DROP 32 WORD
          NUN SWAP !                 ( замена номера экрана N1 на N2)
          UPDATE      ( установка флага "спасения") FLUSH ;

   Схема такого  обмена проста:  сначала в качестве имени виртуального
файла записывается с  помощью  оператора  FILCH  имя  файла-источника,
считывается нужный экран в буфер, в заголовке блока записывается номер
экрана-адресата и устанавливается флаг "спасения" (процедура  UPDATE).
Наконец,   в   качестве  имени  виртуального  файла  записывается  имя
файла-адресата и  производится  запись  буфера  на  диск.  Информация,
которая хранилась там прежде,  теряется. При обращении к слову SCOP на
экране появляется запрос "FROM FILE=", на который надо ответить:

      DXi:<NAME>.<EXT> N1

   DXi - имя внешнего устройства,  где лежит файл-источник (это  может
быть  DK,  DY,  MX  и  т.д.),  <NAME>  и  <EXT>  -  имя  и  расширение
файла-источника (наличие "."  и  ":"  обязательно,  так  как  их  коды
используются  в  качестве разделителей оператором WORD в слове FILCH);
N1 -  номер  экрана-источника.  Формат  ответа  на  запрос  "TO  FILE"
идентичен,   но  имя  внешнего  устройства  (D2),  имя  файла-адресата
(<NAME2>.<EX2>) и номер экрана-адресата будут другими.  По  завершении
обмена    система   Форт   будет   работать   с   виртуальным   файлом
D2.<NAME2>.<EX2>.  Вы можете поменять их произвольно с  помощью  FILCH
или на DK:FORTH.DAT с помощью оператора DEFOL.

   Много неожиданных   возможностей   предоставляет   версия  Форта  -
FOREGROUND.  Для работы с ней необходим FB-монитор.  Версия FOREGROUND
(RT-11)    получается,    если   воспользоваться   редактором   связей
LINK/FOREGROUND FORTH.  Загрузка FOREGROUND производится командой FRUN
FORTH  из  ОС  RT-11.  В  общем случае для эффективной работы в режиме
FOREGROUND надо произвести некоторые переделки  в  интерпретаторе,  но
для  простых  задач  этого не требуется,  и вы это можете попробовать,
если  располагаете  файлом  FORTH.OBJ.  Режим  работы   в   FOREGROUND
устраняет  изоляцию  Форта  от  операционной  системы,  так как в этом
случае к вашим услугам весь сервис RT-11  в  режиме  BACKGROUND.  Так,
нажав ^В,  перейдем в режим BACKGROUND, и используя команду DIR, можно
просмотреть оглавление дисков. Нажмите ^F, и вы снова в Форте.

   Интересные возможности при работе с файлами предоставляет  оператор
ASSIGN  (ОС).  По  приведенной ниже схеме можно работать с несколькими
виртуальными файлами на разных дисках:

      CLOSE           ( закрывание рабочего файла)
      ^В              ( переход в режим BACKGROUND)
      ASS DX0: DK:    ( в DX0 находится еще один диск с файлом
                        FORTH.DAT , возможны и временные
                        переименования файлов)
      ^F              ( возврат в режим FOREGROUND, здесь
                        также возможна замена имени
                        виртуального файла)

      Работа с файлом на DX0.

      CLOSE ^В
      ASS DX1: DK: ^F ( возврат к работе со "старым" виртуальным
		     файлом на DX1)

   Здесь приведен  лишь  один вариант,  режим FOREGROUND предоставляет
много других возможностей. Ограничения здесь связаны только с памятью,
оставшейся для задач BACKGROUND (RT-11).

   Как всякая программа в FOREGROUND, Форт загружается непосредственно
перед FB-монитором в "верхнюю"  часть  памяти.  (С  картой  абсолютных
адресов  загрузки  FOREGROUND  можно  познакомиться  в  [28].) Главное
преимущество описанного режима заключается в том,  что можно уходить в
RT-11 и при возврате не тратить время на загрузку системы Форт.

   Упражнение 1.
   Опишите оператор,    который    заносит     в     первые     строки
последовательности   экранов,  начинающиеся  с  экрана  N,  записи  ;S
<EMPTY>. Обращение к оператору: N L EMPTY, где L - число экранов, куда
заносится указанная строка.

   Упражнение 2.
   Напишите программу,  которая  распечатает  содержимое  всего  файла
FORTH.DAT.  Полное  число  экранов  в  файле предполагается известным.
Составьте также  программу,  выдающую  текст  любого  заданного  числа
экранов начиная с N.

   Упражнение 3.
   Опишите оператор   N!,   который   вычисляет    факториал    числа,
находящегося в стеке, используя рекурсию.
