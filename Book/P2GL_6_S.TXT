                 Глава 6. ВЕКТОРЫ, СТРОКИ, МАССИВЫ


   Структуры, перечисленные   в  заголовке,  наряду  с  переменными  и
константами  являются  объектами,  с  которыми  программист   работает
постоянно.  Векторы и строки - это одномерные массивы чисел и символов
соответственно.  Несколько примеров простых  одномерных  массивов  уже
было описано. Это A0 VARIABLE A1 , A2 , A3 , A4 , или 0 VARIABLE AA NN
ALLOT.  В обоих случаях размер массива известен,  в первом  -  это  10
байт, во втором - NN+2 байт. Векторы и строки представляют собой более
организованные структуры.  Примером  описания  вектора  может  служить
следующее [35]:

      : VECTOR <BUILDS 2* ALLOT DOES> SWAP 1 - 2* +;

   Обращение к  этому  оператору  на  фазе описания нового вектора:  N
VECTOR <NAME>,  где N - число  16-разрядных  кодов  в  векторе  (длина
вектора), а <NAME> - имя нового вектора. Возможен и другой вариант:

      : VECTOR <BUILDS DUP , 2* ALLOT DOES> SWAP 1+ 2* +;

   В этом  случае  обращение к описанному вектору будет иметь вид:  IN
<NAME>, в результате в стек будет записан адрес кода вектора с номером
IN (нумерация начинается с 0).  Второе описание отличается тем, что по
адресу PFA+2 находится число,  равное длине вектора. Это удобно, когда
размер вектора вычисляется программой до его описания. В более сложном
варианте реализации оператора [35] при обращении  к  вновь  описанному
вектору контролируется условие 0<=IN<=L,  где L - длина вектора. Такое
усовершенствование может быть легко добавлено ко второму описанию.

   Примером строки может служить описание оператора STRING (строка):

   : STRING                     ( описание структур типа "строка")
              <BUILDS           ( описание нового входа в словарь)
              HERE BL WORD      ( введение в описание строки ее
                                  значения по умолчанию)
              C@ 1+ ALLOT ALIGN ( выравнивание конца описания по
                                  четному адресу, что необходимо
                                  для ЭВМ типа СМ)
              DOES> COUNT ;

   Пример использования  этого оператора приведен в приложении 3,  где
STRING использован для  описания  строки  с  именем  ALF.  Эта  строка
содержит  последовательность из 48 символов,  которые образуют алфавит
для плакатной  печати.  Каждая  буква  при  этой  печати  отображается
матрицей  5x7 элементов *.  Модели всех букв и символов представлены в
массиве PAT.  Приведенный текст программы ориентирован на операционную
систему  RT-11,  в  случае  персональной ЭВМ типа IBM PC она несколько
упростится.

   Более сложную структуру имеют двумерные массивы, например ARRAY:

   : ARRAY <BUILDS 2DUP , , * ALLOT DOES>
           SWAP OVER @ * + + 4 + ( в PFA+2 и PFA+4 записаны
           коды числа рядов [RM] и колонок в массиве [CM] ) ;

   Массив CM  занимает  в  поле  PFA  C*R+4  байт  (элементом  массива
является  байт).  В этом описании также нет контроля номера строки R и
колонки C, о чем можно сожалеть особенно при отладке программы.

   При описании новых массивов обращение к  ARRAY  имеет  вид:  CM  RM
ARRAY  <NAME>,  например  8  8 ARRAY CHESS ("Шахматная доска").  Пусть
элемент с C=0 и R=0 черного цвета.  Цвет  клетки  определяется  знаком
байта,  а наличие и тип фигуры - кодом,  записанным в этот байт. Таким
образом,  чтобы определить цвет поля и тип фигуры на поле R=7  и  C=5,
надо  выдать  команду 5 7 CHESS C@.  В результате в стек будет записан
искомый код.



         6.1. БИБЛИОТЕКА ОПЕРАТОРОВ ДЛЯ РАБОТЫ СО СТРОКАМИ


   Характерная задача для редакторов текстов (CHI-WRITER, TEX, VENTURE
и  т.д.),  трансляторов,  баз  данных  и  пр.  -  работа  со  строками
(последовательностями символов). Хотя операторы для работы со строками
за редким исключением не входят в базовый словарь, многие версии Форта
снабжаются библиотеками таких операторов,  хранящимися на диске. Здесь
рассмотрим вариант библиотеки из FIG-FORTH.

   Многие операторы библиотеки функционально аналогичны процедурам над
числами.  Для строк создается специальный стек.  Указатель стека строк
($SP)  является  стандартной  Форт-переменной.  Имена  операторов  для
работы  со строками начинаются с символа $ или ^ (см.  табл.23).  Так,
слово,  устанавливающее стек строк (SS) в базовое состояние, имеет имя
$CLEAR (аналог SP!  для стека параметров).  Данная библиотека работает
со счетными строками,  т.е.  со строками, первый байт которых содержит
код длины строки. Ниже дается краткое описание некоторых операторов из
этой библиотеки:

Таблица 23. Операторы для работы со строками
----------------------------------------------------------------------
Имя     Состояние         Версия              Функция
          стека
----------------------------------------------------------------------
ARRAY     n --> -         М       Слово-описатель, которое создает
                                  массив (вектор) чисел  одинарной
				  длины.  Используется как; n ARRAY
				  name, где name - имя массива, для
				  которого выделяется n+1 ячеек памяти.
				  Обращение к вновь описанному слову:
               			  j name. В результате в стек будет
				  записан (j+1)-й элемент массива

ASC       адр -->  n      М       Записывает в стек первый символ
                                  счетной строки, с началом по адресу
                                  "адр"

2ARRAY    n1 n2 --> -     М       Слово-описатель, создающее двумерный
                                  массив чисел одинарной длины с
                                  именем <name>. Используется как n1
                                  n2 2ARRAY <name>. Массив будет иметь
                                  n1 рядов и n2 столбцов. Обращение
                                  к вновь описанному слову: k1 k2
                                  <name>, где k1, k2 - номера ряда и
                                  столбца

$!        адр1 адр2 --> - M, F    Переносит счетную строку с адр1 и
                                  записывает ее начиная с адр2

S"        - --> адр       М       Записывает строку, выделенную ", в
                                  PAD, адрес которого заносится в стек

$+        адр1 адр2 -->адр3 M, F  Добавляет счетную строку с началом
                                  по адр2 к счетной строке с началом
                                  по адр1 и помещает новую строку в
                                  PAD, адрес которого записывается в
                                  стек

$-TB      адр --> адр     М       Удаляет пробелы в конце счетной
                                  строки и исправляет счетный байт

$.        адр --> -       M, F    Отображает строку, начинающуюся по
                                  адресу "адр", на экране.
                                  Эквивалентно COUNT TYPE

$ICOMPARE адр1 адр2 --> а M       Сравнивает две счетные строки и
($COMP)                   F       записывает в стек -1, 0 или 1 в
                                  зависимости от того, является ли
                                  строка, начинающаяся с адр1, больше,
                                  равна или меньше строки по адр2

$CONSTANT - -             М       Слово-описатель, создающее строку -
                                  константу. Обращение; $CONSTANT
                                  <name> <строка>" образует слово с
                                  именем <name>, текст строки
                                  выделен ". При обращении <name> в
                                  стек записывается адрес начала
                                  строки

$VARIABLE n --> -         М       Слово-описатель, создающее строку -
                                  переменную. Обращение: n $VARIABLE
                                  <name> образует строку с именем
                                  <name> и длиной n+1 байт. В
                                  исходный момент счетный байт равен
                                  0. При обращении к <name> в стек
                                  записывается адрес этой счетной
                                  строки

$XCHG     адр1 адр2 --> - М       Меняет местами строки, начала
                                  которых лежат по адр1 и адр2. Длины
                                  строк должны быть идентичны

Примечание. F - FIG-FORTH, М - MMSFORTH.
----------------------------------------------------------------------

   $LEN
   выдает в стек значение длины строки, хранящейся в стеке SS, если же
стек пуст, сообщает " $STACK EMPTY" и осуществляет уход в QUIT;

   $DROP
   удаляет строку из SS (аналог DROP);

   $.
   выдает строку на экран, удаляя ее из SS;

   $COUNT
   преобразует адрес  в стеке параметров в адрес начала строки и число
символов в ней (последнее число на верху стека);

   $@TEXT
   пересылает последовательность  символов  в  стек строк при условии,
что адрес начала этой  последовательности  и  число  элементов  в  ней
записаны в стек параметров;

   $@
   пересылает строку,  адрес которой лежит в  стеке  параметров,  в
стек строк. ( : $@ COUNT $@ TEXT ;) ;

   $!
   пересылает строку из SS в память начиная  с  адреса,  указанного  в
стеке параметров;

   $DUP
   дублирует последнюю строку в SS  (аналог  DUP  для  чисел  в  стеке
параметров);

   $SEG
   засылает в  SS  сегмент  текста,  адрес  начала  и  конца  которого
определен в стеке параметров;

   $OVER
   аналог OVER для строк в SS;

   $SWAP
   аналог SWAP для строк в SS;

   $COMP
   сравнивает две  верхние  строки  в  SS,  удаляет  их  из  стека,  а
результат  сравнения  записывается в стек параметров (0 означает,  что
все элементы короткой строки совпадают с элементами строки 2);

   $+
   соединяет две строки в одну;

   $DIM
   создает в словаре Форт строку-переменную длиной,  заданной числом в
стеке параметров;

   $NULL
   создает "нулевую" строку (одно нулевое слово в SS);

   $STR
   преобразует число  из  стека  параметров в последовательность кодов
ASCII и засылает их в SS:

   : $STR S -> D  SWAP OVER DABS                    ( в стеке S |D|)
          <# # SIGN #>      ( преобразование числа в
                              последовательность кодов ASCII)
          $@TEXT ;

   Здесь приведен ограниченный список операторов лишь для того,  чтобы
пояснить назначение и некоторые возможности  библиотеки  процедур  для
работы со строками.


                    6.2. ВИРТУАЛЬНЫЕ МАССИВЫ


   Нередко требуется  организовать  хранение больших объемов данных на
магнитном диске.  Для информации объемом 1 Кбайт  (экран)  необходимый
аппарат взаимодействия имеется в базовом словаре (BLOCK,  BUFFER, LOAD
и т.д.).  Но 1 Кбайт - слишком  крупная  единица  информации.  Удобный
доступ  к  данным на диске предоставляет описанная в FIG-FORTH система
виртуальных  массивов.  Единица  информации  (запись)  в   виртуальном
массиве   может   иметь  любую  длину.  Желательно,  чтобы  на  экране
укладывалось целое число записей,  поэтому ряд возможных значений длин
записи имеет вид:  1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 байт. В
виртуальном массиве могут храниться отдельные байты (символы),  числа,
последовательности  символов (строки,  тексты) и массивы чисел.  Длина
записи постоянная,  для виртуального массива длина  задается  при  его
описании.  Разумеется,  у  различных  массивов длина записи может быть
разной.

   Пусть мы хотим описать виртуальный массив с именем VIRA из  записей
длиной  L  и  знаем,  что  на  диске  начиная  с  экрана  М достаточно
свободного места.  Поставленную задачу можно решить,  записав  L  N  М
VIRRAY VIRA.  В словаре появится новое слово с именем VIRA. Теперь при
обращении K VIRA программа считает с диска нужный экран  и  запишет  в
стек адрес первого байта K-го элемента (записи) массива.  Если K>N или
К<0,  система выдаст сообщение OUT OF V-ARRAY, т.е. заказанный элемент
не  может  лежать  в  пределах  данного  массива.  Если предполагается
описать  совокупность  виртуальных  массивов,   целесообразно   ввести
переменные,   где   будут  храниться  номер  экрана  и  номер  первого
свободного   байта.   Эта   информация    будет    использоваться    и
корректироваться  при  каждом очередном описании виртуального массива,
что избавит  программиста  от  необходимости  самому  следить,  где  и
сколько свободного места на диске.

   Виртуальные массивы  элементов  - удобный инструмент при построении
баз данных,  всевозможных справочных систем, программ типа HELP и т.д.
Если  элемент  виртуального  массива исправлен или переписан,  для его
записи на диск необходимо до обращения к  какому-либо  другому  экрану
выполнить  команду  UPDATE,  а  по  завершении  всей процедуры - FLUSH
(SAVE-BUFFERS).    Допускается    описание    виртуальных    массивов,
перекрывающихся  на  диске  частично  или полностью и имеющих,  вообще
говоря,  различную длину записей.  Ниже приведено  описание  оператора
VIRRAY:

   : VIRRY <BUILDS        ( образование нового входа в словарь
		    с именем описываемого виртуального массива)
           , ,  ( запись в PFA нового слова номера экрана, где
                 начинается виртуальный массивен числа записей
                 в нем)
           DUP ,                   ( запись в PFA длины записи)
           1024 SWAP / ,       ( запись в новое описание числа
                            записей, которые могут поместиться
                            на одном экране)
           DOES>               ( формирование CFA нового слова)
           >R              запись в стек возвратов адреса PFA,
                         где хранится номер стартового экрана;
                                   начало обработки параметров
                         виртуального массива и входных данных)
           DUP I        ( в стеке REC REC SCR, где REC - номер
                          записи, SCR - адрес, кода стартового
                          экрана)
           2+             ( запись в стек адреса числа записей
                            в массиве)
           @ < OVER 0< OR      ( номер запрашиваемой записи в
                                         допустимых пределах?)
           IF                    ( если номер записи не верен)
             ." OUT OF V-ARRAY"            ( печать сообщения)
             R> DROP
           ELSE        (если номер записи в пределах допусков)
           I 6 + @    ( запись в стек числа записей на экране)
           /MOD   ( в стеке номер записи, приращение к номеру
		    экрана )
           I @ +                 ( вычисление номера экрана с
				        запрашиваемой записью)
           BLOCK                  ( считывание нужного экрана)
           SWAP R> 4 + @
           * +    ( определение адреса первого байта записи в
		    буфере)
           THEN ;

   В PFA  слова  VIRA  хранится  адрес  ссылки на VIRRAY (PFA),  номер
стартового экрана (PFA+2),  полное число записей  в  массиве  (PFA+4),
длина записи (PFA+6) и число записей на экране (PFA+8).  Описанный так
виртуальный массив должен начинаться с первого элемента  на  стартовом
экране.

   Упражнение 1.
   Опишите виртуальный массив,  начинающийся с произвольного  элемента
на экране.

   Упражнение 2.
   Как можно  использовать  массив  VIRRAY  при  написании   экранного
редактора?

   Упражнение 3.
   Опишите слово с формой обращения: адр n DUMP, которое распечатывает
в  восьмеричной  и  символьной форме n байт начиная с адреса "адр".  С
помощью этого оператора распечатайте описание переменной  константы  и
массива.

   Решение.

   : DUMP BASE @ R           ( запись в стек возвратов основания
		               системы счисления)

        OCTAL                ( установление восьмеричной системы)
        8 / 0 DO    ( начало цикла распечаток последовательности
		      байтов по 8 в строке)

                DUP 7 U.R SPACE   ( распечатка начального адреса
				    строки)
                8 0 DO     ( начало цикла распечатки очередных 8
			     байт)
                    DUP I + C@ 4 .R           ( распечатка байта)
                    LOOP 4 SPACES
                8 0 DO        ( начало цикла распечатки тех же 8
				байт в символьной форме)
                     DUP I + C@ DUP        ( код символа в стеке)
                     32 < OVER '176 > OR      ( это код символа?)
                     IF DROP '56 THEN   ( если нет, печатаем ".")
                     EMIT                  ( отображение символа)
                    LOOP
                CR 8 +                 ( переход на новую строку)
              LOOP DROP R> BASE ! ;         ( завершение цикла и
                                восстановление системы счисления)

   При определении  адреса массива вспомните об операторе '(апостроф).
Попробуйте переписать эту программу для распечатки чисел,  а не  байт.
Сравните это описание с тем,  что содержится в тексте интерпретатора в
приложении 9.

   Упражнение 4.
   Опишите слово,  которое  содержит список заданий,  аналогично тому,
что описано в гл.4,  но занимающее меньше места в памяти (не требующее
";" в конце).

   Решение.
   CREATE TASKLIST ] TASK1 TASK2...TASK 10[

   В данном примере в списке 10 слов-заданий,  все они  предполагаются
описанными  ранее.  Использование  аналогично  рассмотренному  в гл.4.
Такая структура называется иногда исполнительным вектором.
